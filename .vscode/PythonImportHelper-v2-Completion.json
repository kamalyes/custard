[
    {
        "label": "asyncio",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "asyncio",
        "description": "asyncio",
        "detail": "asyncio",
        "documentation": {}
    },
    {
        "label": "OrderedDict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "defaultdict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "OrderedDict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "OrderedDict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "ChainMap",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "Counter",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "functools",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "functools",
        "description": "functools",
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "_CacheInfo",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "_make_key",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "partial",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "wraps",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "reduce",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "wraps",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "wraps",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "wraps",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "wraps",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "wraps",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "wraps",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "wraps",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "reduce",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "wraps",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "logging",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "logging",
        "description": "logging",
        "detail": "logging",
        "documentation": {}
    },
    {
        "label": "DEBUG",
        "importPath": "logging",
        "description": "logging",
        "isExtraImport": true,
        "detail": "logging",
        "documentation": {}
    },
    {
        "label": "ERROR",
        "importPath": "logging",
        "description": "logging",
        "isExtraImport": true,
        "detail": "logging",
        "documentation": {}
    },
    {
        "label": "FATAL",
        "importPath": "logging",
        "description": "logging",
        "isExtraImport": true,
        "detail": "logging",
        "documentation": {}
    },
    {
        "label": "INFO",
        "importPath": "logging",
        "description": "logging",
        "isExtraImport": true,
        "detail": "logging",
        "documentation": {}
    },
    {
        "label": "WARN",
        "importPath": "logging",
        "description": "logging",
        "isExtraImport": true,
        "detail": "logging",
        "documentation": {}
    },
    {
        "label": "getLogger",
        "importPath": "logging",
        "description": "logging",
        "isExtraImport": true,
        "detail": "logging",
        "documentation": {}
    },
    {
        "label": "threading",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "threading",
        "description": "threading",
        "detail": "threading",
        "documentation": {}
    },
    {
        "label": "redis",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "redis",
        "description": "redis",
        "detail": "redis",
        "documentation": {}
    },
    {
        "label": "json",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "json",
        "description": "json",
        "detail": "json",
        "documentation": {}
    },
    {
        "label": "random",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "random",
        "description": "random",
        "detail": "random",
        "documentation": {}
    },
    {
        "label": "randint",
        "importPath": "random",
        "description": "random",
        "isExtraImport": true,
        "detail": "random",
        "documentation": {}
    },
    {
        "label": "uniform",
        "importPath": "random",
        "description": "random",
        "isExtraImport": true,
        "detail": "random",
        "documentation": {}
    },
    {
        "label": "re",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "re",
        "description": "re",
        "detail": "re",
        "documentation": {}
    },
    {
        "label": "string",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "string",
        "description": "string",
        "detail": "string",
        "documentation": {}
    },
    {
        "label": "ascii_letters",
        "importPath": "string",
        "description": "string",
        "isExtraImport": true,
        "detail": "string",
        "documentation": {}
    },
    {
        "label": "digits",
        "importPath": "string",
        "description": "string",
        "isExtraImport": true,
        "detail": "string",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Text",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Collection",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypeVar",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "AsyncIterator",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "ContextManager",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterator",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Type",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypeVar",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "cast",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "ClassVar",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Generic",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Mapping",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Type",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypeVar",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "cast",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Generic",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypeVar",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Generic",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypeVar",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Generic",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypeVar",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypeVar",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Generic",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypeVar",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypeVar",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypeVar",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Pattern",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "AsyncIterator",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterator",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "urllib.parse",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "urllib.parse",
        "description": "urllib.parse",
        "detail": "urllib.parse",
        "documentation": {}
    },
    {
        "label": "quote",
        "importPath": "urllib.parse",
        "description": "urllib.parse",
        "isExtraImport": true,
        "detail": "urllib.parse",
        "documentation": {}
    },
    {
        "label": "pypinyin",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pypinyin",
        "description": "pypinyin",
        "detail": "pypinyin",
        "documentation": {}
    },
    {
        "label": "Faker",
        "importPath": "faker",
        "description": "faker",
        "isExtraImport": true,
        "detail": "faker",
        "documentation": {}
    },
    {
        "label": "Faker",
        "importPath": "faker",
        "description": "faker",
        "isExtraImport": true,
        "detail": "faker",
        "documentation": {}
    },
    {
        "label": "Faker",
        "importPath": "faker",
        "description": "faker",
        "isExtraImport": true,
        "detail": "faker",
        "documentation": {}
    },
    {
        "label": "InvalidURL",
        "importPath": "requests.exceptions",
        "description": "requests.exceptions",
        "isExtraImport": true,
        "detail": "requests.exceptions",
        "documentation": {}
    },
    {
        "label": "LocationParseError",
        "importPath": "urllib3.exceptions",
        "description": "urllib3.exceptions",
        "isExtraImport": true,
        "detail": "urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "parse_url",
        "importPath": "urllib3.util",
        "description": "urllib3.util",
        "isExtraImport": true,
        "detail": "urllib3.util",
        "documentation": {}
    },
    {
        "label": "Moment",
        "importPath": "custard.time.moment",
        "description": "custard.time.moment",
        "isExtraImport": true,
        "detail": "custard.time.moment",
        "documentation": {}
    },
    {
        "label": "base64",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "base64",
        "description": "base64",
        "detail": "base64",
        "documentation": {}
    },
    {
        "label": "hashlib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "hashlib",
        "description": "hashlib",
        "detail": "hashlib",
        "documentation": {}
    },
    {
        "label": "sha1",
        "importPath": "hashlib",
        "description": "hashlib",
        "isExtraImport": true,
        "detail": "hashlib",
        "documentation": {}
    },
    {
        "label": "datetime",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "datetime",
        "description": "datetime",
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timedelta",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "date",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timedelta",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "date",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "date",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "time",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timezone",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "jwt",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "jwt",
        "description": "jwt",
        "detail": "jwt",
        "documentation": {}
    },
    {
        "label": "sys",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sys",
        "description": "sys",
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "xml.dom.minidom",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "xml.dom.minidom",
        "description": "xml.dom.minidom",
        "detail": "xml.dom.minidom",
        "documentation": {}
    },
    {
        "label": "xml.etree.ElementTree",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "xml.etree.ElementTree",
        "description": "xml.etree.ElementTree",
        "detail": "xml.etree.ElementTree",
        "documentation": {}
    },
    {
        "label": "zip_longest",
        "importPath": "itertools",
        "description": "itertools",
        "isExtraImport": true,
        "detail": "itertools",
        "documentation": {}
    },
    {
        "label": "islice",
        "importPath": "itertools",
        "description": "itertools",
        "isExtraImport": true,
        "detail": "itertools",
        "documentation": {}
    },
    {
        "label": "dicttoxml",
        "importPath": "dicttoxml",
        "description": "dicttoxml",
        "isExtraImport": true,
        "detail": "dicttoxml",
        "documentation": {}
    },
    {
        "label": "etree",
        "importPath": "lxml",
        "description": "lxml",
        "isExtraImport": true,
        "detail": "lxml",
        "documentation": {}
    },
    {
        "label": "text_type",
        "importPath": "six",
        "description": "six",
        "isExtraImport": true,
        "detail": "six",
        "documentation": {}
    },
    {
        "label": "binary_type",
        "importPath": "six",
        "description": "six",
        "isExtraImport": true,
        "detail": "six",
        "documentation": {}
    },
    {
        "label": "text_type",
        "importPath": "six",
        "description": "six",
        "isExtraImport": true,
        "detail": "six",
        "documentation": {}
    },
    {
        "label": "Xml2Dict",
        "importPath": "custard.core.xml2dict",
        "description": "custard.core.xml2dict",
        "isExtraImport": true,
        "detail": "custard.core.xml2dict",
        "documentation": {}
    },
    {
        "label": "BatchTask",
        "importPath": "custard.cron",
        "description": "custard.cron",
        "isExtraImport": true,
        "detail": "custard.cron",
        "documentation": {}
    },
    {
        "label": "time",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "time",
        "description": "time",
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "perf_counter",
        "importPath": "time",
        "description": "time",
        "isExtraImport": true,
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "csv",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "csv",
        "description": "csv",
        "detail": "csv",
        "documentation": {}
    },
    {
        "label": "custard",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "custard",
        "description": "custard",
        "detail": "custard",
        "documentation": {}
    },
    {
        "label": "kaptcha",
        "importPath": "custard",
        "description": "custard",
        "isExtraImport": true,
        "detail": "custard",
        "documentation": {}
    },
    {
        "label": "kaptcha",
        "importPath": "custard",
        "description": "custard",
        "isExtraImport": true,
        "detail": "custard",
        "documentation": {}
    },
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "platform",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "platform",
        "description": "platform",
        "detail": "platform",
        "documentation": {}
    },
    {
        "label": "yaml",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "yaml",
        "description": "yaml",
        "detail": "yaml",
        "documentation": {}
    },
    {
        "label": "DataHand",
        "importPath": "custard.core.processor",
        "description": "custard.core.processor",
        "isExtraImport": true,
        "detail": "custard.core.processor",
        "documentation": {}
    },
    {
        "label": "bisect",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "bisect",
        "description": "bisect",
        "detail": "bisect",
        "documentation": {}
    },
    {
        "label": "timegm",
        "importPath": "calendar",
        "description": "calendar",
        "isExtraImport": true,
        "detail": "calendar",
        "documentation": {}
    },
    {
        "label": "tzutc",
        "importPath": "dateutil.tz",
        "description": "dateutil.tz",
        "isExtraImport": true,
        "detail": "dateutil.tz",
        "documentation": {}
    },
    {
        "label": "copy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "copy",
        "description": "copy",
        "detail": "copy",
        "documentation": {}
    },
    {
        "label": "struct",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "struct",
        "description": "struct",
        "detail": "struct",
        "documentation": {}
    },
    {
        "label": "abstractmethod",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "ABC",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "abstractmethod",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "Random",
        "importPath": "Crypto",
        "description": "Crypto",
        "isExtraImport": true,
        "detail": "Crypto",
        "documentation": {}
    },
    {
        "label": "AES",
        "importPath": "Crypto.Cipher",
        "description": "Crypto.Cipher",
        "isExtraImport": true,
        "detail": "Crypto.Cipher",
        "documentation": {}
    },
    {
        "label": "PKCS1_OAEP",
        "importPath": "Crypto.Cipher",
        "description": "Crypto.Cipher",
        "isExtraImport": true,
        "detail": "Crypto.Cipher",
        "documentation": {}
    },
    {
        "label": "PKCS1_v1_5",
        "importPath": "Crypto.Cipher",
        "description": "Crypto.Cipher",
        "isExtraImport": true,
        "detail": "Crypto.Cipher",
        "documentation": {}
    },
    {
        "label": "RSA",
        "importPath": "Crypto.PublicKey",
        "description": "Crypto.PublicKey",
        "isExtraImport": true,
        "detail": "Crypto.PublicKey",
        "documentation": {}
    },
    {
        "label": "Counter",
        "importPath": "Crypto.Util",
        "description": "Crypto.Util",
        "isExtraImport": true,
        "detail": "Crypto.Util",
        "documentation": {}
    },
    {
        "label": "uuid",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "uuid",
        "description": "uuid",
        "detail": "uuid",
        "documentation": {}
    },
    {
        "label": "pymysql",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pymysql",
        "description": "pymysql",
        "detail": "pymysql",
        "documentation": {}
    },
    {
        "label": "traceback",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "traceback",
        "description": "traceback",
        "detail": "traceback",
        "documentation": {}
    },
    {
        "label": "FileNotFoundError",
        "importPath": "custard.script.compat",
        "description": "custard.script.compat",
        "isExtraImport": true,
        "detail": "custard.script.compat",
        "documentation": {}
    },
    {
        "label": "basestring",
        "importPath": "custard.script.compat",
        "description": "custard.script.compat",
        "isExtraImport": true,
        "detail": "custard.script.compat",
        "documentation": {}
    },
    {
        "label": "builtin_str",
        "importPath": "custard.script.compat",
        "description": "custard.script.compat",
        "isExtraImport": true,
        "detail": "custard.script.compat",
        "documentation": {}
    },
    {
        "label": "numeric_types",
        "importPath": "custard.script.compat",
        "description": "custard.script.compat",
        "isExtraImport": true,
        "detail": "custard.script.compat",
        "documentation": {}
    },
    {
        "label": "str",
        "importPath": "custard.script.compat",
        "description": "custard.script.compat",
        "isExtraImport": true,
        "detail": "custard.script.compat",
        "documentation": {}
    },
    {
        "label": "stdev",
        "importPath": "statistics",
        "description": "statistics",
        "isExtraImport": true,
        "detail": "statistics",
        "documentation": {}
    },
    {
        "label": "fmean",
        "importPath": "statistics",
        "description": "statistics",
        "isExtraImport": true,
        "detail": "statistics",
        "documentation": {}
    },
    {
        "label": "importlib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "importlib",
        "description": "importlib",
        "detail": "importlib",
        "documentation": {}
    },
    {
        "label": "inspect",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "inspect",
        "description": "inspect",
        "detail": "inspect",
        "documentation": {}
    },
    {
        "label": "istraceback",
        "importPath": "inspect",
        "description": "inspect",
        "isExtraImport": true,
        "detail": "inspect",
        "documentation": {}
    },
    {
        "label": "BytesIO",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "Image",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "ImageDraw",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "ImageFont",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "ImageFilter",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "conint",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "create_model",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "conint",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "conint",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "Request",
        "importPath": "starlette.requests",
        "description": "starlette.requests",
        "isExtraImport": true,
        "detail": "starlette.requests",
        "documentation": {}
    },
    {
        "label": "Response",
        "importPath": "starlette.responses",
        "description": "starlette.responses",
        "isExtraImport": true,
        "detail": "starlette.responses",
        "documentation": {}
    },
    {
        "label": "status",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "Depends",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "FastAPI",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "Request",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "Response",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "Query",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "Query",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "Query",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "Depends",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "FastAPI",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "Depends",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "FastAPI",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "Depends",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "FastAPI",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "utilities",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "utilities",
        "description": "utilities",
        "detail": "utilities",
        "documentation": {}
    },
    {
        "label": "math",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "math",
        "description": "math",
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "arrays",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "arrays",
        "description": "arrays",
        "detail": "arrays",
        "documentation": {}
    },
    {
        "label": "ctypes",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "ctypes",
        "description": "ctypes",
        "detail": "ctypes",
        "documentation": {}
    },
    {
        "label": "sysconfig",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sysconfig",
        "description": "sysconfig",
        "detail": "sysconfig",
        "documentation": {}
    },
    {
        "label": "IntEnum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "requests",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "requests",
        "description": "requests",
        "detail": "requests",
        "documentation": {}
    },
    {
        "label": "contextmanager",
        "importPath": "contextlib",
        "description": "contextlib",
        "isExtraImport": true,
        "detail": "contextlib",
        "documentation": {}
    },
    {
        "label": "suppress",
        "importPath": "contextlib",
        "description": "contextlib",
        "isExtraImport": true,
        "detail": "contextlib",
        "documentation": {}
    },
    {
        "label": "ContextVar",
        "importPath": "contextvars",
        "description": "contextvars",
        "isExtraImport": true,
        "detail": "contextvars",
        "documentation": {}
    },
    {
        "label": "get_parameterless_sub_dependant",
        "importPath": "fastapi.dependencies.utils",
        "description": "fastapi.dependencies.utils",
        "isExtraImport": true,
        "detail": "fastapi.dependencies.utils",
        "documentation": {}
    },
    {
        "label": "lenient_issubclass",
        "importPath": "fastapi.dependencies.utils",
        "description": "fastapi.dependencies.utils",
        "isExtraImport": true,
        "detail": "fastapi.dependencies.utils",
        "documentation": {}
    },
    {
        "label": "APIRoute",
        "importPath": "fastapi.routing",
        "description": "fastapi.routing",
        "isExtraImport": true,
        "detail": "fastapi.routing",
        "documentation": {}
    },
    {
        "label": "APIRouter",
        "importPath": "fastapi.routing",
        "description": "fastapi.routing",
        "isExtraImport": true,
        "detail": "fastapi.routing",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "func",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "select",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "Column",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "Integer",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "String",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "Column",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "Integer",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "String",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "create_engine",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "asdict",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "GenericModel",
        "importPath": "pydantic.generics",
        "description": "pydantic.generics",
        "isExtraImport": true,
        "detail": "pydantic.generics",
        "documentation": {}
    },
    {
        "label": "conint",
        "importPath": "pydantic.types",
        "description": "pydantic.types",
        "isExtraImport": true,
        "detail": "pydantic.types",
        "documentation": {}
    },
    {
        "label": "conint",
        "importPath": "pydantic.types",
        "description": "pydantic.types",
        "isExtraImport": true,
        "detail": "pydantic.types",
        "documentation": {}
    },
    {
        "label": "Query",
        "importPath": "sqlalchemy.orm",
        "description": "sqlalchemy.orm",
        "isExtraImport": true,
        "detail": "sqlalchemy.orm",
        "documentation": {}
    },
    {
        "label": "sessionmaker",
        "importPath": "sqlalchemy.orm",
        "description": "sqlalchemy.orm",
        "isExtraImport": true,
        "detail": "sqlalchemy.orm",
        "documentation": {}
    },
    {
        "label": "Session",
        "importPath": "sqlalchemy.orm",
        "description": "sqlalchemy.orm",
        "isExtraImport": true,
        "detail": "sqlalchemy.orm",
        "documentation": {}
    },
    {
        "label": "sessionmaker",
        "importPath": "sqlalchemy.orm",
        "description": "sqlalchemy.orm",
        "isExtraImport": true,
        "detail": "sqlalchemy.orm",
        "documentation": {}
    },
    {
        "label": "Select",
        "importPath": "sqlalchemy.sql",
        "description": "sqlalchemy.sql",
        "isExtraImport": true,
        "detail": "sqlalchemy.sql",
        "documentation": {}
    },
    {
        "label": "ast",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "ast",
        "description": "ast",
        "detail": "ast",
        "documentation": {}
    },
    {
        "label": "logger",
        "importPath": "loguru",
        "description": "loguru",
        "isExtraImport": true,
        "detail": "loguru",
        "documentation": {}
    },
    {
        "label": "exceptions",
        "importPath": "custard.expect",
        "description": "custard.expect",
        "isExtraImport": true,
        "detail": "custard.expect",
        "documentation": {}
    },
    {
        "label": "ExcContextManager",
        "importPath": "custard.expect",
        "description": "custard.expect",
        "isExtraImport": true,
        "detail": "custard.expect",
        "documentation": {}
    },
    {
        "label": "types",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "types",
        "description": "types",
        "detail": "types",
        "documentation": {}
    },
    {
        "label": "operator",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "operator",
        "description": "operator",
        "detail": "operator",
        "documentation": {}
    },
    {
        "label": "text",
        "importPath": "custard.utils",
        "description": "custard.utils",
        "isExtraImport": true,
        "detail": "custard.utils",
        "documentation": {}
    },
    {
        "label": "unicodedata",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "unicodedata",
        "description": "unicodedata",
        "detail": "unicodedata",
        "documentation": {}
    },
    {
        "label": "aiohttp",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "aiohttp",
        "description": "aiohttp",
        "detail": "aiohttp",
        "documentation": {}
    },
    {
        "label": "alru_cache",
        "importPath": "custard.cache.async_lru",
        "description": "custard.cache.async_lru",
        "isExtraImport": true,
        "detail": "custard.cache.async_lru",
        "documentation": {}
    },
    {
        "label": "RSAProvider",
        "importPath": "custard.crypto",
        "description": "custard.crypto",
        "isExtraImport": true,
        "detail": "custard.crypto",
        "documentation": {}
    },
    {
        "label": "unittest",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "unittest",
        "description": "unittest",
        "detail": "unittest",
        "documentation": {}
    },
    {
        "label": "handle_exception",
        "importPath": "custard.expect.record",
        "description": "custard.expect.record",
        "isExtraImport": true,
        "detail": "custard.expect.record",
        "documentation": {}
    },
    {
        "label": "keep_circulating",
        "importPath": "custard.expect.spacer",
        "description": "custard.expect.spacer",
        "isExtraImport": true,
        "detail": "custard.expect.spacer",
        "documentation": {}
    },
    {
        "label": "bind_run_many_times",
        "importPath": "custard.function",
        "description": "custard.function",
        "isExtraImport": true,
        "detail": "custard.function",
        "documentation": {}
    },
    {
        "label": "where_is_it_called",
        "importPath": "custard.function",
        "description": "custard.function",
        "isExtraImport": true,
        "detail": "custard.function",
        "documentation": {}
    },
    {
        "label": "singleton_lock",
        "importPath": "custard.lock",
        "description": "custard.lock",
        "isExtraImport": true,
        "detail": "custard.lock",
        "documentation": {}
    },
    {
        "label": "TimerContextManager",
        "importPath": "custard.time",
        "description": "custard.time",
        "isExtraImport": true,
        "detail": "custard.time",
        "documentation": {}
    },
    {
        "label": "calc_time",
        "importPath": "custard.time",
        "description": "custard.time",
        "isExtraImport": true,
        "detail": "custard.time",
        "documentation": {}
    },
    {
        "label": "bind_timeout",
        "importPath": "custard.time",
        "description": "custard.time",
        "isExtraImport": true,
        "detail": "custard.time",
        "documentation": {}
    },
    {
        "label": "TimerContextManager",
        "importPath": "custard.time",
        "description": "custard.time",
        "isExtraImport": true,
        "detail": "custard.time",
        "documentation": {}
    },
    {
        "label": "calc_time",
        "importPath": "custard.time",
        "description": "custard.time",
        "isExtraImport": true,
        "detail": "custard.time",
        "documentation": {}
    },
    {
        "label": "MySqlInspect",
        "importPath": "custard.db",
        "description": "custard.db",
        "isExtraImport": true,
        "detail": "custard.db",
        "documentation": {}
    },
    {
        "label": "MysqlUtil",
        "importPath": "custard.db ",
        "description": "custard.db ",
        "isExtraImport": true,
        "detail": "custard.db ",
        "documentation": {}
    },
    {
        "label": "hitfilter",
        "importPath": "custard.hitfilter",
        "description": "custard.hitfilter",
        "isExtraImport": true,
        "detail": "custard.hitfilter",
        "documentation": {}
    },
    {
        "label": "unittest.mock",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "jsonlogger",
        "importPath": "custard.json",
        "description": "custard.json",
        "isExtraImport": true,
        "detail": "custard.json",
        "documentation": {}
    },
    {
        "label": "aioredis",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "aioredis",
        "description": "aioredis",
        "detail": "aioredis",
        "documentation": {}
    },
    {
        "label": "uvicorn",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "uvicorn",
        "description": "uvicorn",
        "detail": "uvicorn",
        "documentation": {}
    },
    {
        "label": "Limiter",
        "importPath": "custard.limiter",
        "description": "custard.limiter",
        "isExtraImport": true,
        "detail": "custard.limiter",
        "documentation": {}
    },
    {
        "label": "RateLimiter",
        "importPath": "custard.limiter.depends",
        "description": "custard.limiter.depends",
        "isExtraImport": true,
        "detail": "custard.limiter.depends",
        "documentation": {}
    },
    {
        "label": "pprint",
        "importPath": "pprint",
        "description": "pprint",
        "isExtraImport": true,
        "detail": "pprint",
        "documentation": {}
    },
    {
        "label": "Mock",
        "importPath": "custard.mock",
        "description": "custard.mock",
        "isExtraImport": true,
        "detail": "custard.mock",
        "documentation": {}
    },
    {
        "label": "AsyncSession",
        "importPath": "sqlalchemy.ext.asyncio",
        "description": "sqlalchemy.ext.asyncio",
        "isExtraImport": true,
        "detail": "sqlalchemy.ext.asyncio",
        "documentation": {}
    },
    {
        "label": "create_async_engine",
        "importPath": "sqlalchemy.ext.asyncio",
        "description": "sqlalchemy.ext.asyncio",
        "isExtraImport": true,
        "detail": "sqlalchemy.ext.asyncio",
        "documentation": {}
    },
    {
        "label": "declarative_base",
        "importPath": "sqlalchemy.ext.declarative",
        "description": "sqlalchemy.ext.declarative",
        "isExtraImport": true,
        "detail": "sqlalchemy.ext.declarative",
        "documentation": {}
    },
    {
        "label": "declarative_base",
        "importPath": "sqlalchemy.ext.declarative",
        "description": "sqlalchemy.ext.declarative",
        "isExtraImport": true,
        "detail": "sqlalchemy.ext.declarative",
        "documentation": {}
    },
    {
        "label": "select",
        "importPath": "sqlalchemy.future",
        "description": "sqlalchemy.future",
        "isExtraImport": true,
        "detail": "sqlalchemy.future",
        "documentation": {}
    },
    {
        "label": "LimitOffsetPage",
        "importPath": "custard.pagination",
        "description": "custard.pagination",
        "isExtraImport": true,
        "detail": "custard.pagination",
        "documentation": {}
    },
    {
        "label": "Page",
        "importPath": "custard.pagination",
        "description": "custard.pagination",
        "isExtraImport": true,
        "detail": "custard.pagination",
        "documentation": {}
    },
    {
        "label": "paginate",
        "importPath": "custard.pagination",
        "description": "custard.pagination",
        "isExtraImport": true,
        "detail": "custard.pagination",
        "documentation": {}
    },
    {
        "label": "add_pagination",
        "importPath": "custard.pagination",
        "description": "custard.pagination",
        "isExtraImport": true,
        "detail": "custard.pagination",
        "documentation": {}
    },
    {
        "label": "LimitOffsetPage",
        "importPath": "custard.pagination",
        "description": "custard.pagination",
        "isExtraImport": true,
        "detail": "custard.pagination",
        "documentation": {}
    },
    {
        "label": "Page",
        "importPath": "custard.pagination",
        "description": "custard.pagination",
        "isExtraImport": true,
        "detail": "custard.pagination",
        "documentation": {}
    },
    {
        "label": "add_pagination",
        "importPath": "custard.pagination",
        "description": "custard.pagination",
        "isExtraImport": true,
        "detail": "custard.pagination",
        "documentation": {}
    },
    {
        "label": "paginate",
        "importPath": "custard.pagination.sync_sqlalchemy",
        "description": "custard.pagination.sync_sqlalchemy",
        "isExtraImport": true,
        "detail": "custard.pagination.sync_sqlalchemy",
        "documentation": {}
    },
    {
        "label": "warnings",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "warnings",
        "description": "warnings",
        "detail": "warnings",
        "documentation": {}
    },
    {
        "label": "parse",
        "importPath": "urllib",
        "description": "urllib",
        "isExtraImport": true,
        "detail": "urllib",
        "documentation": {}
    },
    {
        "label": "utils",
        "importPath": "custard.swagger",
        "description": "custard.swagger",
        "isExtraImport": true,
        "detail": "custard.swagger",
        "documentation": {}
    },
    {
        "label": "swagger_parse",
        "importPath": "custard.swagger",
        "description": "custard.swagger",
        "isExtraImport": true,
        "detail": "custard.swagger",
        "documentation": {}
    },
    {
        "label": "MsHelper",
        "importPath": "custard.core.factory",
        "description": "custard.core.factory",
        "isExtraImport": true,
        "detail": "custard.core.factory",
        "documentation": {}
    },
    {
        "label": "JSONDecodeError",
        "importPath": "simplejson",
        "description": "simplejson",
        "isExtraImport": true,
        "detail": "simplejson",
        "documentation": {}
    },
    {
        "label": "firefox",
        "importPath": "custard.core.useragent",
        "description": "custard.core.useragent",
        "isExtraImport": true,
        "detail": "custard.core.useragent",
        "documentation": {}
    },
    {
        "label": "safari",
        "importPath": "custard.core.useragent",
        "description": "custard.core.useragent",
        "isExtraImport": true,
        "detail": "custard.core.useragent",
        "documentation": {}
    },
    {
        "label": "internet_explorer",
        "importPath": "custard.core.useragent",
        "description": "custard.core.useragent",
        "isExtraImport": true,
        "detail": "custard.core.useragent",
        "documentation": {}
    },
    {
        "label": "opera",
        "importPath": "custard.core.useragent",
        "description": "custard.core.useragent",
        "isExtraImport": true,
        "detail": "custard.core.useragent",
        "documentation": {}
    },
    {
        "label": "linux_platform_token",
        "importPath": "custard.core.useragent",
        "description": "custard.core.useragent",
        "isExtraImport": true,
        "detail": "custard.core.useragent",
        "documentation": {}
    },
    {
        "label": "mac_platform_token",
        "importPath": "custard.core.useragent",
        "description": "custard.core.useragent",
        "isExtraImport": true,
        "detail": "custard.core.useragent",
        "documentation": {}
    },
    {
        "label": "win_platform_token",
        "importPath": "custard.core.useragent",
        "description": "custard.core.useragent",
        "isExtraImport": true,
        "detail": "custard.core.useragent",
        "documentation": {}
    },
    {
        "label": "android_platform_token",
        "importPath": "custard.core.useragent",
        "description": "custard.core.useragent",
        "isExtraImport": true,
        "detail": "custard.core.useragent",
        "documentation": {}
    },
    {
        "label": "unpartial",
        "kind": 2,
        "importPath": "custard.cache.async_lru",
        "description": "custard.cache.async_lru",
        "peekOfCode": "def unpartial(fn):\n    while hasattr(fn, \"func\"):\n        fn = fn.func\n    return fn\ndef _done_callback(fut, task):\n    if task.cancelled():\n        fut.cancel()\n        return\n    exc = task.exception()\n    if exc is not None:",
        "detail": "custard.cache.async_lru",
        "documentation": {}
    },
    {
        "label": "alru_cache",
        "kind": 2,
        "importPath": "custard.cache.async_lru",
        "description": "custard.cache.async_lru",
        "peekOfCode": "def alru_cache(\n        fn=None,\n        maxsize=128,\n        typed=False,\n        *,\n        cache_exceptions=True,\n):\n    def wrapper(fn):\n        _origin = unpartial(fn)\n        if not asyncio.iscoroutinefunction(_origin):",
        "detail": "custard.cache.async_lru",
        "documentation": {}
    },
    {
        "label": "RedisClient",
        "kind": 6,
        "importPath": "custard.cache.redis",
        "description": "custard.cache.redis",
        "peekOfCode": "class RedisClient(object):\n    \"\"\"\n    py2.7, py3.7\n    \"\"\"\n    mutex = threading.Lock()  # gevent 里使用线程锁可能有问题\n    config = None\n    connection_pool = None\n    connection_client = None\n    def __init__(self, config):\n        \"\"\"",
        "detail": "custard.cache.redis",
        "documentation": {}
    },
    {
        "label": "unidecode",
        "kind": 2,
        "importPath": "custard.core.decode",
        "description": "custard.core.decode",
        "peekOfCode": "def unidecode(txt: str) -> str:\n    \"\"\"\n    Args:\n        txt:\n    Returns:\n    Examples:\n        >>> print(unidecode(\"ah 啊哈哈\"))\n    \"\"\"\n    chars = \"\"\n    for ch in txt:",
        "detail": "custard.core.decode",
        "documentation": {}
    },
    {
        "label": "codes",
        "kind": 5,
        "importPath": "custard.core.decode",
        "description": "custard.core.decode",
        "peekOfCode": "codes = (\n    \"\\x00\",\n    \"\\x01\",\n    \"\\x02\",\n    \"\\x03\",\n    \"\\x04\",\n    \"\\x05\",\n    \"\\x06\",\n    \"\\x07\",\n    \"\\x08\",",
        "detail": "custard.core.decode",
        "documentation": {}
    },
    {
        "label": "MockHelper",
        "kind": 6,
        "importPath": "custard.core.factory",
        "description": "custard.core.factory",
        "peekOfCode": "class MockHelper:\n    @staticmethod\n    def hans2pinyin(hans, style='A'):\n        \"\"\"\n        汉字转拼音\n        Args:\n            hans: 汉字\n            style: 返回首字母还是全拼， A：全拼； F：首字母\n        Returns:\n        Examples:",
        "detail": "custard.core.factory",
        "documentation": {}
    },
    {
        "label": "AutoVivification",
        "kind": 6,
        "importPath": "custard.core.factory",
        "description": "custard.core.factory",
        "peekOfCode": "class AutoVivification(dict):\n  def __getitem__(self, item):\n    try:\n      return dict.__getitem__(self, item)\n    except KeyError:\n      value = self[item] = type(self)()\n    return value\nclass MsHelper(object):\n    GLOBAL_PAGE_INDEX = [\"page_index\" \"pageindex\"]\n    GLOBAL_PAGE_SIZE = [\"page_size\" \"pagesize\"]",
        "detail": "custard.core.factory",
        "documentation": {}
    },
    {
        "label": "MsHelper",
        "kind": 6,
        "importPath": "custard.core.factory",
        "description": "custard.core.factory",
        "peekOfCode": "class MsHelper(object):\n    GLOBAL_PAGE_INDEX = [\"page_index\" \"pageindex\"]\n    GLOBAL_PAGE_SIZE = [\"page_size\" \"pagesize\"]\n    @classmethod\n    def __property__(cls, prop):\n        \"\"\"\n        数据转换\n        Args:\n            prop:\n        Returns:",
        "detail": "custard.core.factory",
        "documentation": {}
    },
    {
        "label": "fake",
        "kind": 5,
        "importPath": "custard.core.factory",
        "description": "custard.core.factory",
        "peekOfCode": "fake = Faker(['zh_CN'])\nclass MockHelper:\n    @staticmethod\n    def hans2pinyin(hans, style='A'):\n        \"\"\"\n        汉字转拼音\n        Args:\n            hans: 汉字\n            style: 返回首字母还是全拼， A：全拼； F：首字母\n        Returns:",
        "detail": "custard.core.factory",
        "documentation": {}
    },
    {
        "label": "Kerberos",
        "kind": 6,
        "importPath": "custard.core.kerberos",
        "description": "custard.core.kerberos",
        "peekOfCode": "class Kerberos:\n    @staticmethod\n    def jwt_encode(secret_key, target_value, seconds):\n        \"\"\"\n        jwt加密\n        Args:\n            secret_key:\n            target_value:\n            seconds:\n        Returns:",
        "detail": "custard.core.kerberos",
        "documentation": {}
    },
    {
        "label": "DataHand",
        "kind": 6,
        "importPath": "custard.core.processor",
        "description": "custard.core.processor",
        "peekOfCode": "class DataHand:\n    @staticmethod\n    def to_str(variable):\n        \"\"\"非字符串转换为字符串\"\"\"\n        if isinstance(variable, text_type) or isinstance(variable, binary_type):\n            return variable\n        return str(variable)\n    @staticmethod\n    def to_unicode(variable):\n        \"\"\"将字符串转为unicode\"\"\"",
        "detail": "custard.core.processor",
        "documentation": {}
    },
    {
        "label": "HtmlHand",
        "kind": 6,
        "importPath": "custard.core.processor",
        "description": "custard.core.processor",
        "peekOfCode": "class HtmlHand:\n    @staticmethod\n    def find(res, xpath, index) -> Text:\n        \"\"\"\n        获取html中的数据\n        :param res:\n        :param xpath:\n        :param index:\n        :return:\n        \"\"\"",
        "detail": "custard.core.processor",
        "documentation": {}
    },
    {
        "label": "JsonHand",
        "kind": 6,
        "importPath": "custard.core.processor",
        "description": "custard.core.processor",
        "peekOfCode": "class JsonHand:\n    @staticmethod\n    def normalize(filter):\n        \"\"\"\n        normalize the path expression; outside JsonHand to allow testings\n        :param filter: 需要查找的值\n        :return:\n        \"\"\"\n        subx = []\n        # replace index/filter expressions with placeholders",
        "detail": "custard.core.processor",
        "documentation": {}
    },
    {
        "label": "SINGLE_UPLOAD_LENGTH",
        "kind": 5,
        "importPath": "custard.core.processor",
        "description": "custard.core.processor",
        "peekOfCode": "SINGLE_UPLOAD_LENGTH = 5 * 1024 * 1024 * 1024  # 单次上传文件最大为5GB\nDEFAULT_CHUNK_SIZE = 1024 * 1024  # 计算MD5值时,文件单次读取的块大小为1MB\nclass DataHand:\n    @staticmethod\n    def to_str(variable):\n        \"\"\"非字符串转换为字符串\"\"\"\n        if isinstance(variable, text_type) or isinstance(variable, binary_type):\n            return variable\n        return str(variable)\n    @staticmethod",
        "detail": "custard.core.processor",
        "documentation": {}
    },
    {
        "label": "DEFAULT_CHUNK_SIZE",
        "kind": 5,
        "importPath": "custard.core.processor",
        "description": "custard.core.processor",
        "peekOfCode": "DEFAULT_CHUNK_SIZE = 1024 * 1024  # 计算MD5值时,文件单次读取的块大小为1MB\nclass DataHand:\n    @staticmethod\n    def to_str(variable):\n        \"\"\"非字符串转换为字符串\"\"\"\n        if isinstance(variable, text_type) or isinstance(variable, binary_type):\n            return variable\n        return str(variable)\n    @staticmethod\n    def to_unicode(variable):",
        "detail": "custard.core.processor",
        "documentation": {}
    },
    {
        "label": "RegEx",
        "kind": 6,
        "importPath": "custard.core.regular",
        "description": "custard.core.regular",
        "peekOfCode": "class RegEx:\n    @staticmethod\n    def match_email(context: Any) -> bool:\n        \"\"\"\n        效验邮箱格式\n        Args:\n            context:\n        Returns:\n        Examples:\n            >>> examples = [\"test@163.com\",\"test163.com\",\"155555@qq.com\"]",
        "detail": "custard.core.regular",
        "documentation": {}
    },
    {
        "label": "snowflake_to_timestamp",
        "kind": 2,
        "importPath": "custard.core.snowflake",
        "description": "custard.core.snowflake",
        "peekOfCode": "def snowflake_to_timestamp(_id):\n    _id = _id >> 22  # strip the lower 22 bits\n    _id += twepoch  # adjust for twitter epoch\n    _id = _id / 1000  # convert from milliseconds to seconds\n    return _id\ndef generator(worker_id, data_center_id, sleep=lambda x: time.sleep(x / 1000.0)):\n    assert 0 <= worker_id <= max_worker_id\n    assert 0 <= data_center_id <= max_data_center_id\n    last_timestamp = -1\n    sequence = 0",
        "detail": "custard.core.snowflake",
        "documentation": {}
    },
    {
        "label": "generator",
        "kind": 2,
        "importPath": "custard.core.snowflake",
        "description": "custard.core.snowflake",
        "peekOfCode": "def generator(worker_id, data_center_id, sleep=lambda x: time.sleep(x / 1000.0)):\n    assert 0 <= worker_id <= max_worker_id\n    assert 0 <= data_center_id <= max_data_center_id\n    last_timestamp = -1\n    sequence = 0\n    while True:\n        timestamp = int(time.time() * 1000)\n        if last_timestamp > timestamp:\n            print(\"clock is moving backwards. waiting until %i\" % last_timestamp)\n            sleep(last_timestamp - timestamp)",
        "detail": "custard.core.snowflake",
        "documentation": {}
    },
    {
        "label": "twepoch",
        "kind": 5,
        "importPath": "custard.core.snowflake",
        "description": "custard.core.snowflake",
        "peekOfCode": "twepoch = 1292978355588\nworker_id_bits = 5\ndata_center_id_bits = 5\nmax_worker_id = -1 ^ (-1 << worker_id_bits)\nmax_data_center_id = -1 ^ (-1 << data_center_id_bits)\nsequence_bits = 12\nworker_id_shift = sequence_bits\ndata_center_id_shift = sequence_bits + worker_id_bits\ntimestamp_left_shift = sequence_bits + worker_id_bits + data_center_id_bits\nsequence_mask = -1 ^ (-1 << sequence_bits)",
        "detail": "custard.core.snowflake",
        "documentation": {}
    },
    {
        "label": "worker_id_bits",
        "kind": 5,
        "importPath": "custard.core.snowflake",
        "description": "custard.core.snowflake",
        "peekOfCode": "worker_id_bits = 5\ndata_center_id_bits = 5\nmax_worker_id = -1 ^ (-1 << worker_id_bits)\nmax_data_center_id = -1 ^ (-1 << data_center_id_bits)\nsequence_bits = 12\nworker_id_shift = sequence_bits\ndata_center_id_shift = sequence_bits + worker_id_bits\ntimestamp_left_shift = sequence_bits + worker_id_bits + data_center_id_bits\nsequence_mask = -1 ^ (-1 << sequence_bits)\ndef snowflake_to_timestamp(_id):",
        "detail": "custard.core.snowflake",
        "documentation": {}
    },
    {
        "label": "data_center_id_bits",
        "kind": 5,
        "importPath": "custard.core.snowflake",
        "description": "custard.core.snowflake",
        "peekOfCode": "data_center_id_bits = 5\nmax_worker_id = -1 ^ (-1 << worker_id_bits)\nmax_data_center_id = -1 ^ (-1 << data_center_id_bits)\nsequence_bits = 12\nworker_id_shift = sequence_bits\ndata_center_id_shift = sequence_bits + worker_id_bits\ntimestamp_left_shift = sequence_bits + worker_id_bits + data_center_id_bits\nsequence_mask = -1 ^ (-1 << sequence_bits)\ndef snowflake_to_timestamp(_id):\n    _id = _id >> 22  # strip the lower 22 bits",
        "detail": "custard.core.snowflake",
        "documentation": {}
    },
    {
        "label": "max_worker_id",
        "kind": 5,
        "importPath": "custard.core.snowflake",
        "description": "custard.core.snowflake",
        "peekOfCode": "max_worker_id = -1 ^ (-1 << worker_id_bits)\nmax_data_center_id = -1 ^ (-1 << data_center_id_bits)\nsequence_bits = 12\nworker_id_shift = sequence_bits\ndata_center_id_shift = sequence_bits + worker_id_bits\ntimestamp_left_shift = sequence_bits + worker_id_bits + data_center_id_bits\nsequence_mask = -1 ^ (-1 << sequence_bits)\ndef snowflake_to_timestamp(_id):\n    _id = _id >> 22  # strip the lower 22 bits\n    _id += twepoch  # adjust for twitter epoch",
        "detail": "custard.core.snowflake",
        "documentation": {}
    },
    {
        "label": "max_data_center_id",
        "kind": 5,
        "importPath": "custard.core.snowflake",
        "description": "custard.core.snowflake",
        "peekOfCode": "max_data_center_id = -1 ^ (-1 << data_center_id_bits)\nsequence_bits = 12\nworker_id_shift = sequence_bits\ndata_center_id_shift = sequence_bits + worker_id_bits\ntimestamp_left_shift = sequence_bits + worker_id_bits + data_center_id_bits\nsequence_mask = -1 ^ (-1 << sequence_bits)\ndef snowflake_to_timestamp(_id):\n    _id = _id >> 22  # strip the lower 22 bits\n    _id += twepoch  # adjust for twitter epoch\n    _id = _id / 1000  # convert from milliseconds to seconds",
        "detail": "custard.core.snowflake",
        "documentation": {}
    },
    {
        "label": "sequence_bits",
        "kind": 5,
        "importPath": "custard.core.snowflake",
        "description": "custard.core.snowflake",
        "peekOfCode": "sequence_bits = 12\nworker_id_shift = sequence_bits\ndata_center_id_shift = sequence_bits + worker_id_bits\ntimestamp_left_shift = sequence_bits + worker_id_bits + data_center_id_bits\nsequence_mask = -1 ^ (-1 << sequence_bits)\ndef snowflake_to_timestamp(_id):\n    _id = _id >> 22  # strip the lower 22 bits\n    _id += twepoch  # adjust for twitter epoch\n    _id = _id / 1000  # convert from milliseconds to seconds\n    return _id",
        "detail": "custard.core.snowflake",
        "documentation": {}
    },
    {
        "label": "worker_id_shift",
        "kind": 5,
        "importPath": "custard.core.snowflake",
        "description": "custard.core.snowflake",
        "peekOfCode": "worker_id_shift = sequence_bits\ndata_center_id_shift = sequence_bits + worker_id_bits\ntimestamp_left_shift = sequence_bits + worker_id_bits + data_center_id_bits\nsequence_mask = -1 ^ (-1 << sequence_bits)\ndef snowflake_to_timestamp(_id):\n    _id = _id >> 22  # strip the lower 22 bits\n    _id += twepoch  # adjust for twitter epoch\n    _id = _id / 1000  # convert from milliseconds to seconds\n    return _id\ndef generator(worker_id, data_center_id, sleep=lambda x: time.sleep(x / 1000.0)):",
        "detail": "custard.core.snowflake",
        "documentation": {}
    },
    {
        "label": "data_center_id_shift",
        "kind": 5,
        "importPath": "custard.core.snowflake",
        "description": "custard.core.snowflake",
        "peekOfCode": "data_center_id_shift = sequence_bits + worker_id_bits\ntimestamp_left_shift = sequence_bits + worker_id_bits + data_center_id_bits\nsequence_mask = -1 ^ (-1 << sequence_bits)\ndef snowflake_to_timestamp(_id):\n    _id = _id >> 22  # strip the lower 22 bits\n    _id += twepoch  # adjust for twitter epoch\n    _id = _id / 1000  # convert from milliseconds to seconds\n    return _id\ndef generator(worker_id, data_center_id, sleep=lambda x: time.sleep(x / 1000.0)):\n    assert 0 <= worker_id <= max_worker_id",
        "detail": "custard.core.snowflake",
        "documentation": {}
    },
    {
        "label": "timestamp_left_shift",
        "kind": 5,
        "importPath": "custard.core.snowflake",
        "description": "custard.core.snowflake",
        "peekOfCode": "timestamp_left_shift = sequence_bits + worker_id_bits + data_center_id_bits\nsequence_mask = -1 ^ (-1 << sequence_bits)\ndef snowflake_to_timestamp(_id):\n    _id = _id >> 22  # strip the lower 22 bits\n    _id += twepoch  # adjust for twitter epoch\n    _id = _id / 1000  # convert from milliseconds to seconds\n    return _id\ndef generator(worker_id, data_center_id, sleep=lambda x: time.sleep(x / 1000.0)):\n    assert 0 <= worker_id <= max_worker_id\n    assert 0 <= data_center_id <= max_data_center_id",
        "detail": "custard.core.snowflake",
        "documentation": {}
    },
    {
        "label": "sequence_mask",
        "kind": 5,
        "importPath": "custard.core.snowflake",
        "description": "custard.core.snowflake",
        "peekOfCode": "sequence_mask = -1 ^ (-1 << sequence_bits)\ndef snowflake_to_timestamp(_id):\n    _id = _id >> 22  # strip the lower 22 bits\n    _id += twepoch  # adjust for twitter epoch\n    _id = _id / 1000  # convert from milliseconds to seconds\n    return _id\ndef generator(worker_id, data_center_id, sleep=lambda x: time.sleep(x / 1000.0)):\n    assert 0 <= worker_id <= max_worker_id\n    assert 0 <= data_center_id <= max_data_center_id\n    last_timestamp = -1",
        "detail": "custard.core.snowflake",
        "documentation": {}
    },
    {
        "label": "System",
        "kind": 6,
        "importPath": "custard.core.system",
        "description": "custard.core.system",
        "peekOfCode": "class System:\n    @staticmethod\n    def get_depend_libs(file_path):\n        \"\"\"\n        获取第三方依赖架包\n        Args:\n            file_path:\n        Returns:\n        Examples:\n        \"\"\"",
        "detail": "custard.core.system",
        "documentation": {}
    },
    {
        "label": "random_sample",
        "kind": 2,
        "importPath": "custard.core.useragent",
        "description": "custard.core.useragent",
        "peekOfCode": "def random_sample(random=None) -> float:\n    if random is None:\n        random = mod_random\n    return random.uniform(0.0, 1.0)\ndef cumsum(it: Iterable[float]):\n    total: float = 0\n    for x in it:\n        total += x\n        yield total\ndef choices_distribution_unique(a, p, random=None, length: int = 1):",
        "detail": "custard.core.useragent",
        "documentation": {}
    },
    {
        "label": "cumsum",
        "kind": 2,
        "importPath": "custard.core.useragent",
        "description": "custard.core.useragent",
        "peekOfCode": "def cumsum(it: Iterable[float]):\n    total: float = 0\n    for x in it:\n        total += x\n        yield total\ndef choices_distribution_unique(a, p, random=None, length: int = 1):\n    # As of Python 3.7, there isn't a way to sample unique elements that takes\n    # weight into account.\n    if random is None:\n        random = mod_random",
        "detail": "custard.core.useragent",
        "documentation": {}
    },
    {
        "label": "choices_distribution_unique",
        "kind": 2,
        "importPath": "custard.core.useragent",
        "description": "custard.core.useragent",
        "peekOfCode": "def choices_distribution_unique(a, p, random=None, length: int = 1):\n    # As of Python 3.7, there isn't a way to sample unique elements that takes\n    # weight into account.\n    if random is None:\n        random = mod_random\n    assert p is not None\n    assert len(a) == len(p)\n    assert len(a) >= length, \"You can't request more unique samples than elements in the dataset.\"\n    choices = []\n    items = list(a)",
        "detail": "custard.core.useragent",
        "documentation": {}
    },
    {
        "label": "choices_distribution",
        "kind": 2,
        "importPath": "custard.core.useragent",
        "description": "custard.core.useragent",
        "peekOfCode": "def choices_distribution(a, p, random=None, length: int = 1):\n    if random is None:\n        random = mod_random\n    if p is not None:\n        assert len(a) == len(p)\n    if hasattr(random, \"choices\"):\n        if length == 1 and p is None:\n            return [random.choice(a)]\n        else:\n            return random.choices(a, weights=p, k=length)",
        "detail": "custard.core.useragent",
        "documentation": {}
    },
    {
        "label": "random_elements",
        "kind": 2,
        "importPath": "custard.core.useragent",
        "description": "custard.core.useragent",
        "peekOfCode": "def random_elements(\n        elements: ElementsType = (\"a\", \"b\", \"c\"),\n        length=None,\n        unique: bool = False,\n        use_weighting=None,\n):\n    use_weighting = use_weighting if use_weighting is not None else __use_weighting__\n    if isinstance(elements, dict) and not isinstance(elements, OrderedDict):\n        raise ValueError(\"Use OrderedDict only to avoid dependency on PYTHONHASHSEED (See #363).\")\n    fn = choices_distribution_unique if unique else choices_distribution",
        "detail": "custard.core.useragent",
        "documentation": {}
    },
    {
        "label": "mac_processor",
        "kind": 2,
        "importPath": "custard.core.useragent",
        "description": "custard.core.useragent",
        "peekOfCode": "def mac_processor() -> str:\n    \"\"\"Generate a MacOS processor token used in user agent strings.\"\"\"\n    return random_element(mac_processors)\ndef linux_processor() -> str:\n    \"\"\"Generate a Linux processor token used in user agent strings.\"\"\"\n    return random_element(linux_processors)\nuser_agents: ElementsType = (\n    \"chrome\",\n    \"firefox\",\n    \"internet_explorer\",",
        "detail": "custard.core.useragent",
        "documentation": {}
    },
    {
        "label": "linux_processor",
        "kind": 2,
        "importPath": "custard.core.useragent",
        "description": "custard.core.useragent",
        "peekOfCode": "def linux_processor() -> str:\n    \"\"\"Generate a Linux processor token used in user agent strings.\"\"\"\n    return random_element(linux_processors)\nuser_agents: ElementsType = (\n    \"chrome\",\n    \"firefox\",\n    \"internet_explorer\",\n    \"opera\",\n    \"safari\",\n)",
        "detail": "custard.core.useragent",
        "documentation": {}
    },
    {
        "label": "user_agent",
        "kind": 2,
        "importPath": "custard.core.useragent",
        "description": "custard.core.useragent",
        "peekOfCode": "def user_agent() -> str:\n    name: str = random_element(user_agents)\n    print(name)\ndef chrome(\n        version_from: int = 13,\n        version_to: int = 63,\n        build_from: int = 800,\n        build_to: int = 899,\n) -> str:\n    \"\"\"Generate a Chrome web browser user agent string.\"\"\"",
        "detail": "custard.core.useragent",
        "documentation": {}
    },
    {
        "label": "chrome",
        "kind": 2,
        "importPath": "custard.core.useragent",
        "description": "custard.core.useragent",
        "peekOfCode": "def chrome(\n        version_from: int = 13,\n        version_to: int = 63,\n        build_from: int = 800,\n        build_to: int = 899,\n) -> str:\n    \"\"\"Generate a Chrome web browser user agent string.\"\"\"\n    saf: str = f\"{random.randint(531, 536)}.{random.randint(0, 2)}\"\n    bld: str = lexify(numerify(\"##?###\"), string.ascii_uppercase)\n    tmplt: str = \"({0}) AppleWebKit/{1} (KHTML, like Gecko)\" \" Chrome/{2}.0.{3}.0 Safari/{4}\"",
        "detail": "custard.core.useragent",
        "documentation": {}
    },
    {
        "label": "languageCode",
        "kind": 2,
        "importPath": "custard.core.useragent",
        "description": "custard.core.useragent",
        "peekOfCode": "def languageCode():\n    return random_element(language_locale_codes.keys())\ndef localeLang():\n    language_code = languageCode()\n    return (\n            language_code\n            + \"_\"\n            + random_element(\n        language_locale_codes[language_code],\n    )",
        "detail": "custard.core.useragent",
        "documentation": {}
    },
    {
        "label": "localeLang",
        "kind": 2,
        "importPath": "custard.core.useragent",
        "description": "custard.core.useragent",
        "peekOfCode": "def localeLang():\n    language_code = languageCode()\n    return (\n            language_code\n            + \"_\"\n            + random_element(\n        language_locale_codes[language_code],\n    )\n    )\ndef random_int(min: int = 0, max: int = 9999, step: int = 1) -> int:",
        "detail": "custard.core.useragent",
        "documentation": {}
    },
    {
        "label": "random_int",
        "kind": 2,
        "importPath": "custard.core.useragent",
        "description": "custard.core.useragent",
        "peekOfCode": "def random_int(min: int = 0, max: int = 9999, step: int = 1) -> int:\n    return random.randrange(min, max + 1, step)\ndef random_digit() -> int:\n    \"\"\"Generate a random digit (0 to 9).\"\"\"\n    return random.randint(0, 9)\ndef random_digit_not_null() -> int:\n    return random.randint(1, 9)\ndef random_digit_or_empty() -> Union[int, str]:\n    if random.randint(0, 1):\n        return random.randint(0, 9)",
        "detail": "custard.core.useragent",
        "documentation": {}
    },
    {
        "label": "random_digit",
        "kind": 2,
        "importPath": "custard.core.useragent",
        "description": "custard.core.useragent",
        "peekOfCode": "def random_digit() -> int:\n    \"\"\"Generate a random digit (0 to 9).\"\"\"\n    return random.randint(0, 9)\ndef random_digit_not_null() -> int:\n    return random.randint(1, 9)\ndef random_digit_or_empty() -> Union[int, str]:\n    if random.randint(0, 1):\n        return random.randint(0, 9)\n    else:\n        return \"\"",
        "detail": "custard.core.useragent",
        "documentation": {}
    },
    {
        "label": "random_digit_not_null",
        "kind": 2,
        "importPath": "custard.core.useragent",
        "description": "custard.core.useragent",
        "peekOfCode": "def random_digit_not_null() -> int:\n    return random.randint(1, 9)\ndef random_digit_or_empty() -> Union[int, str]:\n    if random.randint(0, 1):\n        return random.randint(0, 9)\n    else:\n        return \"\"\ndef random_digit_not_null_or_empty() -> Union[int, str]:\n    if random.randint(0, 1):\n        return random.randint(1, 9)",
        "detail": "custard.core.useragent",
        "documentation": {}
    },
    {
        "label": "random_digit_or_empty",
        "kind": 2,
        "importPath": "custard.core.useragent",
        "description": "custard.core.useragent",
        "peekOfCode": "def random_digit_or_empty() -> Union[int, str]:\n    if random.randint(0, 1):\n        return random.randint(0, 9)\n    else:\n        return \"\"\ndef random_digit_not_null_or_empty() -> Union[int, str]:\n    if random.randint(0, 1):\n        return random.randint(1, 9)\n    else:\n        return \"\"",
        "detail": "custard.core.useragent",
        "documentation": {}
    },
    {
        "label": "random_digit_not_null_or_empty",
        "kind": 2,
        "importPath": "custard.core.useragent",
        "description": "custard.core.useragent",
        "peekOfCode": "def random_digit_not_null_or_empty() -> Union[int, str]:\n    if random.randint(0, 1):\n        return random.randint(1, 9)\n    else:\n        return \"\"\ndef random_number(digits=None, fix_len: bool = False) -> int:\n    if digits is None:\n        digits = random_digit_not_null()\n    if digits < 0:\n        raise ValueError(\"The digit parameter must be greater than or equal to 0.\")",
        "detail": "custard.core.useragent",
        "documentation": {}
    },
    {
        "label": "random_number",
        "kind": 2,
        "importPath": "custard.core.useragent",
        "description": "custard.core.useragent",
        "peekOfCode": "def random_number(digits=None, fix_len: bool = False) -> int:\n    if digits is None:\n        digits = random_digit_not_null()\n    if digits < 0:\n        raise ValueError(\"The digit parameter must be greater than or equal to 0.\")\n    if fix_len:\n        if digits > 0:\n            return random.randint(pow(10, digits - 1), pow(10, digits) - 1)\n        else:\n            raise ValueError(\"A number of fixed length cannot have less than 1 digit in it.\")",
        "detail": "custard.core.useragent",
        "documentation": {}
    },
    {
        "label": "random_letter",
        "kind": 2,
        "importPath": "custard.core.useragent",
        "description": "custard.core.useragent",
        "peekOfCode": "def random_letter() -> str:\n    return random.choice(getattr(string, \"letters\", string.ascii_letters))\ndef random_choices(self, elements: ElementsType = (\"a\", \"b\", \"c\"), length: int = None) -> Sequence[T]:\n    return self.random_elements(elements, length, unique=False)\ndef random_letters(length: int = 16) -> Sequence[str]:\n    return random_choices(\n        getattr(string, \"letters\", string.ascii_letters),\n        length=length,\n    )\ndef rand_lowercase_letter() -> str:",
        "detail": "custard.core.useragent",
        "documentation": {}
    },
    {
        "label": "random_choices",
        "kind": 2,
        "importPath": "custard.core.useragent",
        "description": "custard.core.useragent",
        "peekOfCode": "def random_choices(self, elements: ElementsType = (\"a\", \"b\", \"c\"), length: int = None) -> Sequence[T]:\n    return self.random_elements(elements, length, unique=False)\ndef random_letters(length: int = 16) -> Sequence[str]:\n    return random_choices(\n        getattr(string, \"letters\", string.ascii_letters),\n        length=length,\n    )\ndef rand_lowercase_letter() -> str:\n    return random.choice(string.ascii_lowercase)\ndef rand_uppercase_letter() -> str:",
        "detail": "custard.core.useragent",
        "documentation": {}
    },
    {
        "label": "random_letters",
        "kind": 2,
        "importPath": "custard.core.useragent",
        "description": "custard.core.useragent",
        "peekOfCode": "def random_letters(length: int = 16) -> Sequence[str]:\n    return random_choices(\n        getattr(string, \"letters\", string.ascii_letters),\n        length=length,\n    )\ndef rand_lowercase_letter() -> str:\n    return random.choice(string.ascii_lowercase)\ndef rand_uppercase_letter() -> str:\n    return random.choice(string.ascii_uppercase)\ndef numerify(text: str = \"###\") -> str:",
        "detail": "custard.core.useragent",
        "documentation": {}
    },
    {
        "label": "rand_lowercase_letter",
        "kind": 2,
        "importPath": "custard.core.useragent",
        "description": "custard.core.useragent",
        "peekOfCode": "def rand_lowercase_letter() -> str:\n    return random.choice(string.ascii_lowercase)\ndef rand_uppercase_letter() -> str:\n    return random.choice(string.ascii_uppercase)\ndef numerify(text: str = \"###\") -> str:\n    text = _re_hash.sub(lambda x: str(random_digit()), text)\n    text = _re_perc.sub(lambda x: str(random_digit_not_null()), text)\n    text = _re_excl.sub(lambda x: str(random_digit_or_empty()), text)\n    text = _re_at.sub(lambda x: str(random_digit_not_null_or_empty()), text)\n    return text",
        "detail": "custard.core.useragent",
        "documentation": {}
    },
    {
        "label": "rand_uppercase_letter",
        "kind": 2,
        "importPath": "custard.core.useragent",
        "description": "custard.core.useragent",
        "peekOfCode": "def rand_uppercase_letter() -> str:\n    return random.choice(string.ascii_uppercase)\ndef numerify(text: str = \"###\") -> str:\n    text = _re_hash.sub(lambda x: str(random_digit()), text)\n    text = _re_perc.sub(lambda x: str(random_digit_not_null()), text)\n    text = _re_excl.sub(lambda x: str(random_digit_or_empty()), text)\n    text = _re_at.sub(lambda x: str(random_digit_not_null_or_empty()), text)\n    return text\ndef lexify(text: str = \"????\", letters: str = string.ascii_letters) -> str:\n    return _re_qm.sub(lambda x: random_element(letters), text)",
        "detail": "custard.core.useragent",
        "documentation": {}
    },
    {
        "label": "numerify",
        "kind": 2,
        "importPath": "custard.core.useragent",
        "description": "custard.core.useragent",
        "peekOfCode": "def numerify(text: str = \"###\") -> str:\n    text = _re_hash.sub(lambda x: str(random_digit()), text)\n    text = _re_perc.sub(lambda x: str(random_digit_not_null()), text)\n    text = _re_excl.sub(lambda x: str(random_digit_or_empty()), text)\n    text = _re_at.sub(lambda x: str(random_digit_not_null_or_empty()), text)\n    return text\ndef lexify(text: str = \"????\", letters: str = string.ascii_letters) -> str:\n    return _re_qm.sub(lambda x: random_element(letters), text)\ndef datetime_to_timestamp(dt: Union[dtdate, datetime]) -> int:\n    if isinstance(dt, datetime) and getattr(dt, \"tzinfo\", None) is not None:",
        "detail": "custard.core.useragent",
        "documentation": {}
    },
    {
        "label": "lexify",
        "kind": 2,
        "importPath": "custard.core.useragent",
        "description": "custard.core.useragent",
        "peekOfCode": "def lexify(text: str = \"????\", letters: str = string.ascii_letters) -> str:\n    return _re_qm.sub(lambda x: random_element(letters), text)\ndef datetime_to_timestamp(dt: Union[dtdate, datetime]) -> int:\n    if isinstance(dt, datetime) and getattr(dt, \"tzinfo\", None) is not None:\n        dt = dt.astimezone(tzutc())\n    return timegm(dt.timetuple())\ndef parse_date_string(cls, value: str) -> Dict[str, float]:\n    parts = cls.regex.match(value)\n    if not parts:\n        raise Exception(f\"Can't parse date string `{value}`\")",
        "detail": "custard.core.useragent",
        "documentation": {}
    },
    {
        "label": "datetime_to_timestamp",
        "kind": 2,
        "importPath": "custard.core.useragent",
        "description": "custard.core.useragent",
        "peekOfCode": "def datetime_to_timestamp(dt: Union[dtdate, datetime]) -> int:\n    if isinstance(dt, datetime) and getattr(dt, \"tzinfo\", None) is not None:\n        dt = dt.astimezone(tzutc())\n    return timegm(dt.timetuple())\ndef parse_date_string(cls, value: str) -> Dict[str, float]:\n    parts = cls.regex.match(value)\n    if not parts:\n        raise Exception(f\"Can't parse date string `{value}`\")\n    parts = parts.groupdict()\n    time_params: Dict[str, float] = {}",
        "detail": "custard.core.useragent",
        "documentation": {}
    },
    {
        "label": "parse_date_string",
        "kind": 2,
        "importPath": "custard.core.useragent",
        "description": "custard.core.useragent",
        "peekOfCode": "def parse_date_string(cls, value: str) -> Dict[str, float]:\n    parts = cls.regex.match(value)\n    if not parts:\n        raise Exception(f\"Can't parse date string `{value}`\")\n    parts = parts.groupdict()\n    time_params: Dict[str, float] = {}\n    for (name_, param_) in parts.items():\n        if param_:\n            time_params[name_] = int(param_)\n    if \"years\" in time_params:",
        "detail": "custard.core.useragent",
        "documentation": {}
    },
    {
        "label": "date_time_between",
        "kind": 2,
        "importPath": "custard.core.useragent",
        "description": "custard.core.useragent",
        "peekOfCode": "def date_time_between(\n        start_date: DateParseType = \"-30y\",\n        end_date: DateParseType = \"now\",\n        tzinfo=None,\n) -> datetime:\n    start_date = _parse_date_time(start_date, tzinfo=tzinfo)\n    end_date = _parse_date_time(end_date, tzinfo=tzinfo)\n    if end_date - start_date <= 1:\n        ts = start_date + random.random()\n    else:",
        "detail": "custard.core.useragent",
        "documentation": {}
    },
    {
        "label": "firefox",
        "kind": 2,
        "importPath": "custard.core.useragent",
        "description": "custard.core.useragent",
        "peekOfCode": "def firefox() -> str:\n    \"\"\"Generate a Mozilla Firefox web browser user agent string.\"\"\"\n    ver: ElementsType = (\n        (\n            f\"Gecko/{date_time_between(datetime(2011, 1, 1))} \"\n            f\"Firefox/{random.randint(4, 15)}.0\"\n        ),\n        (\n            f\"Gecko/{date_time_between(datetime(2010, 1, 1))} \"\n            f\"Firefox/3.6.{random.randint(1, 20)}\"",
        "detail": "custard.core.useragent",
        "documentation": {}
    },
    {
        "label": "localeLang",
        "kind": 2,
        "importPath": "custard.core.useragent",
        "description": "custard.core.useragent",
        "peekOfCode": "def localeLang() -> str:\n    language_code = languageCode()\n    return (\n            language_code\n            + \"_\"\n            + random_element(\n        language_locale_codes[language_code],\n    )\n    )\ndef safari() -> str:",
        "detail": "custard.core.useragent",
        "documentation": {}
    },
    {
        "label": "safari",
        "kind": 2,
        "importPath": "custard.core.useragent",
        "description": "custard.core.useragent",
        "peekOfCode": "def safari() -> str:\n    saf: str = (\n        f\"{random.randint(531, 535)}.\"\n        f\"{random.randint(1, 50)}.\"\n        f\"{random.randint(1, 7)}\"\n    )\n    ver: str = (\n        f\"{random.randint(4, 5)}.{random.randint(0, 1)}\"\n        if not random.getrandbits(1)\n        else f\"{random.randint(4, 5)}.0.{random.randint(1, 5)}\"",
        "detail": "custard.core.useragent",
        "documentation": {}
    },
    {
        "label": "opera",
        "kind": 2,
        "importPath": "custard.core.useragent",
        "description": "custard.core.useragent",
        "peekOfCode": "def opera() -> str:\n    token: str = (\n        linux_platform_token() if random.getrandbits(1) else win_platform_token()\n    )\n    locale: str = localeLang().replace(\"_\", \"-\")\n    platform: str = (\n        f\"({token}; {locale}) Presto/2.9.{random.randint(160, 190)} \"\n        f\"Version/{random.randint(10, 12)}.00\"\n    )\n    return f\"Opera/{random.randint(8, 9)}.{random.randint(10, 99)}.{platform}\"",
        "detail": "custard.core.useragent",
        "documentation": {}
    },
    {
        "label": "internet_explorer",
        "kind": 2,
        "importPath": "custard.core.useragent",
        "description": "custard.core.useragent",
        "peekOfCode": "def internet_explorer() -> str:\n    return (\n        f\"Mozilla/5.0 (compatible; MSIE {random.randint(5, 9)}.0; \"\n        f\"{win_platform_token()}; \"\n        f\"Trident/{random.randint(3, 5)}.{random.randint(0, 1)})\"\n    )\ndef random_element(elements: ElementsType = (\"a\", \"b\", \"c\")) -> T:\n    return random_elements(elements, length=1)[0]\ndef win_platform_token() -> str:\n    return random_element(win_platform_tokens)",
        "detail": "custard.core.useragent",
        "documentation": {}
    },
    {
        "label": "random_element",
        "kind": 2,
        "importPath": "custard.core.useragent",
        "description": "custard.core.useragent",
        "peekOfCode": "def random_element(elements: ElementsType = (\"a\", \"b\", \"c\")) -> T:\n    return random_elements(elements, length=1)[0]\ndef win_platform_token() -> str:\n    return random_element(win_platform_tokens)\ndef linux_platform_token() -> str:\n    return f\"X11; Linux {random_element(linux_processors)}\"\ndef mac_platform_token() -> str:\n    return (\n        f\"Macintosh; {random_element(mac_processors)} Mac OS X 10_\"\n        f\"{random.randint(5, 12)}_{random.randint(0, 9)}\"",
        "detail": "custard.core.useragent",
        "documentation": {}
    },
    {
        "label": "win_platform_token",
        "kind": 2,
        "importPath": "custard.core.useragent",
        "description": "custard.core.useragent",
        "peekOfCode": "def win_platform_token() -> str:\n    return random_element(win_platform_tokens)\ndef linux_platform_token() -> str:\n    return f\"X11; Linux {random_element(linux_processors)}\"\ndef mac_platform_token() -> str:\n    return (\n        f\"Macintosh; {random_element(mac_processors)} Mac OS X 10_\"\n        f\"{random.randint(5, 12)}_{random.randint(0, 9)}\"\n    )\ndef android_platform_token() -> str:",
        "detail": "custard.core.useragent",
        "documentation": {}
    },
    {
        "label": "linux_platform_token",
        "kind": 2,
        "importPath": "custard.core.useragent",
        "description": "custard.core.useragent",
        "peekOfCode": "def linux_platform_token() -> str:\n    return f\"X11; Linux {random_element(linux_processors)}\"\ndef mac_platform_token() -> str:\n    return (\n        f\"Macintosh; {random_element(mac_processors)} Mac OS X 10_\"\n        f\"{random.randint(5, 12)}_{random.randint(0, 9)}\"\n    )\ndef android_platform_token() -> str:\n    return f\"Android {random_element(android_versions)}\"\ndef ios_platform_token() -> str:",
        "detail": "custard.core.useragent",
        "documentation": {}
    },
    {
        "label": "mac_platform_token",
        "kind": 2,
        "importPath": "custard.core.useragent",
        "description": "custard.core.useragent",
        "peekOfCode": "def mac_platform_token() -> str:\n    return (\n        f\"Macintosh; {random_element(mac_processors)} Mac OS X 10_\"\n        f\"{random.randint(5, 12)}_{random.randint(0, 9)}\"\n    )\ndef android_platform_token() -> str:\n    return f\"Android {random_element(android_versions)}\"\ndef ios_platform_token() -> str:\n    apple_device: str = random_element(apple_devices)\n    ios_version: str = random_element(ios_versions)",
        "detail": "custard.core.useragent",
        "documentation": {}
    },
    {
        "label": "android_platform_token",
        "kind": 2,
        "importPath": "custard.core.useragent",
        "description": "custard.core.useragent",
        "peekOfCode": "def android_platform_token() -> str:\n    return f\"Android {random_element(android_versions)}\"\ndef ios_platform_token() -> str:\n    apple_device: str = random_element(apple_devices)\n    ios_version: str = random_element(ios_versions)\n    return f\"{apple_device}; CPU {apple_device} \" f'OS {ios_version.replace(\".\", \"_\")} like Mac OS X'",
        "detail": "custard.core.useragent",
        "documentation": {}
    },
    {
        "label": "ios_platform_token",
        "kind": 2,
        "importPath": "custard.core.useragent",
        "description": "custard.core.useragent",
        "peekOfCode": "def ios_platform_token() -> str:\n    apple_device: str = random_element(apple_devices)\n    ios_version: str = random_element(ios_versions)\n    return f\"{apple_device}; CPU {apple_device} \" f'OS {ios_version.replace(\".\", \"_\")} like Mac OS X'",
        "detail": "custard.core.useragent",
        "documentation": {}
    },
    {
        "label": "T",
        "kind": 5,
        "importPath": "custard.core.useragent",
        "description": "custard.core.useragent",
        "peekOfCode": "T = TypeVar(\"T\")\nElementsType = Collection[T]\nDateParseType = Union[date, datetime, timedelta, str, int]\nHueType = TypeVar(\"HueType\", str, float, Sequence[int])\nGenderType = TypeVar(\"GenderType\", bound=Literal[\"M\", \"F\"])\n_re_hash = re.compile(r\"#\")\n_re_perc = re.compile(r\"%\")\n_re_excl = re.compile(r\"!\")\n_re_at = re.compile(r\"@\")\n_re_qm = re.compile(r\"\\?\")",
        "detail": "custard.core.useragent",
        "documentation": {}
    },
    {
        "label": "ElementsType",
        "kind": 5,
        "importPath": "custard.core.useragent",
        "description": "custard.core.useragent",
        "peekOfCode": "ElementsType = Collection[T]\nDateParseType = Union[date, datetime, timedelta, str, int]\nHueType = TypeVar(\"HueType\", str, float, Sequence[int])\nGenderType = TypeVar(\"GenderType\", bound=Literal[\"M\", \"F\"])\n_re_hash = re.compile(r\"#\")\n_re_perc = re.compile(r\"%\")\n_re_excl = re.compile(r\"!\")\n_re_at = re.compile(r\"@\")\n_re_qm = re.compile(r\"\\?\")\n_re_cir = re.compile(r\"\\^\")",
        "detail": "custard.core.useragent",
        "documentation": {}
    },
    {
        "label": "DateParseType",
        "kind": 5,
        "importPath": "custard.core.useragent",
        "description": "custard.core.useragent",
        "peekOfCode": "DateParseType = Union[date, datetime, timedelta, str, int]\nHueType = TypeVar(\"HueType\", str, float, Sequence[int])\nGenderType = TypeVar(\"GenderType\", bound=Literal[\"M\", \"F\"])\n_re_hash = re.compile(r\"#\")\n_re_perc = re.compile(r\"%\")\n_re_excl = re.compile(r\"!\")\n_re_at = re.compile(r\"@\")\n_re_qm = re.compile(r\"\\?\")\n_re_cir = re.compile(r\"\\^\")\n__use_weighting__ = False",
        "detail": "custard.core.useragent",
        "documentation": {}
    },
    {
        "label": "HueType",
        "kind": 5,
        "importPath": "custard.core.useragent",
        "description": "custard.core.useragent",
        "peekOfCode": "HueType = TypeVar(\"HueType\", str, float, Sequence[int])\nGenderType = TypeVar(\"GenderType\", bound=Literal[\"M\", \"F\"])\n_re_hash = re.compile(r\"#\")\n_re_perc = re.compile(r\"%\")\n_re_excl = re.compile(r\"!\")\n_re_at = re.compile(r\"@\")\n_re_qm = re.compile(r\"\\?\")\n_re_cir = re.compile(r\"\\^\")\n__use_weighting__ = False\nuserAgents: ElementsType = (",
        "detail": "custard.core.useragent",
        "documentation": {}
    },
    {
        "label": "GenderType",
        "kind": 5,
        "importPath": "custard.core.useragent",
        "description": "custard.core.useragent",
        "peekOfCode": "GenderType = TypeVar(\"GenderType\", bound=Literal[\"M\", \"F\"])\n_re_hash = re.compile(r\"#\")\n_re_perc = re.compile(r\"%\")\n_re_excl = re.compile(r\"!\")\n_re_at = re.compile(r\"@\")\n_re_qm = re.compile(r\"\\?\")\n_re_cir = re.compile(r\"\\^\")\n__use_weighting__ = False\nuserAgents: ElementsType = (\n    \"chrome\",",
        "detail": "custard.core.useragent",
        "documentation": {}
    },
    {
        "label": "_re_hash",
        "kind": 5,
        "importPath": "custard.core.useragent",
        "description": "custard.core.useragent",
        "peekOfCode": "_re_hash = re.compile(r\"#\")\n_re_perc = re.compile(r\"%\")\n_re_excl = re.compile(r\"!\")\n_re_at = re.compile(r\"@\")\n_re_qm = re.compile(r\"\\?\")\n_re_cir = re.compile(r\"\\^\")\n__use_weighting__ = False\nuserAgents: ElementsType = (\n    \"chrome\",\n    \"firefox\",",
        "detail": "custard.core.useragent",
        "documentation": {}
    },
    {
        "label": "_re_perc",
        "kind": 5,
        "importPath": "custard.core.useragent",
        "description": "custard.core.useragent",
        "peekOfCode": "_re_perc = re.compile(r\"%\")\n_re_excl = re.compile(r\"!\")\n_re_at = re.compile(r\"@\")\n_re_qm = re.compile(r\"\\?\")\n_re_cir = re.compile(r\"\\^\")\n__use_weighting__ = False\nuserAgents: ElementsType = (\n    \"chrome\",\n    \"firefox\",\n    \"internet_explorer\",",
        "detail": "custard.core.useragent",
        "documentation": {}
    },
    {
        "label": "_re_excl",
        "kind": 5,
        "importPath": "custard.core.useragent",
        "description": "custard.core.useragent",
        "peekOfCode": "_re_excl = re.compile(r\"!\")\n_re_at = re.compile(r\"@\")\n_re_qm = re.compile(r\"\\?\")\n_re_cir = re.compile(r\"\\^\")\n__use_weighting__ = False\nuserAgents: ElementsType = (\n    \"chrome\",\n    \"firefox\",\n    \"internet_explorer\",\n    \"opera\",",
        "detail": "custard.core.useragent",
        "documentation": {}
    },
    {
        "label": "_re_at",
        "kind": 5,
        "importPath": "custard.core.useragent",
        "description": "custard.core.useragent",
        "peekOfCode": "_re_at = re.compile(r\"@\")\n_re_qm = re.compile(r\"\\?\")\n_re_cir = re.compile(r\"\\^\")\n__use_weighting__ = False\nuserAgents: ElementsType = (\n    \"chrome\",\n    \"firefox\",\n    \"internet_explorer\",\n    \"opera\",\n    \"safari\",",
        "detail": "custard.core.useragent",
        "documentation": {}
    },
    {
        "label": "_re_qm",
        "kind": 5,
        "importPath": "custard.core.useragent",
        "description": "custard.core.useragent",
        "peekOfCode": "_re_qm = re.compile(r\"\\?\")\n_re_cir = re.compile(r\"\\^\")\n__use_weighting__ = False\nuserAgents: ElementsType = (\n    \"chrome\",\n    \"firefox\",\n    \"internet_explorer\",\n    \"opera\",\n    \"safari\",\n)",
        "detail": "custard.core.useragent",
        "documentation": {}
    },
    {
        "label": "_re_cir",
        "kind": 5,
        "importPath": "custard.core.useragent",
        "description": "custard.core.useragent",
        "peekOfCode": "_re_cir = re.compile(r\"\\^\")\n__use_weighting__ = False\nuserAgents: ElementsType = (\n    \"chrome\",\n    \"firefox\",\n    \"internet_explorer\",\n    \"opera\",\n    \"safari\",\n)\nwin_platform_tokens: ElementsType = (",
        "detail": "custard.core.useragent",
        "documentation": {}
    },
    {
        "label": "__use_weighting__",
        "kind": 5,
        "importPath": "custard.core.useragent",
        "description": "custard.core.useragent",
        "peekOfCode": "__use_weighting__ = False\nuserAgents: ElementsType = (\n    \"chrome\",\n    \"firefox\",\n    \"internet_explorer\",\n    \"opera\",\n    \"safari\",\n)\nwin_platform_tokens: ElementsType = (\n    \"win 95\",",
        "detail": "custard.core.useragent",
        "documentation": {}
    },
    {
        "label": "random",
        "kind": 5,
        "importPath": "custard.core.useragent",
        "description": "custard.core.useragent",
        "peekOfCode": "random = random_module.Random()\nmod_random = random  # compat with name released in 0.8\ndef random_sample(random=None) -> float:\n    if random is None:\n        random = mod_random\n    return random.uniform(0.0, 1.0)\ndef cumsum(it: Iterable[float]):\n    total: float = 0\n    for x in it:\n        total += x",
        "detail": "custard.core.useragent",
        "documentation": {}
    },
    {
        "label": "mod_random",
        "kind": 5,
        "importPath": "custard.core.useragent",
        "description": "custard.core.useragent",
        "peekOfCode": "mod_random = random  # compat with name released in 0.8\ndef random_sample(random=None) -> float:\n    if random is None:\n        random = mod_random\n    return random.uniform(0.0, 1.0)\ndef cumsum(it: Iterable[float]):\n    total: float = 0\n    for x in it:\n        total += x\n        yield total",
        "detail": "custard.core.useragent",
        "documentation": {}
    },
    {
        "label": "language_locale_codes",
        "kind": 5,
        "importPath": "custard.core.useragent",
        "description": "custard.core.useragent",
        "peekOfCode": "language_locale_codes = {\n    \"aa\": (\"DJ\", \"ER\", \"ET\"),\n    \"af\": (\"ZA\",),\n    \"ak\": (\"GH\",),\n    \"am\": (\"ET\",),\n    \"an\": (\"ES\",),\n    \"apn\": (\"IN\",),\n    \"ar\": (\n        \"AE\",\n        \"BH\",",
        "detail": "custard.core.useragent",
        "documentation": {}
    },
    {
        "label": "Xml2Dict",
        "kind": 6,
        "importPath": "custard.core.xml2dict",
        "description": "custard.core.xml2dict",
        "peekOfCode": "class Xml2Dict(dict):\n    def __init__(self, parent_node):\n        if parent_node.items():\n            self.update_dict(dict(parent_node.items()))\n        for element in parent_node:\n            if len(element):\n                adict = Xml2Dict(element)\n                self.update_dict({element.tag: adict})\n            elif element.items():\n                element_attrib = element.items()",
        "detail": "custard.core.xml2dict",
        "documentation": {}
    },
    {
        "label": "stdout_write",
        "kind": 2,
        "importPath": "custard.core.xprint",
        "description": "custard.core.xprint",
        "peekOfCode": "def stdout_write(msg: str):\n    sys.stdout.write(msg)\n    sys.stdout.flush()\ndef stderr_write(msg: str):\n    sys.stderr.write(msg)\n    sys.stderr.flush()\ndef reverse_patch_print():\n    \"\"\"\n    提供一个反猴子补丁，恢复print原状\n    :return:",
        "detail": "custard.core.xprint",
        "documentation": {}
    },
    {
        "label": "stderr_write",
        "kind": 2,
        "importPath": "custard.core.xprint",
        "description": "custard.core.xprint",
        "peekOfCode": "def stderr_write(msg: str):\n    sys.stderr.write(msg)\n    sys.stderr.flush()\ndef reverse_patch_print():\n    \"\"\"\n    提供一个反猴子补丁，恢复print原状\n    :return:\n    \"\"\"\n    try:\n        __builtins__.print = print_raw",
        "detail": "custard.core.xprint",
        "documentation": {}
    },
    {
        "label": "reverse_patch_print",
        "kind": 2,
        "importPath": "custard.core.xprint",
        "description": "custard.core.xprint",
        "peekOfCode": "def reverse_patch_print():\n    \"\"\"\n    提供一个反猴子补丁，恢复print原状\n    :return:\n    \"\"\"\n    try:\n        __builtins__.print = print_raw\n    except AttributeError:\n        __builtins__['print'] = print_raw\ndef xprint(*args, sep=' ', end='\\n', file=None, color=True):",
        "detail": "custard.core.xprint",
        "documentation": {}
    },
    {
        "label": "xprint",
        "kind": 2,
        "importPath": "custard.core.xprint",
        "description": "custard.core.xprint",
        "peekOfCode": "def xprint(*args, sep=' ', end='\\n', file=None, color=True):\n    \"\"\"\n    超流弊的print补丁\n    Args:\n        *args:\n        sep:\n        end:\n        file:\n        color:\n    Returns:",
        "detail": "custard.core.xprint",
        "documentation": {}
    },
    {
        "label": "print_raw",
        "kind": 5,
        "importPath": "custard.core.xprint",
        "description": "custard.core.xprint",
        "peekOfCode": "print_raw = print\ndef stdout_write(msg: str):\n    sys.stdout.write(msg)\n    sys.stdout.flush()\ndef stderr_write(msg: str):\n    sys.stderr.write(msg)\n    sys.stderr.flush()\ndef reverse_patch_print():\n    \"\"\"\n    提供一个反猴子补丁，恢复print原状",
        "detail": "custard.core.xprint",
        "documentation": {}
    },
    {
        "label": "BatchTask",
        "kind": 6,
        "importPath": "custard.cron.batch_task",
        "description": "custard.cron.batch_task",
        "peekOfCode": "class BatchTask:\n    @staticmethod\n    def list_jobs(func_name, context):\n        \"\"\"\n        批量任务处理\n        Args:\n            func_name:\n            context:\n        Returns:\n        Examples:",
        "detail": "custard.cron.batch_task",
        "documentation": {}
    },
    {
        "label": "CryptoException",
        "kind": 6,
        "importPath": "custard.crypto.crypto",
        "description": "custard.crypto.crypto",
        "peekOfCode": "class CryptoException(Exception):\n    def __init__(self, message):\n        self._message = message\n    def __str__(self):\n        return str(self._message)\nclass AESCTRCipher(object):\n    \"\"\"数据加密类，用于加密用户数据\"\"\"\n    def __init__(self):\n        \"\"\"初始化\"\"\"\n        self.__block_size_len = AES.block_size",
        "detail": "custard.crypto.crypto",
        "documentation": {}
    },
    {
        "label": "AESCTRCipher",
        "kind": 6,
        "importPath": "custard.crypto.crypto",
        "description": "custard.crypto.crypto",
        "peekOfCode": "class AESCTRCipher(object):\n    \"\"\"数据加密类，用于加密用户数据\"\"\"\n    def __init__(self):\n        \"\"\"初始化\"\"\"\n        self.__block_size_len = AES.block_size\n        self.__cipher = None\n        self.__key_len = _AES_256_KEY_SIZE\n    def new_cipher(self, key, start, offset=0):\n        \"\"\"\n        初始化AES加解密对象",
        "detail": "custard.crypto.crypto",
        "documentation": {}
    },
    {
        "label": "RSAKeyPair",
        "kind": 6,
        "importPath": "custard.crypto.crypto",
        "description": "custard.crypto.crypto",
        "peekOfCode": "class RSAKeyPair:\n    \"\"\"封装有公钥和私钥\"\"\"\n    def __init__(self, public_key, private_key):\n        self.public_key = public_key\n        self.private_key = private_key\nclass RSAKeyPairPath:\n    \"\"\"封装有公钥和私钥的路径\"\"\"\n    def __init__(self, public_key_path, private_key_path):\n        self.public_key_path = public_key_path\n        self.private_key_path = private_key_path",
        "detail": "custard.crypto.crypto",
        "documentation": {}
    },
    {
        "label": "RSAKeyPairPath",
        "kind": 6,
        "importPath": "custard.crypto.crypto",
        "description": "custard.crypto.crypto",
        "peekOfCode": "class RSAKeyPairPath:\n    \"\"\"封装有公钥和私钥的路径\"\"\"\n    def __init__(self, public_key_path, private_key_path):\n        self.public_key_path = public_key_path\n        self.private_key_path = private_key_path\nclass BaseProvider(object):\n    \"\"\"客户端主密钥加密基类\"\"\"\n    def __init__(self, cipher):\n        \"\"\"初始化\n        :param cipher(an AES object): 数据加解密类",
        "detail": "custard.crypto.crypto",
        "documentation": {}
    },
    {
        "label": "BaseProvider",
        "kind": 6,
        "importPath": "custard.crypto.crypto",
        "description": "custard.crypto.crypto",
        "peekOfCode": "class BaseProvider(object):\n    \"\"\"客户端主密钥加密基类\"\"\"\n    def __init__(self, cipher):\n        \"\"\"初始化\n        :param cipher(an AES object): 数据加解密类\n        \"\"\"\n        self.data_cipher = cipher\n    def get_data_key(self):\n        \"\"\"随机获取数据加解密密钥\"\"\"\n        return self.data_cipher.get_key()",
        "detail": "custard.crypto.crypto",
        "documentation": {}
    },
    {
        "label": "RSAProvider",
        "kind": 6,
        "importPath": "custard.crypto.crypto",
        "description": "custard.crypto.crypto",
        "peekOfCode": "class RSAProvider(BaseProvider):\n    \"\"\"客户端非对称主密钥加密类\"\"\"\n    def __init__(self, key_pair_info=None, cipher=AESCTRCipher(), passphrase=None):\n        \"\"\"初始化\"\"\"\n        super(RSAProvider, self).__init__(cipher=cipher)\n        default_rsa_dir = os.path.expanduser('~/.local_rsa')\n        default_public_key_path = os.path.join(default_rsa_dir, '.public_key.pem')\n        default_private_key_path = os.path.join(default_rsa_dir, '.private_key.pem')\n        self.__encrypt_obj = None\n        self.__decrypt_obj = None",
        "detail": "custard.crypto.crypto",
        "documentation": {}
    },
    {
        "label": "AESProvider",
        "kind": 6,
        "importPath": "custard.crypto.crypto",
        "description": "custard.crypto.crypto",
        "peekOfCode": "class AESProvider(BaseProvider):\n    \"\"\"客户端对称主密钥加密类\"\"\"\n    def __init__(self, aes_key=None, aes_key_path=None, cipher=AESCTRCipher()):\n        \"\"\"初始化\"\"\"\n        super(AESProvider, self).__init__(cipher=cipher)\n        self.__ed_obj = None\n        self.__data_key = None\n        self.__data_iv = None\n        self.__my_counter = Counter.new(_AES_CTR_COUNTER_BITS_LENGTH, initial_value=0)\n        self.__aes_key = aes_key",
        "detail": "custard.crypto.crypto",
        "documentation": {}
    },
    {
        "label": "DataEncryptAdapter",
        "kind": 6,
        "importPath": "custard.crypto.crypto",
        "description": "custard.crypto.crypto",
        "peekOfCode": "class DataEncryptAdapter(object):\n    \"\"\"用于读取经过加密后的的数据\"\"\"\n    def __init__(self, data, content_len, data_cipher):\n        self._data = to_bytes(data)\n        self._data_cipher = data_cipher\n        self._content_len = content_len\n        self._read_len = 0\n    @property\n    def len(self):\n        return self._content_len",
        "detail": "custard.crypto.crypto",
        "documentation": {}
    },
    {
        "label": "DataDecryptAdapter",
        "kind": 6,
        "importPath": "custard.crypto.crypto",
        "description": "custard.crypto.crypto",
        "peekOfCode": "class DataDecryptAdapter(StreamBody):\n    \"\"\"用于读取经过解密后的数据\"\"\"\n    def __init__(self, rt, data_cipher, offset=0):\n        \"\"\"初始化\n        :param rt(request object): request请求返回的对象\n        :param data_cipher(an AES object): 数据加解密类\n        :param offset(int): 数据读取的偏移量\n        \"\"\"\n        super(DataDecryptAdapter, self).__init__(rt)\n        self._data_cipher = data_cipher",
        "detail": "custard.crypto.crypto",
        "documentation": {}
    },
    {
        "label": "to_bytes",
        "kind": 2,
        "importPath": "custard.crypto.crypto",
        "description": "custard.crypto.crypto",
        "peekOfCode": "def to_bytes(str_):\n    \"\"\"\n    将字符串转为bytes\n    Args:\n        str_:\n    Returns:\n    \"\"\"\n    if isinstance(str_, text_type):\n        try:\n            return str_.encode('utf-8')",
        "detail": "custard.crypto.crypto",
        "documentation": {}
    },
    {
        "label": "random_key",
        "kind": 2,
        "importPath": "custard.crypto.crypto",
        "description": "custard.crypto.crypto",
        "peekOfCode": "def random_key(key_len):\n    \"\"\"\n    Args:\n        key_len:\n    Returns:\n    \"\"\"\n    return Random.new().read(key_len)\ndef random_iv():\n    \"\"\"\n    Returns:",
        "detail": "custard.crypto.crypto",
        "documentation": {}
    },
    {
        "label": "random_iv",
        "kind": 2,
        "importPath": "custard.crypto.crypto",
        "description": "custard.crypto.crypto",
        "peekOfCode": "def random_iv():\n    \"\"\"\n    Returns:\n    \"\"\"\n    iv = Random.new().read(16)\n    return iv\ndef iv_to_big_int(iv):\n    \"\"\"\n    Args:\n        iv:",
        "detail": "custard.crypto.crypto",
        "documentation": {}
    },
    {
        "label": "iv_to_big_int",
        "kind": 2,
        "importPath": "custard.crypto.crypto",
        "description": "custard.crypto.crypto",
        "peekOfCode": "def iv_to_big_int(iv):\n    \"\"\"\n    Args:\n        iv:\n    Returns:\n    \"\"\"\n    iv_pair = struct.unpack(\">QQ\", iv)\n    iv_int = iv_pair[0] << 64 | iv_pair[1]\n    return iv_int\nclass CryptoException(Exception):",
        "detail": "custard.crypto.crypto",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "custard.crypto.crypto",
        "description": "custard.crypto.crypto",
        "peekOfCode": "logger = logging.getLogger(__name__)\n_AES_CTR_COUNTER_BITS_LENGTH = 8 * 16\n_AES_256_KEY_SIZE = 32\n__all__ = [\"BaseProvider\", \"AESProvider\", \"RSAProvider\", \"AESCTRCipher\", \"DataDecryptAdapter\", \"DataEncryptAdapter\"]\ndef to_bytes(str_):\n    \"\"\"\n    将字符串转为bytes\n    Args:\n        str_:\n    Returns:",
        "detail": "custard.crypto.crypto",
        "documentation": {}
    },
    {
        "label": "_AES_CTR_COUNTER_BITS_LENGTH",
        "kind": 5,
        "importPath": "custard.crypto.crypto",
        "description": "custard.crypto.crypto",
        "peekOfCode": "_AES_CTR_COUNTER_BITS_LENGTH = 8 * 16\n_AES_256_KEY_SIZE = 32\n__all__ = [\"BaseProvider\", \"AESProvider\", \"RSAProvider\", \"AESCTRCipher\", \"DataDecryptAdapter\", \"DataEncryptAdapter\"]\ndef to_bytes(str_):\n    \"\"\"\n    将字符串转为bytes\n    Args:\n        str_:\n    Returns:\n    \"\"\"",
        "detail": "custard.crypto.crypto",
        "documentation": {}
    },
    {
        "label": "_AES_256_KEY_SIZE",
        "kind": 5,
        "importPath": "custard.crypto.crypto",
        "description": "custard.crypto.crypto",
        "peekOfCode": "_AES_256_KEY_SIZE = 32\n__all__ = [\"BaseProvider\", \"AESProvider\", \"RSAProvider\", \"AESCTRCipher\", \"DataDecryptAdapter\", \"DataEncryptAdapter\"]\ndef to_bytes(str_):\n    \"\"\"\n    将字符串转为bytes\n    Args:\n        str_:\n    Returns:\n    \"\"\"\n    if isinstance(str_, text_type):",
        "detail": "custard.crypto.crypto",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "custard.crypto.crypto",
        "description": "custard.crypto.crypto",
        "peekOfCode": "__all__ = [\"BaseProvider\", \"AESProvider\", \"RSAProvider\", \"AESCTRCipher\", \"DataDecryptAdapter\", \"DataEncryptAdapter\"]\ndef to_bytes(str_):\n    \"\"\"\n    将字符串转为bytes\n    Args:\n        str_:\n    Returns:\n    \"\"\"\n    if isinstance(str_, text_type):\n        try:",
        "detail": "custard.crypto.crypto",
        "documentation": {}
    },
    {
        "label": "StreamBody",
        "kind": 6,
        "importPath": "custard.crypto.streambody",
        "description": "custard.crypto.streambody",
        "peekOfCode": "class StreamBody(object):\n    def __init__(self, rt):\n        self._rt = rt\n        self._read_len = 0\n        self._content_len = 0\n        self._use_chunked = False\n        self._use_encoding = False\n        if 'Content-Length' in self._rt.headers:\n            self._content_len = int(self._rt.headers['Content-Length'])\n        elif 'Transfer-Encoding' in self._rt.headers and self._rt.headers['Transfer-Encoding'] == \"chunked\":",
        "detail": "custard.crypto.streambody",
        "documentation": {}
    },
    {
        "label": "TableNotFoundError",
        "kind": 6,
        "importPath": "custard.db.exc",
        "description": "custard.db.exc",
        "peekOfCode": "class TableNotFoundError(Exception):\n    pass\nclass TableTypeError(Exception):\n    pass",
        "detail": "custard.db.exc",
        "documentation": {}
    },
    {
        "label": "TableTypeError",
        "kind": 6,
        "importPath": "custard.db.exc",
        "description": "custard.db.exc",
        "peekOfCode": "class TableTypeError(Exception):\n    pass",
        "detail": "custard.db.exc",
        "documentation": {}
    },
    {
        "label": "MySqlInspect",
        "kind": 6,
        "importPath": "custard.db.inspect",
        "description": "custard.db.inspect",
        "peekOfCode": "class MySqlInspect:\n    def __init__(self, source_schema: Optional[str], source_url: Optional[str],\n                 source_user: Optional[str], source_password: Optional[str], source_port: Optional[int],\n                 target_schema: Optional[str], target_url: Optional[str],\n                 target_user: Optional[str], target_password: Optional[str], target_port: Optional[int]\n                 ):\n        \"\"\"\n        检查数据结构\n        source： 参考、target：目标\n        Args:",
        "detail": "custard.db.inspect",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "custard.db.logger",
        "description": "custard.db.logger",
        "peekOfCode": "__all__ = ['getLogger', 'INFO', 'WARN', 'DEBUG', 'TRACE', 'ERROR', 'FATAL', 'logger']\nTRACE = logging.TRACE = DEBUG - 5\nlogging.addLevelName(TRACE, 'TRACE')\nFORMAT = '%(relativeCreated)d %(levelname)s: %(message)s'\nlogging.basicConfig(format=FORMAT, level=logging.INFO)\nlogger = getLogger('dts')\ndef __add_options(parser):\n    levels = ('TRACE', 'DEBUG', 'INFO', 'WARN', 'ERROR', 'CRITICAL')\n    parser.add_argument(\n        '--log-level',",
        "detail": "custard.db.logger",
        "documentation": {}
    },
    {
        "label": "TRACE",
        "kind": 5,
        "importPath": "custard.db.logger",
        "description": "custard.db.logger",
        "peekOfCode": "TRACE = logging.TRACE = DEBUG - 5\nlogging.addLevelName(TRACE, 'TRACE')\nFORMAT = '%(relativeCreated)d %(levelname)s: %(message)s'\nlogging.basicConfig(format=FORMAT, level=logging.INFO)\nlogger = getLogger('dts')\ndef __add_options(parser):\n    levels = ('TRACE', 'DEBUG', 'INFO', 'WARN', 'ERROR', 'CRITICAL')\n    parser.add_argument(\n        '--log-level',\n        choices=levels,",
        "detail": "custard.db.logger",
        "documentation": {}
    },
    {
        "label": "FORMAT",
        "kind": 5,
        "importPath": "custard.db.logger",
        "description": "custard.db.logger",
        "peekOfCode": "FORMAT = '%(relativeCreated)d %(levelname)s: %(message)s'\nlogging.basicConfig(format=FORMAT, level=logging.INFO)\nlogger = getLogger('dts')\ndef __add_options(parser):\n    levels = ('TRACE', 'DEBUG', 'INFO', 'WARN', 'ERROR', 'CRITICAL')\n    parser.add_argument(\n        '--log-level',\n        choices=levels,\n        metavar=\"LEVEL\",\n        default='INFO',",
        "detail": "custard.db.logger",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "custard.db.logger",
        "description": "custard.db.logger",
        "peekOfCode": "logger = getLogger('dts')\ndef __add_options(parser):\n    levels = ('TRACE', 'DEBUG', 'INFO', 'WARN', 'ERROR', 'CRITICAL')\n    parser.add_argument(\n        '--log-level',\n        choices=levels,\n        metavar=\"LEVEL\",\n        default='INFO',\n        dest='loglevel',\n        help='Amount of detail in build-time console messages. LEVEL may be one of %s (default: %%(default)s).' %",
        "detail": "custard.db.logger",
        "documentation": {}
    },
    {
        "label": "MysqlUtil",
        "kind": 6,
        "importPath": "custard.db.utils",
        "description": "custard.db.utils",
        "peekOfCode": "class MysqlUtil:\n    def __init__(self, schema: Optional[str], url: Optional[str],\n                 user: Optional[str], password: Optional[str], port: Optional[int]):\n        self.__schema = schema\n        self.__url = url\n        self.__user = user\n        self.__password = password\n        self.__port = port\n        self.__config = {\n            'host': self.__url,",
        "detail": "custard.db.utils",
        "documentation": {}
    },
    {
        "label": "ExcContextManager",
        "kind": 6,
        "importPath": "custard.expect.context",
        "description": "custard.expect.context",
        "peekOfCode": "class ExcContextManager:\n    def __init__(self, verbose=100, donot_raise__exception=True):\n        \"\"\"\n        用上下文管理器捕获异常，可对代码片段进行错误捕捉，比装饰器更细腻\n        Args:\n            verbose: 打印错误的深度,对应traceback对象的limit，为正整数\n            donot_raise__exception: 打印错误的深度,对应traceback对象的limit，为正整数\n        \"\"\"\n        self._verbose = verbose\n        self._donot_raise__exception = donot_raise__exception",
        "detail": "custard.expect.context",
        "documentation": {}
    },
    {
        "label": "MyBaseFailure",
        "kind": 6,
        "importPath": "custard.expect.exceptions",
        "description": "custard.expect.exceptions",
        "peekOfCode": "class MyBaseFailure(Exception):\n    pass\nclass ValidationFailure(MyBaseFailure):\n    pass\nclass ExtractFailure(MyBaseFailure):\n    pass\nclass SetupHooksFailure(MyBaseFailure):\n    pass\nclass TeardownHooksFailure(MyBaseFailure):\n    pass",
        "detail": "custard.expect.exceptions",
        "documentation": {}
    },
    {
        "label": "ValidationFailure",
        "kind": 6,
        "importPath": "custard.expect.exceptions",
        "description": "custard.expect.exceptions",
        "peekOfCode": "class ValidationFailure(MyBaseFailure):\n    pass\nclass ExtractFailure(MyBaseFailure):\n    pass\nclass SetupHooksFailure(MyBaseFailure):\n    pass\nclass TeardownHooksFailure(MyBaseFailure):\n    pass\nclass MyBaseError(Exception):\n    pass",
        "detail": "custard.expect.exceptions",
        "documentation": {}
    },
    {
        "label": "ExtractFailure",
        "kind": 6,
        "importPath": "custard.expect.exceptions",
        "description": "custard.expect.exceptions",
        "peekOfCode": "class ExtractFailure(MyBaseFailure):\n    pass\nclass SetupHooksFailure(MyBaseFailure):\n    pass\nclass TeardownHooksFailure(MyBaseFailure):\n    pass\nclass MyBaseError(Exception):\n    pass\nclass FileFormatError(MyBaseError):\n    pass",
        "detail": "custard.expect.exceptions",
        "documentation": {}
    },
    {
        "label": "SetupHooksFailure",
        "kind": 6,
        "importPath": "custard.expect.exceptions",
        "description": "custard.expect.exceptions",
        "peekOfCode": "class SetupHooksFailure(MyBaseFailure):\n    pass\nclass TeardownHooksFailure(MyBaseFailure):\n    pass\nclass MyBaseError(Exception):\n    pass\nclass FileFormatError(MyBaseError):\n    pass\nclass ParamsError(MyBaseError):\n    pass",
        "detail": "custard.expect.exceptions",
        "documentation": {}
    },
    {
        "label": "TeardownHooksFailure",
        "kind": 6,
        "importPath": "custard.expect.exceptions",
        "description": "custard.expect.exceptions",
        "peekOfCode": "class TeardownHooksFailure(MyBaseFailure):\n    pass\nclass MyBaseError(Exception):\n    pass\nclass FileFormatError(MyBaseError):\n    pass\nclass ParamsError(MyBaseError):\n    pass\nclass NotFoundError(MyBaseError):\n    pass",
        "detail": "custard.expect.exceptions",
        "documentation": {}
    },
    {
        "label": "MyBaseError",
        "kind": 6,
        "importPath": "custard.expect.exceptions",
        "description": "custard.expect.exceptions",
        "peekOfCode": "class MyBaseError(Exception):\n    pass\nclass FileFormatError(MyBaseError):\n    pass\nclass ParamsError(MyBaseError):\n    pass\nclass NotFoundError(MyBaseError):\n    pass\nclass FileNotFound(FileNotFoundError, NotFoundError):\n    pass",
        "detail": "custard.expect.exceptions",
        "documentation": {}
    },
    {
        "label": "FileFormatError",
        "kind": 6,
        "importPath": "custard.expect.exceptions",
        "description": "custard.expect.exceptions",
        "peekOfCode": "class FileFormatError(MyBaseError):\n    pass\nclass ParamsError(MyBaseError):\n    pass\nclass NotFoundError(MyBaseError):\n    pass\nclass FileNotFound(FileNotFoundError, NotFoundError):\n    pass\nclass FunctionNotFound(NotFoundError):\n    pass",
        "detail": "custard.expect.exceptions",
        "documentation": {}
    },
    {
        "label": "ParamsError",
        "kind": 6,
        "importPath": "custard.expect.exceptions",
        "description": "custard.expect.exceptions",
        "peekOfCode": "class ParamsError(MyBaseError):\n    pass\nclass NotFoundError(MyBaseError):\n    pass\nclass FileNotFound(FileNotFoundError, NotFoundError):\n    pass\nclass FunctionNotFound(NotFoundError):\n    pass\nclass VariableNotFound(NotFoundError):\n    pass",
        "detail": "custard.expect.exceptions",
        "documentation": {}
    },
    {
        "label": "NotFoundError",
        "kind": 6,
        "importPath": "custard.expect.exceptions",
        "description": "custard.expect.exceptions",
        "peekOfCode": "class NotFoundError(MyBaseError):\n    pass\nclass FileNotFound(FileNotFoundError, NotFoundError):\n    pass\nclass FunctionNotFound(NotFoundError):\n    pass\nclass VariableNotFound(NotFoundError):\n    pass\nclass ApiNotFound(NotFoundError):\n    pass",
        "detail": "custard.expect.exceptions",
        "documentation": {}
    },
    {
        "label": "FileNotFound",
        "kind": 6,
        "importPath": "custard.expect.exceptions",
        "description": "custard.expect.exceptions",
        "peekOfCode": "class FileNotFound(FileNotFoundError, NotFoundError):\n    pass\nclass FunctionNotFound(NotFoundError):\n    pass\nclass VariableNotFound(NotFoundError):\n    pass\nclass ApiNotFound(NotFoundError):\n    pass\nclass TestcaseNotFound(NotFoundError):\n    pass",
        "detail": "custard.expect.exceptions",
        "documentation": {}
    },
    {
        "label": "FunctionNotFound",
        "kind": 6,
        "importPath": "custard.expect.exceptions",
        "description": "custard.expect.exceptions",
        "peekOfCode": "class FunctionNotFound(NotFoundError):\n    pass\nclass VariableNotFound(NotFoundError):\n    pass\nclass ApiNotFound(NotFoundError):\n    pass\nclass TestcaseNotFound(NotFoundError):\n    pass\nclass ExpectValueParseFailure(Exception):\n    pass",
        "detail": "custard.expect.exceptions",
        "documentation": {}
    },
    {
        "label": "VariableNotFound",
        "kind": 6,
        "importPath": "custard.expect.exceptions",
        "description": "custard.expect.exceptions",
        "peekOfCode": "class VariableNotFound(NotFoundError):\n    pass\nclass ApiNotFound(NotFoundError):\n    pass\nclass TestcaseNotFound(NotFoundError):\n    pass\nclass ExpectValueParseFailure(Exception):\n    pass",
        "detail": "custard.expect.exceptions",
        "documentation": {}
    },
    {
        "label": "ApiNotFound",
        "kind": 6,
        "importPath": "custard.expect.exceptions",
        "description": "custard.expect.exceptions",
        "peekOfCode": "class ApiNotFound(NotFoundError):\n    pass\nclass TestcaseNotFound(NotFoundError):\n    pass\nclass ExpectValueParseFailure(Exception):\n    pass",
        "detail": "custard.expect.exceptions",
        "documentation": {}
    },
    {
        "label": "TestcaseNotFound",
        "kind": 6,
        "importPath": "custard.expect.exceptions",
        "description": "custard.expect.exceptions",
        "peekOfCode": "class TestcaseNotFound(NotFoundError):\n    pass\nclass ExpectValueParseFailure(Exception):\n    pass",
        "detail": "custard.expect.exceptions",
        "documentation": {}
    },
    {
        "label": "ExpectValueParseFailure",
        "kind": 6,
        "importPath": "custard.expect.exceptions",
        "description": "custard.expect.exceptions",
        "peekOfCode": "class ExpectValueParseFailure(Exception):\n    pass",
        "detail": "custard.expect.exceptions",
        "documentation": {}
    },
    {
        "label": "args_to_str",
        "kind": 2,
        "importPath": "custard.expect.record",
        "description": "custard.expect.record",
        "peekOfCode": "def args_to_str(*args, **kwargs):\n    \"\"\"\n    args 转换为 str\n    Args:\n        *args:\n        **kwargs:\n    Returns:\n    \"\"\"\n    str1 = \", \".join(str(i) for i in args)\n    kv = []",
        "detail": "custard.expect.record",
        "documentation": {}
    },
    {
        "label": "handle_exception",
        "kind": 2,
        "importPath": "custard.expect.record",
        "description": "custard.expect.record",
        "peekOfCode": "def handle_exception(retry_times=0, error_detail_level=0, is_throw_error=False, time_sleep=0, logger=None):\n    \"\"\"\n    捕获函数错误的装饰器,重试并打印日志\n    Args:\n        retry_times: 重试次数\n        error_detail_level: 为0打印exception提示，为1打印3层深度的错误堆栈，为2打印所有深度层次的错误堆栈\n        is_throw_error: 在达到最大次数时候是否重新抛出错误\n        time_sleep: 休眠时间\n        logger:\n    Returns:",
        "detail": "custard.expect.record",
        "documentation": {}
    },
    {
        "label": "keep_circulating",
        "kind": 2,
        "importPath": "custard.expect.spacer",
        "description": "custard.expect.spacer",
        "peekOfCode": "def keep_circulating(time_sleep=0.001, exit_if_function_run_succeed=True, is_display_detail_exception=True,\n                     block=True, daemon=False, logger=None):\n    \"\"\"\n    间隔一段时间，一直循环运行某个方法的装饰器\n    Args:\n        time_sleep: 循环的间隔时间\n        exit_if_function_run_succeed: 如果成功了就退出循环\n        is_display_detail_exception:  是否显示细节异常\n        block: 是否阻塞主主线程，False时候开启一个新的线程运行while 1。\n        daemon: 如果使用线程，那么是否使用守护线程，使这个while 1有机会自动结束。",
        "detail": "custard.expect.spacer",
        "documentation": {}
    },
    {
        "label": "where_is_it_called",
        "kind": 2,
        "importPath": "custard.function.callsource",
        "description": "custard.function.callsource",
        "peekOfCode": "def where_is_it_called(func):\n    \"\"\"一个装饰器，被装饰的函数，如果被调用，将记录一条日志,记录函数被什么文件的哪一行代码所调用，非常犀利黑科技的装饰器\"\"\"\n    @wraps(func)\n    def _where_is_it_called(*args, **kwargs):\n        # 获取被调用函数名称\n        # func_name = sys._getframe().f_code.co_name\n        func_name = func.__name__\n        # 什么函数调用了此函数\n        which_fun_call_this = sys._getframe(1).f_code.co_name  # NOQA\n        # 获取被调用函数在被调用时所处代码行数",
        "detail": "custard.function.callsource",
        "documentation": {}
    },
    {
        "label": "bind_run_many_times",
        "kind": 2,
        "importPath": "custard.function.traverse",
        "description": "custard.function.traverse",
        "peekOfCode": "def bind_run_many_times(times=1, logger=None):\n    \"\"\"\n    设置函数运行次数\n    Args:\n        times: 运行次数\n        logger: 日志开关\n    Returns: 没有捕获错误，出错误就中断运行，可以配合handle_exception装饰器不管是否错误都运行n次。\n    Examples:\n        >>> import time\n        >>> @bind_run_many_times(5)",
        "detail": "custard.function.traverse",
        "documentation": {}
    },
    {
        "label": "DFAFilter",
        "kind": 6,
        "importPath": "custard.hitfilter.hitfilter",
        "description": "custard.hitfilter.hitfilter",
        "peekOfCode": "class DFAFilter:\n    \"\"\"\n    Filter Messages from keywords\n    Use DFA to keep algorithm perform constantly\n    >>> f = DFAFilter()\n    >>> f.add(\"sexy\")\n    >>> f.filter(\"hello sexy baby\")\n    \"\"\"\n    def __init__(self):\n        self.keyword_path = [f\"{os.path.dirname(os.path.realpath(__file__))}/keywords\"]",
        "detail": "custard.hitfilter.hitfilter",
        "documentation": {}
    },
    {
        "label": "JsonEncoder",
        "kind": 6,
        "importPath": "custard.json.jsonlogger",
        "description": "custard.json.jsonlogger",
        "peekOfCode": "class JsonEncoder(json.JSONEncoder):\n    \"\"\"\n    A custom encoder extending the default JSONEncoder\n    \"\"\"\n    def default(self, obj):\n        if isinstance(obj, (date, datetime, time)):\n            return self.format_datetime_obj(obj)\n        elif istraceback(obj):\n            return ''.join(traceback.format_tb(obj)).strip()\n        elif type(obj) == Exception \\",
        "detail": "custard.json.jsonlogger",
        "documentation": {}
    },
    {
        "label": "JsonFormatter",
        "kind": 6,
        "importPath": "custard.json.jsonlogger",
        "description": "custard.json.jsonlogger",
        "peekOfCode": "class JsonFormatter(logging.Formatter):\n    \"\"\"\n    A custom formatter to format logging records as json strings.\n    Extra values will be formatted as str() if not supported by\n    json default encoder\n    \"\"\"\n    def __init__(self, *args, **kwargs):\n        \"\"\"\n        Args:\n            json_default: a function for encoding non-standard objects",
        "detail": "custard.json.jsonlogger",
        "documentation": {}
    },
    {
        "label": "merge_record_extra",
        "kind": 2,
        "importPath": "custard.json.jsonlogger",
        "description": "custard.json.jsonlogger",
        "peekOfCode": "def merge_record_extra(record, target, reserved):\n    \"\"\"\n        Merges extra attributes from LogRecord object into target dictionary\n    Args:\n        record: logging.LogRecord\n        target: dict to update\n        reserved: dict or list with reserved keys to skip\n    Returns:\n    \"\"\"\n    for key, value in record.__dict__.items():",
        "detail": "custard.json.jsonlogger",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "custard.json.jsonlogger",
        "description": "custard.json.jsonlogger",
        "peekOfCode": "__all__ = (\"JsonEncoder\", \"JsonFormatter\", \"merge_record_extra\")\nRESERVED_ATTRS = (\n    'args', 'asctime', 'created', 'exc_info', 'exc_text', 'filename',\n    'funcName', 'levelname', 'levelno', 'lineno', 'module',\n    'msecs', 'message', 'msg', 'name', 'pathname', 'process',\n    'processName', 'relativeCreated', 'stack_info', 'thread', 'threadName')\ndef merge_record_extra(record, target, reserved):\n    \"\"\"\n        Merges extra attributes from LogRecord object into target dictionary\n    Args:",
        "detail": "custard.json.jsonlogger",
        "documentation": {}
    },
    {
        "label": "RESERVED_ATTRS",
        "kind": 5,
        "importPath": "custard.json.jsonlogger",
        "description": "custard.json.jsonlogger",
        "peekOfCode": "RESERVED_ATTRS = (\n    'args', 'asctime', 'created', 'exc_info', 'exc_text', 'filename',\n    'funcName', 'levelname', 'levelno', 'lineno', 'module',\n    'msecs', 'message', 'msg', 'name', 'pathname', 'process',\n    'processName', 'relativeCreated', 'stack_info', 'thread', 'threadName')\ndef merge_record_extra(record, target, reserved):\n    \"\"\"\n        Merges extra attributes from LogRecord object into target dictionary\n    Args:\n        record: logging.LogRecord",
        "detail": "custard.json.jsonlogger",
        "documentation": {}
    },
    {
        "label": "CaptchaPainter",
        "kind": 6,
        "importPath": "custard.kaptcha.captcha",
        "description": "custard.kaptcha.captcha",
        "peekOfCode": "class CaptchaPainter:\n    def __fill_color(self):\n        \"\"\"\n        获取颜色\n        :return:\n        \"\"\"\n        if self.mode == \"RGB\" or self.mode == \"RGBW\":\n            return random.randint(0, 255), random.randint(0, 255), random.randint(0, 255), random.randint(150, 255)\n        else:\n            return random.randint(0, 155)",
        "detail": "custard.kaptcha.captcha",
        "documentation": {}
    },
    {
        "label": "Captcha",
        "kind": 6,
        "importPath": "custard.kaptcha.captcha",
        "description": "custard.kaptcha.captcha",
        "peekOfCode": "class Captcha:\n    @staticmethod\n    def __rand(string, k):\n        return \"\".join(random.choices(string, k=k))\n    def __filter(self, _im):\n        if self.contour:\n            return _im.filter(ImageFilter.CONTOUR)\n        elif self.enhance:\n            return _im.filter(ImageFilter.EDGE_ENHANCE_MORE)\n        elif self.edge:",
        "detail": "custard.kaptcha.captcha",
        "documentation": {}
    },
    {
        "label": "ascii_letters",
        "kind": 5,
        "importPath": "custard.kaptcha.captcha",
        "description": "custard.kaptcha.captcha",
        "peekOfCode": "ascii_letters = ascii_letters.replace(\"i\", \"\").replace(\"l\", \"\") \\\n    .replace(\"I\", \"\").replace(\"Q\", \"\").replace(\"j\", \"\").replace(\"q\", \"\")\ndigits = digits.replace(\"0\", \"\")\nBASE_DIR = os.path.dirname(os.path.realpath(__file__))\nFONT = [BASE_DIR + \"/font1.ttf\",\n        BASE_DIR + \"/font2.ttf\",\n        BASE_DIR + \"/font3.ttf\",\n        BASE_DIR + \"/font4.ttf\"]  # https://fonts.google.com/\nclass CaptchaPainter:\n    def __fill_color(self):",
        "detail": "custard.kaptcha.captcha",
        "documentation": {}
    },
    {
        "label": "digits",
        "kind": 5,
        "importPath": "custard.kaptcha.captcha",
        "description": "custard.kaptcha.captcha",
        "peekOfCode": "digits = digits.replace(\"0\", \"\")\nBASE_DIR = os.path.dirname(os.path.realpath(__file__))\nFONT = [BASE_DIR + \"/font1.ttf\",\n        BASE_DIR + \"/font2.ttf\",\n        BASE_DIR + \"/font3.ttf\",\n        BASE_DIR + \"/font4.ttf\"]  # https://fonts.google.com/\nclass CaptchaPainter:\n    def __fill_color(self):\n        \"\"\"\n        获取颜色",
        "detail": "custard.kaptcha.captcha",
        "documentation": {}
    },
    {
        "label": "BASE_DIR",
        "kind": 5,
        "importPath": "custard.kaptcha.captcha",
        "description": "custard.kaptcha.captcha",
        "peekOfCode": "BASE_DIR = os.path.dirname(os.path.realpath(__file__))\nFONT = [BASE_DIR + \"/font1.ttf\",\n        BASE_DIR + \"/font2.ttf\",\n        BASE_DIR + \"/font3.ttf\",\n        BASE_DIR + \"/font4.ttf\"]  # https://fonts.google.com/\nclass CaptchaPainter:\n    def __fill_color(self):\n        \"\"\"\n        获取颜色\n        :return:",
        "detail": "custard.kaptcha.captcha",
        "documentation": {}
    },
    {
        "label": "FONT",
        "kind": 5,
        "importPath": "custard.kaptcha.captcha",
        "description": "custard.kaptcha.captcha",
        "peekOfCode": "FONT = [BASE_DIR + \"/font1.ttf\",\n        BASE_DIR + \"/font2.ttf\",\n        BASE_DIR + \"/font3.ttf\",\n        BASE_DIR + \"/font4.ttf\"]  # https://fonts.google.com/\nclass CaptchaPainter:\n    def __fill_color(self):\n        \"\"\"\n        获取颜色\n        :return:\n        \"\"\"",
        "detail": "custard.kaptcha.captcha",
        "documentation": {}
    },
    {
        "label": "RateLimiter",
        "kind": 6,
        "importPath": "custard.limiter.depends",
        "description": "custard.limiter.depends",
        "peekOfCode": "class RateLimiter:\n    def __init__(\n            self,\n            counts: conint(ge=0) = 1,\n            milliseconds: conint(ge=-1) = 0,\n            seconds: conint(ge=-1) = 0,\n            minutes: conint(ge=-1) = 0,\n            hours: conint(ge=-1) = 0,\n            identifier: Optional[Callable] = None,\n            callback: Optional[Callable] = None,",
        "detail": "custard.limiter.depends",
        "documentation": {}
    },
    {
        "label": "GlobalVarEnum",
        "kind": 6,
        "importPath": "custard.limiter.enums",
        "description": "custard.limiter.enums",
        "peekOfCode": "class GlobalVarEnum:\n    APP_NAME = \"custard\"",
        "detail": "custard.limiter.enums",
        "documentation": {}
    },
    {
        "label": "RateLimitException",
        "kind": 6,
        "importPath": "custard.limiter.execres",
        "description": "custard.limiter.execres",
        "peekOfCode": "class RateLimitException(Exception):\n    def __init__(\n            self,\n            headers: dict,\n            code: int = 429,\n            detail: str = \"The interview is too fast, please have a cup of tea and take a break!\",\n            status_code: int = status.HTTP_429_TOO_MANY_REQUESTS,\n    ):\n        self.code = code\n        self.headers = headers",
        "detail": "custard.limiter.execres",
        "documentation": {}
    },
    {
        "label": "sync_redis_lock",
        "kind": 2,
        "importPath": "custard.lock.redis_lock",
        "description": "custard.lock.redis_lock",
        "peekOfCode": "def sync_redis_lock(key, client, lock_time_out):\n    \"\"\"\n    redis分布式锁装饰器\n    todo:锁的超时时间需要考虑任务函数执行时间,任务函数执行时间可能会越来越长,如果函数执行时间超出锁设置时间可能会存在执行多次情况\n    redis命令\n        以redis的key为锁名,value为超时时间\n        get 获取对应key的value\n        setnx 设置一个str类型.key存在不执行,返回0(受影响行数).key不存在插入一条数据,返回1\n        getset 为一个str类型设置一个新的value并返回之前的value\n    原理：",
        "detail": "custard.lock.redis_lock",
        "documentation": {}
    },
    {
        "label": "synchronized_lock",
        "kind": 2,
        "importPath": "custard.lock.thread_lock",
        "description": "custard.lock.thread_lock",
        "peekOfCode": "def synchronized_lock(func):\n    \"\"\"\n    线程锁装饰器，可以加在单例模式上\n    Args:\n        func:\n    Returns:\n    \"\"\"\n    func.__lock__ = threading.Lock()\n    @wraps(func)\n    def lock_func(*args, **kwargs):",
        "detail": "custard.lock.thread_lock",
        "documentation": {}
    },
    {
        "label": "singleton_lock",
        "kind": 2,
        "importPath": "custard.lock.thread_lock",
        "description": "custard.lock.thread_lock",
        "peekOfCode": "def singleton_lock(cls):\n    \"\"\"\n    单例模式装饰器,新加入线程锁，更牢固的单例模式，主要解决多线程如100线程同时实例化情况下可能会出现三例四例的情况,实测。\n    Args:\n        cls:\n    Returns:\n    \"\"\"\n    _instance = {}\n    singleton_lock.__lock = threading.Lock()\n    @wraps(cls)",
        "detail": "custard.lock.thread_lock",
        "documentation": {}
    },
    {
        "label": "chunk",
        "kind": 2,
        "importPath": "custard.lodash.arrays",
        "description": "custard.lodash.arrays",
        "peekOfCode": "def chunk(array, size=1):\n    \"\"\"Creates an array of elements split into groups the length of size. If array can't be split evenly, the final chunk will be the remaining elements.\n    Arguments:\n        array {list} -- The array to process\n    Keyword Arguments:\n        size {int} -- The length of each chunk (default: {1})\n    Returns:\n        (list) -- Returns the new array of chunks.\n    \"\"\"\n    result = []",
        "detail": "custard.lodash.arrays",
        "documentation": {}
    },
    {
        "label": "append_list",
        "kind": 2,
        "importPath": "custard.lodash.arrays",
        "description": "custard.lodash.arrays",
        "peekOfCode": "def append_list(array, size, result):\n    \"\"\"Creates an arrays with small array inside\n    Arguments:\n        array {list} -- The array to process\n        size {int} -- The length of each chunk\n        result {type} -- New arrays of chunks\n    Returns:\n        (list) -- Returns the new array of chunks\n    \"\"\"\n    # condition to stop recusion",
        "detail": "custard.lodash.arrays",
        "documentation": {}
    },
    {
        "label": "compact",
        "kind": 2,
        "importPath": "custard.lodash.arrays",
        "description": "custard.lodash.arrays",
        "peekOfCode": "def compact(array):\n    \"\"\"Creates an array with all falsey values removed. The values False, None, and \"\" are falsey.\n    Arguments:\n        array {list} -- The array to compact.\n    Returns:\n        (list) -- Returns the new array of filtered values.\n    \"\"\"\n    return [i for i in array if i not in [False, None, '']]\ndef difference(array, values):\n    \"\"\"Creates an array of array values not included in the other given arrays using SameValueZero for equality comparisons. The order and references of result values are determined by the first array.",
        "detail": "custard.lodash.arrays",
        "documentation": {}
    },
    {
        "label": "difference",
        "kind": 2,
        "importPath": "custard.lodash.arrays",
        "description": "custard.lodash.arrays",
        "peekOfCode": "def difference(array, values):\n    \"\"\"Creates an array of array values not included in the other given arrays using SameValueZero for equality comparisons. The order and references of result values are determined by the first array.\n    Arguments:\n        array {list} -- The array to inspect.\n        values {list} -- The values to exclude.\n    Returns:\n        (list) -- Returns the new array of filtered values.\n    \"\"\"\n    return list(set(array) - set(values))\ndef drop(array, number=1):",
        "detail": "custard.lodash.arrays",
        "documentation": {}
    },
    {
        "label": "drop",
        "kind": 2,
        "importPath": "custard.lodash.arrays",
        "description": "custard.lodash.arrays",
        "peekOfCode": "def drop(array, number=1):\n    \"\"\"Creates a slice of array with n elements dropped from the beginning.\n    Arguments:\n        array {list} -- The array to query.\n    Keyword Arguments:\n        number {int} -- The number of elements to drop. (default: {1})\n    Returns:\n        (list) -- Returns the slice of array.\n    \"\"\"\n    return array[number: len(array)] if helper.is_number(number) else array",
        "detail": "custard.lodash.arrays",
        "documentation": {}
    },
    {
        "label": "drop_right",
        "kind": 2,
        "importPath": "custard.lodash.arrays",
        "description": "custard.lodash.arrays",
        "peekOfCode": "def drop_right(array, number=1):\n    \"\"\"Creates a slice of array with n elements dropped from the end.\n    Arguments:\n        array {list} -- The array to query.\n    Keyword Arguments:\n        number {int} -- The number of elements to drop. (default: {1})\n    Returns:\n        (list) -- Returns the slice of array.\n    \"\"\"\n    if helper.is_number(number) is True and len(array) < number:",
        "detail": "custard.lodash.arrays",
        "documentation": {}
    },
    {
        "label": "fill",
        "kind": 2,
        "importPath": "custard.lodash.arrays",
        "description": "custard.lodash.arrays",
        "peekOfCode": "def fill(array, value, start=0, end=None):\n    \"\"\"Fills elements of array with value from start up to, but not including, end.\n    Arguments:\n        array {list} -- The array to fill.\n        value {*} -- The value to fill array with.\n    Keyword Arguments:\n        start {int} -- The start position. (default: {0})\n        end {*} -- The end position. (default: {None})\n    Returns:\n        (list) -- Returns array",
        "detail": "custard.lodash.arrays",
        "documentation": {}
    },
    {
        "label": "index_of",
        "kind": 2,
        "importPath": "custard.lodash.arrays",
        "description": "custard.lodash.arrays",
        "peekOfCode": "def index_of(array, value=None, fromIndex=0):\n    \"\"\"Gets the index at which the first occurrence of value is found in array using SameValueZero for equality comparisons. If fromIndex is negative, it's used as the offset from the end of array.\n    Arguments:\n        array {list} -- The array to inspect\n    Keyword Arguments:\n        value {*} -- The value to search for (default: {None})\n        fromIndex {int} -- The index to search from (default: {0})\n    Returns:\n        (number) -- Returns the index of the matched value, else -1.\n    \"\"\"",
        "detail": "custard.lodash.arrays",
        "documentation": {}
    },
    {
        "label": "initial",
        "kind": 2,
        "importPath": "custard.lodash.arrays",
        "description": "custard.lodash.arrays",
        "peekOfCode": "def initial(array):\n    \"\"\"Gets all but the last element of array\n    Arguments:\n        array {list} -- The array to query\n    Returns:\n        (list) -- Returns the slice of array\n    \"\"\"\n    return [item for index, item in enumerate(array) if index != len(array) - 1] if isinstance(\n        array, list) else []\ndef pull(array, *args):",
        "detail": "custard.lodash.arrays",
        "documentation": {}
    },
    {
        "label": "pull",
        "kind": 2,
        "importPath": "custard.lodash.arrays",
        "description": "custard.lodash.arrays",
        "peekOfCode": "def pull(array, *args):\n    \"\"\"Removes all given values from array using SameValueZero for equality comparisons\n    Arguments:\n        array {list} -- The array to modify\n        [values](...*): -- The values to remove\n    Returns:\n        (list) -- Returns array\n    \"\"\"\n    return [i for i in array if i not in args]",
        "detail": "custard.lodash.arrays",
        "documentation": {}
    },
    {
        "label": "add",
        "kind": 2,
        "importPath": "custard.lodash.maths",
        "description": "custard.lodash.maths",
        "peekOfCode": "def add(augend, addend):\n    \"\"\"Adds two numbers\n    Arguments:\n        augend {number} -- The first number in an addition\n        addend {number} -- The second number in an addition\n    Returns:\n        (number) -- Returns the total\n    \"\"\"\n    return augend + addend if helpers.is_number(augend) and helpers.is_number(addend) else str(\n        augend) + str(addend)",
        "detail": "custard.lodash.maths",
        "documentation": {}
    },
    {
        "label": "ceil",
        "kind": 2,
        "importPath": "custard.lodash.maths",
        "description": "custard.lodash.maths",
        "peekOfCode": "def ceil(number, precision=0):\n    \"\"\"Computes number rounded up to precision\n    Arguments:\n        number {number} -- The number to round up\n    Keyword Arguments:\n        precision {int} -- The precision to round up to (default: {0})\n    Returns:\n        (number) -- Returns the rounded up number\n    \"\"\"\n    return call_math_operator(number, precision, math.ceil)",
        "detail": "custard.lodash.maths",
        "documentation": {}
    },
    {
        "label": "divide",
        "kind": 2,
        "importPath": "custard.lodash.maths",
        "description": "custard.lodash.maths",
        "peekOfCode": "def divide(dividend, divisor):\n    \"\"\"Divide two numbers\n    Arguments:\n        dividend {number]} -- The first number in a division\n        divisor {[number} -- The second number in a division\n    Returns:\n        (number) -- Returns the quotient\n    \"\"\"\n    try:\n        return dividend / divisor",
        "detail": "custard.lodash.maths",
        "documentation": {}
    },
    {
        "label": "call_math_operator",
        "kind": 2,
        "importPath": "custard.lodash.maths",
        "description": "custard.lodash.maths",
        "peekOfCode": "def call_math_operator(number, precision=0, op=None):\n    \"\"\"Computes numbers ceil or floor base on operator\n    Arguments:\n        number {number} -- The number to round\n    Keyword Arguments:\n        precision {int} -- The precision to round (default: {0})\n        op {*} -- The operator to round (default: {None})\n    Returns:\n        (number) -- Returns the rounded number\n    \"\"\"",
        "detail": "custard.lodash.maths",
        "documentation": {}
    },
    {
        "label": "floor",
        "kind": 2,
        "importPath": "custard.lodash.maths",
        "description": "custard.lodash.maths",
        "peekOfCode": "def floor(number, precision=0):\n    \"\"\"Computes number rounded down to precision.\n    Arguments:\n        number {number} -- The number to round down\n    Keyword Arguments:\n        precision {number} -- The precision to round down to (default: {0})\n    Returns:\n        (number) -- Returns the rounded down number.\n    \"\"\"\n    return call_math_operator(number, precision, math.floor)",
        "detail": "custard.lodash.maths",
        "documentation": {}
    },
    {
        "label": "max",
        "kind": 2,
        "importPath": "custard.lodash.maths",
        "description": "custard.lodash.maths",
        "peekOfCode": "def max(array):\n    \"\"\"Computes the maximum value of array. If array is empty or falsey, undefined is returned\n    Arguments:\n        array {list} -- The array to iterate over\n    Returns:\n        (*) -- Returns the maximum value\n    \"\"\"\n    if len(array) == 0:\n        return None\n    max = 0",
        "detail": "custard.lodash.maths",
        "documentation": {}
    },
    {
        "label": "mean",
        "kind": 2,
        "importPath": "custard.lodash.maths",
        "description": "custard.lodash.maths",
        "peekOfCode": "def mean(array):\n    \"\"\"Computes the mean of the values in array\n    Arguments:\n        array {list} -- The array to iterate over\n    Returns:\n        (number) -- Returns the mean\n    \"\"\"\n    try:\n        return sum(array) / len(array)\n    except ZeroDivisionError as detail:",
        "detail": "custard.lodash.maths",
        "documentation": {}
    },
    {
        "label": "min",
        "kind": 2,
        "importPath": "custard.lodash.maths",
        "description": "custard.lodash.maths",
        "peekOfCode": "def min(array):\n    \"\"\"Computes the minimum value of array. If array is empty or falsey, undefined is returned\n    Arguments:\n        array {list} -- The array to iterate over\n    Returns:\n        (*) -- Returns the minimum value\n    \"\"\"\n    if len(array) == 0:\n        return None\n    min = array[0]",
        "detail": "custard.lodash.maths",
        "documentation": {}
    },
    {
        "label": "multiply",
        "kind": 2,
        "importPath": "custard.lodash.maths",
        "description": "custard.lodash.maths",
        "peekOfCode": "def multiply(multiplier, multiplicand):\n    \"\"\"Multiply two numbers\n    Arguments:\n        multiplier {number} --  The first number in a multiplication.\n        multiplicand {number} -- The second number in a multiplication\n    Returns:\n        (number) -- Returns the product\n    \"\"\"\n    return multiplier * multiplicand\ndef substract(minuend, subtrahend):",
        "detail": "custard.lodash.maths",
        "documentation": {}
    },
    {
        "label": "substract",
        "kind": 2,
        "importPath": "custard.lodash.maths",
        "description": "custard.lodash.maths",
        "peekOfCode": "def substract(minuend, subtrahend):\n    \"\"\"Subtract two numbers\n    Arguments:\n        minuend {number} -- The first number in a subtraction\n        subtrahend {number} -- The second number in a subtraction\n    Returns:\n        (number) -- Returns the difference\n    \"\"\"\n    return minuend - subtrahend\ndef sum(array):",
        "detail": "custard.lodash.maths",
        "documentation": {}
    },
    {
        "label": "sum",
        "kind": 2,
        "importPath": "custard.lodash.maths",
        "description": "custard.lodash.maths",
        "peekOfCode": "def sum(array):\n    \"\"\"Computes the sum of the values in array\n    Arguments:\n        array {list} -- The array to iterate over\n    Returns:\n        (number) -- Returns the sum\n    \"\"\"\n    result = 0\n    for i in array:\n        result += i",
        "detail": "custard.lodash.maths",
        "documentation": {}
    },
    {
        "label": "clamp",
        "kind": 2,
        "importPath": "custard.lodash.number",
        "description": "custard.lodash.number",
        "peekOfCode": "def clamp(number, lower, upper):\n    \"\"\"Clamps number within the inclusive lower and upper bounds\n    Arguments:\n        number {number]} -- The number to clamp\n        lower {[number} -- The lower bound\n        upper {[number} -- The upper bound\n    Returns:\n        (number) -- Returns the clamped number\n    \"\"\"\n    if is_clamp(number, lower, upper):",
        "detail": "custard.lodash.number",
        "documentation": {}
    },
    {
        "label": "is_clamp",
        "kind": 2,
        "importPath": "custard.lodash.number",
        "description": "custard.lodash.number",
        "peekOfCode": "def is_clamp(number, lower, upper):\n    \"\"\"Check clamp number within the inclusive lower and upper bounds\n    Arguments:\n        number {number} -- The number to clamp\n        lower {number} -- The lower bound\n        upper {number} -- The upper bound\n    Returns:\n        (bool) -- Returns number is clamp or not\n    \"\"\"\n    return is_between(lower, number, upper) or is_between(upper, number, lower)",
        "detail": "custard.lodash.number",
        "documentation": {}
    },
    {
        "label": "is_between",
        "kind": 2,
        "importPath": "custard.lodash.number",
        "description": "custard.lodash.number",
        "peekOfCode": "def is_between(a, b, c):\n    \"\"\"Check a number is between two other numbers\n    Arguments:\n        a {number} -- The first number\n        b {number} -- The second number\n        c {number} -- The third number\n    Returns:\n        (bool) -- Return True if number is between else False\n    \"\"\"\n    return a <= b <= c",
        "detail": "custard.lodash.number",
        "documentation": {}
    },
    {
        "label": "in_range",
        "kind": 2,
        "importPath": "custard.lodash.number",
        "description": "custard.lodash.number",
        "peekOfCode": "def in_range(number, start, end=None):\n    \"\"\"Checks if n is between start and up to, but not including, end. If end is not specified, it's set to start with start then set to 0. If start is greater than end the params are swapped to support negative ranges.\n    Arguments:\n        number {number} -- The number to check\n        start {number} -- The start of the range\n    Keyword Arguments:\n        end {*} -- The end of the range. (default: {None})\n    Returns:\n        (boolean) -- Returns True if number is in the range, else False\n    \"\"\"",
        "detail": "custard.lodash.number",
        "documentation": {}
    },
    {
        "label": "basein_range",
        "kind": 2,
        "importPath": "custard.lodash.number",
        "description": "custard.lodash.number",
        "peekOfCode": "def basein_range(number, start, end):\n    \"\"\"Check number is between range\n    Arguments:\n        number {number} -- The number to check\n        start {number} -- The number start of range\n        end {number} -- The number end of range\n    Returns:\n        (boolean) -- Returns True if number is between of range\n    \"\"\"\n    return min(start, end) <= number < max(start, end)",
        "detail": "custard.lodash.number",
        "documentation": {}
    },
    {
        "label": "random",
        "kind": 2,
        "importPath": "custard.lodash.number",
        "description": "custard.lodash.number",
        "peekOfCode": "def random(lower=0, upper=1, floating=False):\n    \"\"\"Produces a random number between the inclusive lower and upper bounds. If only one argument is provided a number between 0 and the given number is returned. If floating is true, or either lower or upper are floats, a floating-point number is returned instead of an integer.\n    Keyword Arguments:\n        lower {int} -- The lower bound (default: {0})\n        upper {int} -- The upper bound (default: {1})\n        floating {bool} -- Specify returning a floating-point number (default: {False})\n    Returns:\n        (number) -- Returns the random number\n    \"\"\"\n    floating = (isinstance(lower, float) or",
        "detail": "custard.lodash.number",
        "documentation": {}
    },
    {
        "label": "camel_case",
        "kind": 2,
        "importPath": "custard.lodash.string",
        "description": "custard.lodash.string",
        "peekOfCode": "def camel_case(string=''):\n    \"\"\"Converts string to camel case\n    Keyword Arguments:\n        string {str} -- The string to convert (default: {''})\n    Returns:\n        (string) -- Returns the camel cased string\n    \"\"\"\n    items = replace_special_characters(string)\n    # format first letter for word\n    result = [item.lower() if index == 0 else item[0].upper() + item[1:].lower() for index, item in",
        "detail": "custard.lodash.string",
        "documentation": {}
    },
    {
        "label": "replace_special_characters",
        "kind": 2,
        "importPath": "custard.lodash.string",
        "description": "custard.lodash.string",
        "peekOfCode": "def replace_special_characters(string=''):\n    \"\"\"Replace all special characters of string\n    Keyword Arguments:\n        string {str} -- The string to replacement (default: {''})\n    Returns:\n        (list) -- Returns a list string\n    \"\"\"\n    # remove all special characters base on pattern\n    items = re.split('[-_*)( %^$#@!]', str(string))\n    # remove all elements is empty, None, False",
        "detail": "custard.lodash.string",
        "documentation": {}
    },
    {
        "label": "capitalize",
        "kind": 2,
        "importPath": "custard.lodash.string",
        "description": "custard.lodash.string",
        "peekOfCode": "def capitalize(string=''):\n    \"\"\"Converts the first character of string to upper case and the remaining to lower case\n    Keyword Arguments:\n        string {str} -- The string to capitalize (default: {''})\n    Returns:\n        (string) -- Returns the capitalized string\n    \"\"\"\n    format_string = str(string)\n    return format_string[0].upper() + format_string[1:].lower()\ndef ends_with(string='', target=None, position=None):",
        "detail": "custard.lodash.string",
        "documentation": {}
    },
    {
        "label": "ends_with",
        "kind": 2,
        "importPath": "custard.lodash.string",
        "description": "custard.lodash.string",
        "peekOfCode": "def ends_with(string='', target=None, position=None):\n    \"\"\"Checks if string ends with the given target string\n    Keyword Arguments:\n        string {str} -- The string to inspect (default: {''})\n        target {[type]} -- The string to search for (default: {None})\n        position {[type]} -- The position to search up to (default: {None})\n    Returns:\n        (boolean) -- Returns true if string ends with target, else false\n    \"\"\"\n    format_string = str(string)",
        "detail": "custard.lodash.string",
        "documentation": {}
    },
    {
        "label": "string_replace",
        "kind": 2,
        "importPath": "custard.lodash.string",
        "description": "custard.lodash.string",
        "peekOfCode": "def string_replace(string, old_character, new_character):\n    \"\"\"Replace string with new characters\n    Arguments:\n        string {string} -- The string to replace\n        old_character {string} -- Old character need to replace\n        new_character {string} -- New character to replace\n    Returns:\n        (string) -- Returns the string with new character\n    \"\"\"\n    if old_character in str(string):",
        "detail": "custard.lodash.string",
        "documentation": {}
    },
    {
        "label": "escape",
        "kind": 2,
        "importPath": "custard.lodash.string",
        "description": "custard.lodash.string",
        "peekOfCode": "def escape(string=''):\n    \"\"\"Converts the characters \"&\", \"<\", \">\", '\"', and \"'\" in string to their corresponding HTML entities\n    Keyword Arguments:\n        string {str} -- The string to escape (default: {''})\n    Returns:\n        (string) -- Returns the escaped string\n    \"\"\"\n    characters = {\n        '&': '&amp;',\n        '>': '&gt;',",
        "detail": "custard.lodash.string",
        "documentation": {}
    },
    {
        "label": "lower_case",
        "kind": 2,
        "importPath": "custard.lodash.string",
        "description": "custard.lodash.string",
        "peekOfCode": "def lower_case(string=''):\n    \"\"\"Converts string, as space separated words, to lower case\n    Keyword Arguments:\n        string {str} -- The string to convert (default: {''})\n    Returns:\n        string -- Returns the lower cased string\n    \"\"\"\n    items = replace_special_characters(string)\n    result = [i.lower() for i in items]\n    return ' '.join(result)",
        "detail": "custard.lodash.string",
        "documentation": {}
    },
    {
        "label": "lower_first",
        "kind": 2,
        "importPath": "custard.lodash.string",
        "description": "custard.lodash.string",
        "peekOfCode": "def lower_first(string=''):\n    \"\"\"Converts the first character of string to lower case\n    Keyword Arguments:\n        string {str} -- The string to convert (default: {''})\n    Returns:\n        (string) -- Returns the converted string\n    \"\"\"\n    format_string = str(string)\n    return format_string[0].lower() + format_string[1:]\ndef pad_characters(chars, position):",
        "detail": "custard.lodash.string",
        "documentation": {}
    },
    {
        "label": "pad_characters",
        "kind": 2,
        "importPath": "custard.lodash.string",
        "description": "custard.lodash.string",
        "peekOfCode": "def pad_characters(chars, position):\n    \"\"\"Split string with position\n    Arguments:\n        chars {string} -- The string to split\n        position {number} -- Position of string to split\n    Returns:\n        (string) -- Returns substring\n    \"\"\"\n    return (chars * position)[0:position]\ndef pad(string='', length=0, chars=' '):",
        "detail": "custard.lodash.string",
        "documentation": {}
    },
    {
        "label": "pad",
        "kind": 2,
        "importPath": "custard.lodash.string",
        "description": "custard.lodash.string",
        "peekOfCode": "def pad(string='', length=0, chars=' '):\n    \"\"\"Pads string on the left and right sides if it's shorter than length. Padding characters are truncated if they can't be evenly divided by length.\n    Keyword Arguments:\n        string {str} -- The string to pad (default: {''})\n        length {int} -- The padding length (default: {0})\n        chars {str} -- The string used as padding (default: {' '})\n    Returns:\n        (string) -- Returns the padded string\n    \"\"\"\n    format_string = str(string)",
        "detail": "custard.lodash.string",
        "documentation": {}
    },
    {
        "label": "pad_end",
        "kind": 2,
        "importPath": "custard.lodash.string",
        "description": "custard.lodash.string",
        "peekOfCode": "def pad_end(string='', length=0, chars=' '):\n    \"\"\"Pads string on the right side if it's shorter than length. Padding characters are truncated if they exceed length\n    Keyword Arguments:\n        string {str} -- The string to pad (default: {''})\n        length {int} -- The padding length (default: {0})\n        chars {str} -- The string used as padding (default: {' '})\n    Returns:\n        (string) -- Returns the padded string\n    \"\"\"\n    format_string = str(string)",
        "detail": "custard.lodash.string",
        "documentation": {}
    },
    {
        "label": "pad_start",
        "kind": 2,
        "importPath": "custard.lodash.string",
        "description": "custard.lodash.string",
        "peekOfCode": "def pad_start(string='', length=0, chars=' '):\n    \"\"\"Pads string on the left side if it's shorter than length. Padding characters are truncated if they exceed length\n    Keyword Arguments:\n        string {str} -- The string to pad (default: {''})\n        length {int} -- The padding length (default: {0})\n        chars {str} -- The string used as padding (default: {' '})\n    Returns:\n        (string) -- Returns the padded string\n    \"\"\"\n    format_string = str(string)",
        "detail": "custard.lodash.string",
        "documentation": {}
    },
    {
        "label": "repeat",
        "kind": 2,
        "importPath": "custard.lodash.string",
        "description": "custard.lodash.string",
        "peekOfCode": "def repeat(string='', n=1):\n    \"\"\"Repeats the given string n times\n    Keyword Arguments:\n        string {str} -- The string to repeat (default: {''})\n        n {int} -- The number of times to repeat the string (default: {1})\n    Returns:\n        (string) -- Returns the repeated string\n    \"\"\"\n    return str(string) * n\ndef replace(string, pattern, replacement):",
        "detail": "custard.lodash.string",
        "documentation": {}
    },
    {
        "label": "replace",
        "kind": 2,
        "importPath": "custard.lodash.string",
        "description": "custard.lodash.string",
        "peekOfCode": "def replace(string, pattern, replacement):\n    \"\"\"Replaces matches for pattern in string with replacement\n    Arguments:\n        string {string} -- The string to modify\n        pattern {RegExp|string} -- The pattern to replace\n        replacement {Function|string)} -- The match replacement\n    Returns:\n        (string) -- Returns the modified string\n    \"\"\"\n    return str(string).replace(pattern, replacement)",
        "detail": "custard.lodash.string",
        "documentation": {}
    },
    {
        "label": "starts_with",
        "kind": 2,
        "importPath": "custard.lodash.string",
        "description": "custard.lodash.string",
        "peekOfCode": "def starts_with(string, target, position=0):\n    \"\"\"Checks if string starts with the given target string\n    Arguments:\n        string {[type]} -- The string to inspect\n        target {[type]} -- The string to search for\n    Keyword Arguments:\n        position {int} -- The position to search from (default: {0})\n    Returns:\n        (boolean) -- Returns true if string starts with target, else false\n    \"\"\"",
        "detail": "custard.lodash.string",
        "documentation": {}
    },
    {
        "label": "is_number",
        "kind": 2,
        "importPath": "custard.lodash.utilities",
        "description": "custard.lodash.utilities",
        "peekOfCode": "def is_number(s):\n    \"\"\"Check input is number or not\n    Arguments:\n        s {*} -- The input to check\n    Returns:\n        (boolean)] -- Returns True if input a number else False\n    \"\"\"\n    try:\n        int(s)\n        return True",
        "detail": "custard.lodash.utilities",
        "documentation": {}
    },
    {
        "label": "MiniOssTypeEnum",
        "kind": 6,
        "importPath": "custard.minioss.enums",
        "description": "custard.minioss.enums",
        "peekOfCode": "class MiniOssTypeEnum:\n    ALIYUN = \"aliyun\"\n    GITEE = \"gitee\"\n    QINIU = \"qiniu\"",
        "detail": "custard.minioss.enums",
        "documentation": {}
    },
    {
        "label": "MiniRacerBaseException",
        "kind": 6,
        "importPath": "custard.mock.mini_racer",
        "description": "custard.mock.mini_racer",
        "peekOfCode": "class MiniRacerBaseException(Exception):\n    \"\"\"Base MiniRacer exception.\"\"\"\nclass JSParseException(MiniRacerBaseException):\n    \"\"\"JavaScript could not be parsed.\"\"\"\nclass JSEvalException(MiniRacerBaseException):\n    \"\"\"JavaScript could not be executed.\"\"\"\nclass JSOOMException(JSEvalException):\n    \"\"\"JavaScript execution ran out of memory.\"\"\"\nclass JSTimeoutException(JSEvalException):\n    \"\"\"JavaScript execution timed out.\"\"\"",
        "detail": "custard.mock.mini_racer",
        "documentation": {}
    },
    {
        "label": "JSParseException",
        "kind": 6,
        "importPath": "custard.mock.mini_racer",
        "description": "custard.mock.mini_racer",
        "peekOfCode": "class JSParseException(MiniRacerBaseException):\n    \"\"\"JavaScript could not be parsed.\"\"\"\nclass JSEvalException(MiniRacerBaseException):\n    \"\"\"JavaScript could not be executed.\"\"\"\nclass JSOOMException(JSEvalException):\n    \"\"\"JavaScript execution ran out of memory.\"\"\"\nclass JSTimeoutException(JSEvalException):\n    \"\"\"JavaScript execution timed out.\"\"\"\nclass JSConversionException(MiniRacerBaseException):\n    \"\"\"JavaScript type could not be converted.\"\"\"",
        "detail": "custard.mock.mini_racer",
        "documentation": {}
    },
    {
        "label": "JSEvalException",
        "kind": 6,
        "importPath": "custard.mock.mini_racer",
        "description": "custard.mock.mini_racer",
        "peekOfCode": "class JSEvalException(MiniRacerBaseException):\n    \"\"\"JavaScript could not be executed.\"\"\"\nclass JSOOMException(JSEvalException):\n    \"\"\"JavaScript execution ran out of memory.\"\"\"\nclass JSTimeoutException(JSEvalException):\n    \"\"\"JavaScript execution timed out.\"\"\"\nclass JSConversionException(MiniRacerBaseException):\n    \"\"\"JavaScript type could not be converted.\"\"\"\nclass WrongReturnTypeException(MiniRacerBaseException):\n    \"\"\"Invalid type returned by the JavaScript runtime.\"\"\"",
        "detail": "custard.mock.mini_racer",
        "documentation": {}
    },
    {
        "label": "JSOOMException",
        "kind": 6,
        "importPath": "custard.mock.mini_racer",
        "description": "custard.mock.mini_racer",
        "peekOfCode": "class JSOOMException(JSEvalException):\n    \"\"\"JavaScript execution ran out of memory.\"\"\"\nclass JSTimeoutException(JSEvalException):\n    \"\"\"JavaScript execution timed out.\"\"\"\nclass JSConversionException(MiniRacerBaseException):\n    \"\"\"JavaScript type could not be converted.\"\"\"\nclass WrongReturnTypeException(MiniRacerBaseException):\n    \"\"\"Invalid type returned by the JavaScript runtime.\"\"\"\nclass JSObject(object):\n    \"\"\"JavaScript object.\"\"\"",
        "detail": "custard.mock.mini_racer",
        "documentation": {}
    },
    {
        "label": "JSTimeoutException",
        "kind": 6,
        "importPath": "custard.mock.mini_racer",
        "description": "custard.mock.mini_racer",
        "peekOfCode": "class JSTimeoutException(JSEvalException):\n    \"\"\"JavaScript execution timed out.\"\"\"\nclass JSConversionException(MiniRacerBaseException):\n    \"\"\"JavaScript type could not be converted.\"\"\"\nclass WrongReturnTypeException(MiniRacerBaseException):\n    \"\"\"Invalid type returned by the JavaScript runtime.\"\"\"\nclass JSObject(object):\n    \"\"\"JavaScript object.\"\"\"\n    def __init__(self, id):\n        self.id = id",
        "detail": "custard.mock.mini_racer",
        "documentation": {}
    },
    {
        "label": "JSConversionException",
        "kind": 6,
        "importPath": "custard.mock.mini_racer",
        "description": "custard.mock.mini_racer",
        "peekOfCode": "class JSConversionException(MiniRacerBaseException):\n    \"\"\"JavaScript type could not be converted.\"\"\"\nclass WrongReturnTypeException(MiniRacerBaseException):\n    \"\"\"Invalid type returned by the JavaScript runtime.\"\"\"\nclass JSObject(object):\n    \"\"\"JavaScript object.\"\"\"\n    def __init__(self, id):\n        self.id = id\n    def __hash__(self):\n        return self.id",
        "detail": "custard.mock.mini_racer",
        "documentation": {}
    },
    {
        "label": "WrongReturnTypeException",
        "kind": 6,
        "importPath": "custard.mock.mini_racer",
        "description": "custard.mock.mini_racer",
        "peekOfCode": "class WrongReturnTypeException(MiniRacerBaseException):\n    \"\"\"Invalid type returned by the JavaScript runtime.\"\"\"\nclass JSObject(object):\n    \"\"\"JavaScript object.\"\"\"\n    def __init__(self, id):\n        self.id = id\n    def __hash__(self):\n        return self.id\nclass JSFunction(object):\n    \"\"\"JavaScript function.\"\"\"",
        "detail": "custard.mock.mini_racer",
        "documentation": {}
    },
    {
        "label": "JSObject",
        "kind": 6,
        "importPath": "custard.mock.mini_racer",
        "description": "custard.mock.mini_racer",
        "peekOfCode": "class JSObject(object):\n    \"\"\"JavaScript object.\"\"\"\n    def __init__(self, id):\n        self.id = id\n    def __hash__(self):\n        return self.id\nclass JSFunction(object):\n    \"\"\"JavaScript function.\"\"\"\nclass JSSymbol(object):\n    \"\"\"JavaScript symbol.\"\"\"",
        "detail": "custard.mock.mini_racer",
        "documentation": {}
    },
    {
        "label": "JSFunction",
        "kind": 6,
        "importPath": "custard.mock.mini_racer",
        "description": "custard.mock.mini_racer",
        "peekOfCode": "class JSFunction(object):\n    \"\"\"JavaScript function.\"\"\"\nclass JSSymbol(object):\n    \"\"\"JavaScript symbol.\"\"\"\ndef is_unicode(value):\n    \"\"\"Check if a value is a valid unicode string.\n    >>> is_unicode(u'foo')\n    True\n    >>> is_unicode(u'✌')\n    True",
        "detail": "custard.mock.mini_racer",
        "documentation": {}
    },
    {
        "label": "JSSymbol",
        "kind": 6,
        "importPath": "custard.mock.mini_racer",
        "description": "custard.mock.mini_racer",
        "peekOfCode": "class JSSymbol(object):\n    \"\"\"JavaScript symbol.\"\"\"\ndef is_unicode(value):\n    \"\"\"Check if a value is a valid unicode string.\n    >>> is_unicode(u'foo')\n    True\n    >>> is_unicode(u'✌')\n    True\n    >>> is_unicode(b'foo')\n    False",
        "detail": "custard.mock.mini_racer",
        "documentation": {}
    },
    {
        "label": "MiniRacer",
        "kind": 6,
        "importPath": "custard.mock.mini_racer",
        "description": "custard.mock.mini_racer",
        "peekOfCode": "class MiniRacer(object):\n    \"\"\"\n    MiniRacer evaluates JavaScript code using a V8 isolate.\n    :cvar json_impl: JSON module used by helper methods default is :py:mod:`json`\n    :cvar v8_flags: Flags used for V8 initialization\n    :vartype v8_flags: class attribute list of str\n    \"\"\"\n    json_impl = json\n    v8_flags = [\"--single-threaded\"]\n    ext = None",
        "detail": "custard.mock.mini_racer",
        "documentation": {}
    },
    {
        "label": "MiniRacerTypes",
        "kind": 6,
        "importPath": "custard.mock.mini_racer",
        "description": "custard.mock.mini_racer",
        "peekOfCode": "class MiniRacerTypes(object):\n    \"\"\"MiniRacer types identifier\n    Note: it needs to be coherent with mini_racer_extension.cc.\n    \"\"\"\n    invalid = 0\n    null = 1\n    bool = 2\n    integer = 3\n    double = 4\n    str_utf8 = 5",
        "detail": "custard.mock.mini_racer",
        "documentation": {}
    },
    {
        "label": "MiniRacerValueStruct",
        "kind": 6,
        "importPath": "custard.mock.mini_racer",
        "description": "custard.mock.mini_racer",
        "peekOfCode": "class MiniRacerValueStruct(ctypes.Structure):\n    _fields_ = [(\"value\", ctypes.c_void_p),  # value is 8 bytes, works only for 64bit systems\n                (\"type\", ctypes.c_int),\n                (\"len\", ctypes.c_size_t)]\nclass ArrayBufferByte(ctypes.Structure):\n    # Cannot use c_ubyte directly because it uses <B\n    # as an internal type but we need B for memoryview.\n    _fields_ = [(\"b\", ctypes.c_ubyte)]\n    _pack_ = 1\nclass MiniRacerValue(object):",
        "detail": "custard.mock.mini_racer",
        "documentation": {}
    },
    {
        "label": "ArrayBufferByte",
        "kind": 6,
        "importPath": "custard.mock.mini_racer",
        "description": "custard.mock.mini_racer",
        "peekOfCode": "class ArrayBufferByte(ctypes.Structure):\n    # Cannot use c_ubyte directly because it uses <B\n    # as an internal type but we need B for memoryview.\n    _fields_ = [(\"b\", ctypes.c_ubyte)]\n    _pack_ = 1\nclass MiniRacerValue(object):\n    def __init__(self, ctx, ptr):\n        self.ctx = ctx\n        self.ptr = ptr\n    def __str__(self):",
        "detail": "custard.mock.mini_racer",
        "documentation": {}
    },
    {
        "label": "MiniRacerValue",
        "kind": 6,
        "importPath": "custard.mock.mini_racer",
        "description": "custard.mock.mini_racer",
        "peekOfCode": "class MiniRacerValue(object):\n    def __init__(self, ctx, ptr):\n        self.ctx = ctx\n        self.ptr = ptr\n    def __str__(self):\n        return str(self.to_python())\n    @property\n    def type(self):\n        return self.ptr.contents.type\n    @property",
        "detail": "custard.mock.mini_racer",
        "documentation": {}
    },
    {
        "label": "is_unicode",
        "kind": 2,
        "importPath": "custard.mock.mini_racer",
        "description": "custard.mock.mini_racer",
        "peekOfCode": "def is_unicode(value):\n    \"\"\"Check if a value is a valid unicode string.\n    >>> is_unicode(u'foo')\n    True\n    >>> is_unicode(u'✌')\n    True\n    >>> is_unicode(b'foo')\n    False\n    >>> is_unicode(42)\n    False",
        "detail": "custard.mock.mini_racer",
        "documentation": {}
    },
    {
        "label": "EXTENSION_PATH",
        "kind": 5,
        "importPath": "custard.mock.mini_racer",
        "description": "custard.mock.mini_racer",
        "peekOfCode": "EXTENSION_PATH = _get_lib_path(\"mini_racer\")\nEXTENSION_NAME = os.path.basename(EXTENSION_PATH) if EXTENSION_PATH is not None else None\nif sys.version_info[0] < 3:\n    UNICODE_TYPE = unicode  # noqa: F821\nelse:\n    from typing import Any, Optional\n    UNICODE_TYPE = str\nclass MiniRacerBaseException(Exception):\n    \"\"\"Base MiniRacer exception.\"\"\"\nclass JSParseException(MiniRacerBaseException):",
        "detail": "custard.mock.mini_racer",
        "documentation": {}
    },
    {
        "label": "EXTENSION_NAME",
        "kind": 5,
        "importPath": "custard.mock.mini_racer",
        "description": "custard.mock.mini_racer",
        "peekOfCode": "EXTENSION_NAME = os.path.basename(EXTENSION_PATH) if EXTENSION_PATH is not None else None\nif sys.version_info[0] < 3:\n    UNICODE_TYPE = unicode  # noqa: F821\nelse:\n    from typing import Any, Optional\n    UNICODE_TYPE = str\nclass MiniRacerBaseException(Exception):\n    \"\"\"Base MiniRacer exception.\"\"\"\nclass JSParseException(MiniRacerBaseException):\n    \"\"\"JavaScript could not be parsed.\"\"\"",
        "detail": "custard.mock.mini_racer",
        "documentation": {}
    },
    {
        "label": "StrictMiniRacer",
        "kind": 5,
        "importPath": "custard.mock.mini_racer",
        "description": "custard.mock.mini_racer",
        "peekOfCode": "StrictMiniRacer = MiniRacer\nclass MiniRacerTypes(object):\n    \"\"\"MiniRacer types identifier\n    Note: it needs to be coherent with mini_racer_extension.cc.\n    \"\"\"\n    invalid = 0\n    null = 1\n    bool = 2\n    integer = 3\n    double = 4",
        "detail": "custard.mock.mini_racer",
        "documentation": {}
    },
    {
        "label": "ReqBodyTypeEnum",
        "kind": 6,
        "importPath": "custard.network.enums",
        "description": "custard.network.enums",
        "peekOfCode": "class ReqBodyTypeEnum(IntEnum):\n    none = 0\n    json = 1\n    form = 2\n    x_form = 3\n    binary = 4\n    graphQL = 5",
        "detail": "custard.network.enums",
        "documentation": {}
    },
    {
        "label": "Request",
        "kind": 6,
        "importPath": "custard.network.httpclient",
        "description": "custard.network.httpclient",
        "peekOfCode": "class Request(object):\n    def __init__(self, url, session=False, **kwargs):\n        self.url = url\n        self.session = session\n        self.kwargs = kwargs\n        if self.session:\n            self.client = requests.session()\n            return\n        self.client = requests\n    def get(self):",
        "detail": "custard.network.httpclient",
        "documentation": {}
    },
    {
        "label": "resolve_params",
        "kind": 2,
        "importPath": "custard.pagination.api",
        "description": "custard.pagination.api",
        "peekOfCode": "def resolve_params(params: Optional[AbstractParams] = None) -> AbstractParams:\n    if params is None:\n        try:\n            return params_value.get()\n        except LookupError:\n            raise RuntimeError(\"Use params or add_pagination\")\n    return params\ndef create_page(items: Sequence[T], total: int, params: AbstractParams) -> AbstractPage[T]:\n    return page_type.get().create(items, total, params)\ndef response() -> Response:",
        "detail": "custard.pagination.api",
        "documentation": {}
    },
    {
        "label": "create_page",
        "kind": 2,
        "importPath": "custard.pagination.api",
        "description": "custard.pagination.api",
        "peekOfCode": "def create_page(items: Sequence[T], total: int, params: AbstractParams) -> AbstractPage[T]:\n    return page_type.get().create(items, total, params)\ndef response() -> Response:\n    try:\n        return response_value.get()\n    except LookupError:\n        raise RuntimeError(\"response context var must be set\")\ndef request() -> Request:\n    try:\n        return request_value.get()",
        "detail": "custard.pagination.api",
        "documentation": {}
    },
    {
        "label": "response",
        "kind": 2,
        "importPath": "custard.pagination.api",
        "description": "custard.pagination.api",
        "peekOfCode": "def response() -> Response:\n    try:\n        return response_value.get()\n    except LookupError:\n        raise RuntimeError(\"response context var must be set\")\ndef request() -> Request:\n    try:\n        return request_value.get()\n    except LookupError:\n        raise RuntimeError(\"request context var must be set\")",
        "detail": "custard.pagination.api",
        "documentation": {}
    },
    {
        "label": "request",
        "kind": 2,
        "importPath": "custard.pagination.api",
        "description": "custard.pagination.api",
        "peekOfCode": "def request() -> Request:\n    try:\n        return request_value.get()\n    except LookupError:\n        raise RuntimeError(\"request context var must be set\")\ndef _ctx_var_with_reset(var: ContextVar, value: Any) -> ContextManager[None]:\n    token = var.set(value)\n    @contextmanager\n    def _reset_ctx() -> Iterator[None]:\n        yield",
        "detail": "custard.pagination.api",
        "documentation": {}
    },
    {
        "label": "set_page",
        "kind": 2,
        "importPath": "custard.pagination.api",
        "description": "custard.pagination.api",
        "peekOfCode": "def set_page(page: Type[AbstractPage]) -> ContextManager[None]:\n    return _ctx_var_with_reset(page_type, page)\ndef _create_page_dependency(page: Type[AbstractPage]) -> Callable[[], AsyncIterator[None]]:\n    async def _set_page_type() -> AsyncIterator[None]:\n        with set_page(page):\n            yield\n    return _set_page_type\ndef _create_params_dependency(\n        params: Type[TAbstractParams],\n) -> Callable[[TAbstractParams], AsyncIterator[TAbstractParams]]:",
        "detail": "custard.pagination.api",
        "documentation": {}
    },
    {
        "label": "add_pagination",
        "kind": 2,
        "importPath": "custard.pagination.api",
        "description": "custard.pagination.api",
        "peekOfCode": "def add_pagination(parent: ParentT) -> ParentT:\n    for route in parent.routes:\n        if isinstance(route, APIRoute):\n            _update_route(route)\n    return parent\n__all__ = [\n    \"add_pagination\",\n    \"create_page\",\n    \"resolve_params\",\n    \"response\",",
        "detail": "custard.pagination.api",
        "documentation": {}
    },
    {
        "label": "T",
        "kind": 5,
        "importPath": "custard.pagination.api",
        "description": "custard.pagination.api",
        "peekOfCode": "T = TypeVar(\"T\")\nTAbstractParams = TypeVar(\"TAbstractParams\", covariant=True, bound=AbstractParams)\nparams_value: ContextVar[AbstractParams] = ContextVar(\"params_value\")\npage_type: ContextVar[Type[AbstractPage]] = ContextVar(\"page_type\", default=Page)\nresponse_value: ContextVar[Response] = ContextVar(\"response_value\")\nrequest_value: ContextVar[Request] = ContextVar(\"request_value\")\ndef resolve_params(params: Optional[AbstractParams] = None) -> AbstractParams:\n    if params is None:\n        try:\n            return params_value.get()",
        "detail": "custard.pagination.api",
        "documentation": {}
    },
    {
        "label": "TAbstractParams",
        "kind": 5,
        "importPath": "custard.pagination.api",
        "description": "custard.pagination.api",
        "peekOfCode": "TAbstractParams = TypeVar(\"TAbstractParams\", covariant=True, bound=AbstractParams)\nparams_value: ContextVar[AbstractParams] = ContextVar(\"params_value\")\npage_type: ContextVar[Type[AbstractPage]] = ContextVar(\"page_type\", default=Page)\nresponse_value: ContextVar[Response] = ContextVar(\"response_value\")\nrequest_value: ContextVar[Request] = ContextVar(\"request_value\")\ndef resolve_params(params: Optional[AbstractParams] = None) -> AbstractParams:\n    if params is None:\n        try:\n            return params_value.get()\n        except LookupError:",
        "detail": "custard.pagination.api",
        "documentation": {}
    },
    {
        "label": "ParentT",
        "kind": 5,
        "importPath": "custard.pagination.api",
        "description": "custard.pagination.api",
        "peekOfCode": "ParentT = TypeVar(\"ParentT\", APIRouter, FastAPI)\ndef _update_route(route: APIRoute) -> None:\n    if any(d.call is _marker for d in route.dependant.dependencies):\n        return\n    if not lenient_issubclass(route.response_model, AbstractPage):\n        return\n    cls = cast(Type[AbstractPage], route.response_model)\n    dependencies = [\n        Depends(_marker),\n        Depends(_set_request_response),",
        "detail": "custard.pagination.api",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "custard.pagination.api",
        "description": "custard.pagination.api",
        "peekOfCode": "__all__ = [\n    \"add_pagination\",\n    \"create_page\",\n    \"resolve_params\",\n    \"response\",\n    \"request\",\n    \"set_page\",\n]",
        "detail": "custard.pagination.api",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "custard.pagination.async_sqlalchemy",
        "description": "custard.pagination.async_sqlalchemy",
        "peekOfCode": "__all__ = [\"paginate\"]",
        "detail": "custard.pagination.async_sqlalchemy",
        "documentation": {}
    },
    {
        "label": "RawParams",
        "kind": 6,
        "importPath": "custard.pagination.bases",
        "description": "custard.pagination.bases",
        "peekOfCode": "class RawParams:\n    limit: int\n    offset: int\nclass AbstractParams(ABC):\n    @abstractmethod\n    def to_raw_params(self) -> RawParams:\n        pass\ndef _create_params(cls: Type[AbstractParams], fields: Dict[str, Any]) -> Mapping[str, Any]:\n    if not issubclass(cls, BaseModel):\n        raise ValueError(f\"{cls.__name__} must be subclass of BaseModel\")",
        "detail": "custard.pagination.bases",
        "documentation": {}
    },
    {
        "label": "AbstractParams",
        "kind": 6,
        "importPath": "custard.pagination.bases",
        "description": "custard.pagination.bases",
        "peekOfCode": "class AbstractParams(ABC):\n    @abstractmethod\n    def to_raw_params(self) -> RawParams:\n        pass\ndef _create_params(cls: Type[AbstractParams], fields: Dict[str, Any]) -> Mapping[str, Any]:\n    if not issubclass(cls, BaseModel):\n        raise ValueError(f\"{cls.__name__} must be subclass of BaseModel\")\n    incorrect = sorted(fields.keys() - cls.__fields__.keys())\n    if incorrect:\n        ending = \"s\" if len(incorrect) > 1 else \"\"",
        "detail": "custard.pagination.bases",
        "documentation": {}
    },
    {
        "label": "AbstractPage",
        "kind": 6,
        "importPath": "custard.pagination.bases",
        "description": "custard.pagination.bases",
        "peekOfCode": "class AbstractPage(GenericModel, Generic[T], ABC):\n    __params_type__: ClassVar[Type[AbstractParams]]\n    @classmethod\n    @abstractmethod\n    def create(cls: Type[C], items: Sequence[T], total: int, params: AbstractParams) -> C:\n        pass\n    @classmethod\n    def with_custom_options(cls: Type[TAbstractPage], **kwargs: Any) -> Type[TAbstractPage]:\n        params_cls = cast(Type[AbstractPage], cls).__params_type__\n        custom_params: Any = create_model(",
        "detail": "custard.pagination.bases",
        "documentation": {}
    },
    {
        "label": "BasePage",
        "kind": 6,
        "importPath": "custard.pagination.bases",
        "description": "custard.pagination.bases",
        "peekOfCode": "class BasePage(AbstractPage[T], Generic[T], ABC):\n    items: Sequence[T]\n    total: conint(ge=0)  # type: ignore\n__all__ = [\n    \"AbstractPage\",\n    \"AbstractParams\",\n    \"BasePage\",\n    \"RawParams\",\n]",
        "detail": "custard.pagination.bases",
        "documentation": {}
    },
    {
        "label": "T",
        "kind": 5,
        "importPath": "custard.pagination.bases",
        "description": "custard.pagination.bases",
        "peekOfCode": "T = TypeVar(\"T\")\nC = TypeVar(\"C\")\nTAbstractPage = TypeVar(\"TAbstractPage\", bound=\"AbstractPage\")\n@dataclass\nclass RawParams:\n    limit: int\n    offset: int\nclass AbstractParams(ABC):\n    @abstractmethod\n    def to_raw_params(self) -> RawParams:",
        "detail": "custard.pagination.bases",
        "documentation": {}
    },
    {
        "label": "C",
        "kind": 5,
        "importPath": "custard.pagination.bases",
        "description": "custard.pagination.bases",
        "peekOfCode": "C = TypeVar(\"C\")\nTAbstractPage = TypeVar(\"TAbstractPage\", bound=\"AbstractPage\")\n@dataclass\nclass RawParams:\n    limit: int\n    offset: int\nclass AbstractParams(ABC):\n    @abstractmethod\n    def to_raw_params(self) -> RawParams:\n        pass",
        "detail": "custard.pagination.bases",
        "documentation": {}
    },
    {
        "label": "TAbstractPage",
        "kind": 5,
        "importPath": "custard.pagination.bases",
        "description": "custard.pagination.bases",
        "peekOfCode": "TAbstractPage = TypeVar(\"TAbstractPage\", bound=\"AbstractPage\")\n@dataclass\nclass RawParams:\n    limit: int\n    offset: int\nclass AbstractParams(ABC):\n    @abstractmethod\n    def to_raw_params(self) -> RawParams:\n        pass\ndef _create_params(cls: Type[AbstractParams], fields: Dict[str, Any]) -> Mapping[str, Any]:",
        "detail": "custard.pagination.bases",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "custard.pagination.bases",
        "description": "custard.pagination.bases",
        "peekOfCode": "__all__ = [\n    \"AbstractPage\",\n    \"AbstractParams\",\n    \"BasePage\",\n    \"RawParams\",\n]",
        "detail": "custard.pagination.bases",
        "documentation": {}
    },
    {
        "label": "Params",
        "kind": 6,
        "importPath": "custard.pagination.default",
        "description": "custard.pagination.default",
        "peekOfCode": "class Params(BaseModel, AbstractParams):\n    page: int = Query(1, ge=1, description=\"Page number\")\n    size: int = Query(50, ge=1, le=100, description=\"Page size\")\n    def to_raw_params(self) -> RawParams:\n        return RawParams(\n            limit=self.size,\n            offset=self.size * (self.page - 1),\n        )\nclass Page(BasePage[T], Generic[T]):\n    page: conint(ge=1)  # type: ignore",
        "detail": "custard.pagination.default",
        "documentation": {}
    },
    {
        "label": "Page",
        "kind": 6,
        "importPath": "custard.pagination.default",
        "description": "custard.pagination.default",
        "peekOfCode": "class Page(BasePage[T], Generic[T]):\n    page: conint(ge=1)  # type: ignore\n    size: conint(ge=1)  # type: ignore\n    __params_type__ = Params\n    @classmethod\n    def create(\n            cls,\n            items: Sequence[T],\n            total: int,\n            params: AbstractParams,",
        "detail": "custard.pagination.default",
        "documentation": {}
    },
    {
        "label": "T",
        "kind": 5,
        "importPath": "custard.pagination.default",
        "description": "custard.pagination.default",
        "peekOfCode": "T = TypeVar(\"T\")\nclass Params(BaseModel, AbstractParams):\n    page: int = Query(1, ge=1, description=\"Page number\")\n    size: int = Query(50, ge=1, le=100, description=\"Page size\")\n    def to_raw_params(self) -> RawParams:\n        return RawParams(\n            limit=self.size,\n            offset=self.size * (self.page - 1),\n        )\nclass Page(BasePage[T], Generic[T]):",
        "detail": "custard.pagination.default",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "custard.pagination.default",
        "description": "custard.pagination.default",
        "peekOfCode": "__all__ = [\n    \"Params\",\n    \"Page\",\n]",
        "detail": "custard.pagination.default",
        "documentation": {}
    },
    {
        "label": "Page",
        "kind": 6,
        "importPath": "custard.pagination.iterables",
        "description": "custard.pagination.iterables",
        "peekOfCode": "class Page(DefaultPage, Generic[T]):\n    total: Optional[conint(ge=0)]  # type: ignore\nclass LimitOffsetPage(DefaultLimitOffsetPage, Generic[T]):\n    total: Optional[conint(ge=0)]  # type: ignore\ndef paginate(\n        iterable: Iterable[T],\n        params: Optional[AbstractParams] = None,\n        total: Optional[int] = None,\n) -> AbstractPage[T]:\n    params = resolve_params(params)",
        "detail": "custard.pagination.iterables",
        "documentation": {}
    },
    {
        "label": "LimitOffsetPage",
        "kind": 6,
        "importPath": "custard.pagination.iterables",
        "description": "custard.pagination.iterables",
        "peekOfCode": "class LimitOffsetPage(DefaultLimitOffsetPage, Generic[T]):\n    total: Optional[conint(ge=0)]  # type: ignore\ndef paginate(\n        iterable: Iterable[T],\n        params: Optional[AbstractParams] = None,\n        total: Optional[int] = None,\n) -> AbstractPage[T]:\n    params = resolve_params(params)\n    raw_params = params.to_raw_params()\n    items = [*islice(iterable, raw_params.offset, raw_params.offset + raw_params.limit)]",
        "detail": "custard.pagination.iterables",
        "documentation": {}
    },
    {
        "label": "paginate",
        "kind": 2,
        "importPath": "custard.pagination.iterables",
        "description": "custard.pagination.iterables",
        "peekOfCode": "def paginate(\n        iterable: Iterable[T],\n        params: Optional[AbstractParams] = None,\n        total: Optional[int] = None,\n) -> AbstractPage[T]:\n    params = resolve_params(params)\n    raw_params = params.to_raw_params()\n    items = [*islice(iterable, raw_params.offset, raw_params.offset + raw_params.limit)]\n    return create_page(items, total, params)  # type: ignore\n__all__ = [",
        "detail": "custard.pagination.iterables",
        "documentation": {}
    },
    {
        "label": "T",
        "kind": 5,
        "importPath": "custard.pagination.iterables",
        "description": "custard.pagination.iterables",
        "peekOfCode": "T = TypeVar(\"T\")\nclass Page(DefaultPage, Generic[T]):\n    total: Optional[conint(ge=0)]  # type: ignore\nclass LimitOffsetPage(DefaultLimitOffsetPage, Generic[T]):\n    total: Optional[conint(ge=0)]  # type: ignore\ndef paginate(\n        iterable: Iterable[T],\n        params: Optional[AbstractParams] = None,\n        total: Optional[int] = None,\n) -> AbstractPage[T]:",
        "detail": "custard.pagination.iterables",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "custard.pagination.iterables",
        "description": "custard.pagination.iterables",
        "peekOfCode": "__all__ = [\n    \"Page\",\n    \"Params\",\n    \"LimitOffsetPage\",\n    \"LimitOffsetParams\",\n    \"paginate\",\n]",
        "detail": "custard.pagination.iterables",
        "documentation": {}
    },
    {
        "label": "LimitOffsetParams",
        "kind": 6,
        "importPath": "custard.pagination.limit_offset",
        "description": "custard.pagination.limit_offset",
        "peekOfCode": "class LimitOffsetParams(BaseModel, AbstractParams):\n    limit: int = Query(50, ge=1, le=100, description=\"Page size limit\")\n    offset: int = Query(0, ge=0, description=\"Page offset\")\n    def to_raw_params(self) -> RawParams:\n        return RawParams(\n            limit=self.limit,\n            offset=self.offset,\n        )\nclass LimitOffsetPage(BasePage[T], Generic[T]):\n    limit: conint(ge=1)  # type: ignore",
        "detail": "custard.pagination.limit_offset",
        "documentation": {}
    },
    {
        "label": "LimitOffsetPage",
        "kind": 6,
        "importPath": "custard.pagination.limit_offset",
        "description": "custard.pagination.limit_offset",
        "peekOfCode": "class LimitOffsetPage(BasePage[T], Generic[T]):\n    limit: conint(ge=1)  # type: ignore\n    offset: conint(ge=0)  # type: ignore\n    __params_type__ = LimitOffsetParams\n    @classmethod\n    def create(\n            cls,\n            items: Sequence[T],\n            total: int,\n            params: AbstractParams,",
        "detail": "custard.pagination.limit_offset",
        "documentation": {}
    },
    {
        "label": "T",
        "kind": 5,
        "importPath": "custard.pagination.limit_offset",
        "description": "custard.pagination.limit_offset",
        "peekOfCode": "T = TypeVar(\"T\")\nclass LimitOffsetParams(BaseModel, AbstractParams):\n    limit: int = Query(50, ge=1, le=100, description=\"Page size limit\")\n    offset: int = Query(0, ge=0, description=\"Page offset\")\n    def to_raw_params(self) -> RawParams:\n        return RawParams(\n            limit=self.limit,\n            offset=self.offset,\n        )\nclass LimitOffsetPage(BasePage[T], Generic[T]):",
        "detail": "custard.pagination.limit_offset",
        "documentation": {}
    },
    {
        "label": "Page",
        "kind": 5,
        "importPath": "custard.pagination.limit_offset",
        "description": "custard.pagination.limit_offset",
        "peekOfCode": "Page = LimitOffsetPage\nParams = LimitOffsetParams\n__all__ = [\n    \"Page\",\n    \"Params\",\n    \"LimitOffsetPage\",\n    \"LimitOffsetParams\",\n]",
        "detail": "custard.pagination.limit_offset",
        "documentation": {}
    },
    {
        "label": "Params",
        "kind": 5,
        "importPath": "custard.pagination.limit_offset",
        "description": "custard.pagination.limit_offset",
        "peekOfCode": "Params = LimitOffsetParams\n__all__ = [\n    \"Page\",\n    \"Params\",\n    \"LimitOffsetPage\",\n    \"LimitOffsetParams\",\n]",
        "detail": "custard.pagination.limit_offset",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "custard.pagination.limit_offset",
        "description": "custard.pagination.limit_offset",
        "peekOfCode": "__all__ = [\n    \"Page\",\n    \"Params\",\n    \"LimitOffsetPage\",\n    \"LimitOffsetParams\",\n]",
        "detail": "custard.pagination.limit_offset",
        "documentation": {}
    },
    {
        "label": "Params",
        "kind": 6,
        "importPath": "custard.pagination.pagination",
        "description": "custard.pagination.pagination",
        "peekOfCode": "class Params(BaseModel, AbstractParams):\n    page: int = Query(1, ge=1, description=\"Page number\")\n    size: int = Query(20, gt=0, le=100, description=\"Page size\")\n    def to_raw_params(self) -> RawParams:\n        return RawParams(\n            limit=self.size,\n            offset=self.size * (self.page - 1),\n        )\nclass Page(AbstractPage[T], Generic[T]):\n    results: Sequence[T]",
        "detail": "custard.pagination.pagination",
        "documentation": {}
    },
    {
        "label": "Page",
        "kind": 6,
        "importPath": "custard.pagination.pagination",
        "description": "custard.pagination.pagination",
        "peekOfCode": "class Page(AbstractPage[T], Generic[T]):\n    results: Sequence[T]\n    total: int\n    page: int\n    size: int\n    next: str\n    previous: str\n    total_pages: int\n    __params_type__ = Params  # Set params related to Page\n    @classmethod",
        "detail": "custard.pagination.pagination",
        "documentation": {}
    },
    {
        "label": "T",
        "kind": 5,
        "importPath": "custard.pagination.pagination",
        "description": "custard.pagination.pagination",
        "peekOfCode": "T = TypeVar(\"T\")\nclass Params(BaseModel, AbstractParams):\n    page: int = Query(1, ge=1, description=\"Page number\")\n    size: int = Query(20, gt=0, le=100, description=\"Page size\")\n    def to_raw_params(self) -> RawParams:\n        return RawParams(\n            limit=self.size,\n            offset=self.size * (self.page - 1),\n        )\nclass Page(AbstractPage[T], Generic[T]):",
        "detail": "custard.pagination.pagination",
        "documentation": {}
    },
    {
        "label": "paginate",
        "kind": 2,
        "importPath": "custard.pagination.paginator",
        "description": "custard.pagination.paginator",
        "peekOfCode": "def paginate(\n        sequence: Sequence[T],\n        params: Optional[AbstractParams] = None,\n        length_function: Callable[[Sequence[T]], int] = len,\n) -> AbstractPage[T]:\n    params = resolve_params(params)\n    raw_params = params.to_raw_params()\n    return create_page(\n        items=sequence[raw_params.offset: raw_params.offset + raw_params.limit],\n        total=length_function(sequence),",
        "detail": "custard.pagination.paginator",
        "documentation": {}
    },
    {
        "label": "T",
        "kind": 5,
        "importPath": "custard.pagination.paginator",
        "description": "custard.pagination.paginator",
        "peekOfCode": "T = TypeVar(\"T\")\ndef paginate(\n        sequence: Sequence[T],\n        params: Optional[AbstractParams] = None,\n        length_function: Callable[[Sequence[T]], int] = len,\n) -> AbstractPage[T]:\n    params = resolve_params(params)\n    raw_params = params.to_raw_params()\n    return create_page(\n        items=sequence[raw_params.offset: raw_params.offset + raw_params.limit],",
        "detail": "custard.pagination.paginator",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "custard.pagination.paginator",
        "description": "custard.pagination.paginator",
        "peekOfCode": "__all__ = [\"paginate\"]",
        "detail": "custard.pagination.paginator",
        "documentation": {}
    },
    {
        "label": "paginate_query",
        "kind": 2,
        "importPath": "custard.pagination.sync_sqlalchemy",
        "description": "custard.pagination.sync_sqlalchemy",
        "peekOfCode": "def paginate_query(query: T, params: AbstractParams) -> T:\n    raw_params = params.to_raw_params()\n    return query.limit(raw_params.limit).offset(raw_params.offset)\ndef _to_dict(obj: Any) -> Any:\n    try:\n        return obj._asdict()\n    except AttributeError:\n        return obj\ndef paginate(query: Query, params: Optional[AbstractParams] = None) -> AbstractPage:\n    params = resolve_params(params)",
        "detail": "custard.pagination.sync_sqlalchemy",
        "documentation": {}
    },
    {
        "label": "paginate",
        "kind": 2,
        "importPath": "custard.pagination.sync_sqlalchemy",
        "description": "custard.pagination.sync_sqlalchemy",
        "peekOfCode": "def paginate(query: Query, params: Optional[AbstractParams] = None) -> AbstractPage:\n    params = resolve_params(params)\n    total = query.count()\n    items = [_to_dict(item) for item in paginate_query(query, params)]\n    return create_page(items, total, params)\n__all__ = [\"paginate_query\", \"paginate\"]",
        "detail": "custard.pagination.sync_sqlalchemy",
        "documentation": {}
    },
    {
        "label": "T",
        "kind": 5,
        "importPath": "custard.pagination.sync_sqlalchemy",
        "description": "custard.pagination.sync_sqlalchemy",
        "peekOfCode": "T = TypeVar(\"T\", Select, Query)\ndef paginate_query(query: T, params: AbstractParams) -> T:\n    raw_params = params.to_raw_params()\n    return query.limit(raw_params.limit).offset(raw_params.offset)\ndef _to_dict(obj: Any) -> Any:\n    try:\n        return obj._asdict()\n    except AttributeError:\n        return obj\ndef paginate(query: Query, params: Optional[AbstractParams] = None) -> AbstractPage:",
        "detail": "custard.pagination.sync_sqlalchemy",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "custard.pagination.sync_sqlalchemy",
        "description": "custard.pagination.sync_sqlalchemy",
        "peekOfCode": "__all__ = [\"paginate_query\", \"paginate\"]",
        "detail": "custard.pagination.sync_sqlalchemy",
        "documentation": {}
    },
    {
        "label": "_ver",
        "kind": 5,
        "importPath": "custard.script.compat",
        "description": "custard.script.compat",
        "peekOfCode": "_ver = sys.version_info\n#: Python 2.x?\nis_py2 = (_ver[0] == 2)\n#: Python 3.x?\nis_py3 = (_ver[0] == 3)\n# ---------\n# Specifics\n# ---------\ntry:\n    JSONDecodeError = json.JSONDecodeError",
        "detail": "custard.script.compat",
        "documentation": {}
    },
    {
        "label": "is_py2",
        "kind": 5,
        "importPath": "custard.script.compat",
        "description": "custard.script.compat",
        "peekOfCode": "is_py2 = (_ver[0] == 2)\n#: Python 3.x?\nis_py3 = (_ver[0] == 3)\n# ---------\n# Specifics\n# ---------\ntry:\n    JSONDecodeError = json.JSONDecodeError\nexcept AttributeError:\n    JSONDecodeError = ValueError",
        "detail": "custard.script.compat",
        "documentation": {}
    },
    {
        "label": "is_py3",
        "kind": 5,
        "importPath": "custard.script.compat",
        "description": "custard.script.compat",
        "peekOfCode": "is_py3 = (_ver[0] == 3)\n# ---------\n# Specifics\n# ---------\ntry:\n    JSONDecodeError = json.JSONDecodeError\nexcept AttributeError:\n    JSONDecodeError = ValueError\nif is_py2:\n    builtin_str = str",
        "detail": "custard.script.compat",
        "documentation": {}
    },
    {
        "label": "parse_string_value",
        "kind": 2,
        "importPath": "custard.script.parser",
        "description": "custard.script.parser",
        "peekOfCode": "def parse_string_value(str_value):\n    \"\"\" parse string to number if possible\n    e.g. \"123\" => 123\n         \"12.2\" => 12.3\n         \"abc\" => \"abc\"\n         \"$var\" => \"$var\"\n    \"\"\"\n    try:\n        return ast.literal_eval(str_value)\n    except ValueError:",
        "detail": "custard.script.parser",
        "documentation": {}
    },
    {
        "label": "extract_variables",
        "kind": 2,
        "importPath": "custard.script.parser",
        "description": "custard.script.parser",
        "peekOfCode": "def extract_variables(content):\n    \"\"\" extract all variable names from content, which is in format $variable\n    Args:\n        content (str): string content\n    Returns:\n        list: variables list extracted from string content\n    Examples:\n        >>> extract_variables(\"$variable\")\n        >>> extract_variables(\"/blog/$postid\")\n        >>> extract_variables(\"/$var1/$var2\")",
        "detail": "custard.script.parser",
        "documentation": {}
    },
    {
        "label": "extract_functions",
        "kind": 2,
        "importPath": "custard.script.parser",
        "description": "custard.script.parser",
        "peekOfCode": "def extract_functions(content):\n    \"\"\" extract all functions from string content, which are in format ${fun()}\n    Args:\n        content (str): string content\n    Returns:\n        list: functions list extracted from string content\n    Examples:\n        >>> extract_functions(\"${func(5)}\")\n        >>> extract_functions(\"${func(a=1, b=2)}\")\n        >>> extract_functions(\"/api/1000?_t=${get_timestamp()}\")",
        "detail": "custard.script.parser",
        "documentation": {}
    },
    {
        "label": "parse_function",
        "kind": 2,
        "importPath": "custard.script.parser",
        "description": "custard.script.parser",
        "peekOfCode": "def parse_function(content):\n    \"\"\" parse function name and args from string content.\n    Args:\n        content (str): string content\n    Returns:\n        dict: function meta dict\n            {\n                \"func_name\": \"xxx\",\n                \"args\": [],\n                \"kwargs\": {}",
        "detail": "custard.script.parser",
        "documentation": {}
    },
    {
        "label": "parse_validator",
        "kind": 2,
        "importPath": "custard.script.parser",
        "description": "custard.script.parser",
        "peekOfCode": "def parse_validator(validator):\n    \"\"\"\n    Args:\n        validator:\n            format1: this is kept for compatiblity with the previous versions.\n                {\"check\": \"status_code\", \"comparator\": \"eq\", \"expect\": 201}\n                {\"check\": \"$resp_body_success\", \"comparator\": \"eq\", \"expect\": True}\n            format2: recommended new version\n                {'eq': ['status_code', 201]}\n                {'eq': ['$resp_body_success', True]}",
        "detail": "custard.script.parser",
        "documentation": {}
    },
    {
        "label": "substitute_variables",
        "kind": 2,
        "importPath": "custard.script.parser",
        "description": "custard.script.parser",
        "peekOfCode": "def substitute_variables(content, variables_mapping):\n    \"\"\" substitute variables in content with variables_mapping\n    Args:\n        content (str/dict/list/numeric/bool/type): content to be substituted.\n        variables_mapping (dict): variables mapping.\n    Returns:\n        substituted content.\n    Examples:\n        >>> content = { 'request': { 'url': '/api/users/$uid', 'headers': {'token': '$token'} } }\n        >>> variables_mapping = {\"$uid\": 1000}",
        "detail": "custard.script.parser",
        "documentation": {}
    },
    {
        "label": "get_builtin_item",
        "kind": 2,
        "importPath": "custard.script.parser",
        "description": "custard.script.parser",
        "peekOfCode": "def get_builtin_item(item_type, item_name):\n    \"\"\"\n    Args:\n        item_type (enum): \"variables\" or \"functions\"\n        item_name (str): variable name or function name\n    Returns:\n        variable or function with the name of item_name\n    \"\"\"\n    # override built_in module with debugtalk.py module\n    from httprunner import loader",
        "detail": "custard.script.parser",
        "documentation": {}
    },
    {
        "label": "get_mapping_variable",
        "kind": 2,
        "importPath": "custard.script.parser",
        "description": "custard.script.parser",
        "peekOfCode": "def get_mapping_variable(variable_name, variables_mapping):\n    \"\"\" get variable from variables_mapping.\n    Args:\n        variable_name (str): variable name\n        variables_mapping (dict): variables mapping\n    Returns:\n        mapping variable value.\n    Raises:\n        exceptions.VariableNotFound: variable is not found.\n    \"\"\"",
        "detail": "custard.script.parser",
        "documentation": {}
    },
    {
        "label": "get_mapping_function",
        "kind": 2,
        "importPath": "custard.script.parser",
        "description": "custard.script.parser",
        "peekOfCode": "def get_mapping_function(function_name, functions_mapping):\n    \"\"\" get function from functions_mapping,\n        if not found, then try to check if builtin function.\n    Args:\n        function_name (str):\n        functions_mapping (dict):\n    Returns:\n        mapping function object.\n    Raises:\n        exceptions.FunctionNotFound: function is neither defined in debugtalk.py nor builtin.",
        "detail": "custard.script.parser",
        "documentation": {}
    },
    {
        "label": "parse_function_params",
        "kind": 2,
        "importPath": "custard.script.parser",
        "description": "custard.script.parser",
        "peekOfCode": "def parse_function_params(params) -> dict:\n    \"\"\" parse function params to args and kwargs.\n    Args:\n        params (str): function param in string\n    Returns:\n        dict: function meta dict\n            {\n                \"args\": [],\n                \"kwargs\": {}\n            }",
        "detail": "custard.script.parser",
        "documentation": {}
    },
    {
        "label": "parse_string",
        "kind": 2,
        "importPath": "custard.script.parser",
        "description": "custard.script.parser",
        "peekOfCode": "def parse_string(\n        raw_string,\n        variables_mapping,\n        functions_mapping,\n):\n    \"\"\" parse string content with variables and functions mapping.\n    Args:\n        raw_string: raw string content to be parsed.\n        variables_mapping: variables mapping.\n        functions_mapping: functions mapping.",
        "detail": "custard.script.parser",
        "documentation": {}
    },
    {
        "label": "parse_data",
        "kind": 2,
        "importPath": "custard.script.parser",
        "description": "custard.script.parser",
        "peekOfCode": "def parse_data(content, variables_mapping=None, functions_mapping=None):\n    \"\"\" parse content with variables mapping\n    Args:\n        content (str/dict/list/numeric/bool/type): content to be parsed\n        variables_mapping (dict): variables mapping.\n        functions_mapping (dict): functions mapping.\n    Returns:\n        parsed content.\n    Examples:\n        >>> content = {'request': { 'url': '/api/users/$uid', 'headers': {'token': '$token'}  } }",
        "detail": "custard.script.parser",
        "documentation": {}
    },
    {
        "label": "variable_regexp",
        "kind": 5,
        "importPath": "custard.script.parser",
        "description": "custard.script.parser",
        "peekOfCode": "variable_regexp = r\"\\$([\\w_]+)\"\nfunction_regexp = r\"\\$\\{([\\w_]+\\([\\$\\w\\.\\-/_ =,]*\\))\\}\"\nfunction_regexp_compile = re.compile(r\"^([\\w_]+)\\(([\\$\\w\\.\\-/_ =,]*)\\)$\")\n# use $$ to escape $ notation\ndolloar_regex_compile = re.compile(r\"\\$\\$\")\n# variable notation, e.g. ${var} or $var\nvariable_regex_compile = re.compile(r\"\\$\\{(\\w+)\\}|\\$(\\w+)\")\n# function notation, e.g. ${func1($var_1, $var_3)}\nfunction_regex_compile = re.compile(r\"\\$\\{(\\w+)\\(([\\$\\w\\.\\-/\\s=,]*)\\)\\}\")\ndef parse_string_value(str_value):",
        "detail": "custard.script.parser",
        "documentation": {}
    },
    {
        "label": "function_regexp",
        "kind": 5,
        "importPath": "custard.script.parser",
        "description": "custard.script.parser",
        "peekOfCode": "function_regexp = r\"\\$\\{([\\w_]+\\([\\$\\w\\.\\-/_ =,]*\\))\\}\"\nfunction_regexp_compile = re.compile(r\"^([\\w_]+)\\(([\\$\\w\\.\\-/_ =,]*)\\)$\")\n# use $$ to escape $ notation\ndolloar_regex_compile = re.compile(r\"\\$\\$\")\n# variable notation, e.g. ${var} or $var\nvariable_regex_compile = re.compile(r\"\\$\\{(\\w+)\\}|\\$(\\w+)\")\n# function notation, e.g. ${func1($var_1, $var_3)}\nfunction_regex_compile = re.compile(r\"\\$\\{(\\w+)\\(([\\$\\w\\.\\-/\\s=,]*)\\)\\}\")\ndef parse_string_value(str_value):\n    \"\"\" parse string to number if possible",
        "detail": "custard.script.parser",
        "documentation": {}
    },
    {
        "label": "function_regexp_compile",
        "kind": 5,
        "importPath": "custard.script.parser",
        "description": "custard.script.parser",
        "peekOfCode": "function_regexp_compile = re.compile(r\"^([\\w_]+)\\(([\\$\\w\\.\\-/_ =,]*)\\)$\")\n# use $$ to escape $ notation\ndolloar_regex_compile = re.compile(r\"\\$\\$\")\n# variable notation, e.g. ${var} or $var\nvariable_regex_compile = re.compile(r\"\\$\\{(\\w+)\\}|\\$(\\w+)\")\n# function notation, e.g. ${func1($var_1, $var_3)}\nfunction_regex_compile = re.compile(r\"\\$\\{(\\w+)\\(([\\$\\w\\.\\-/\\s=,]*)\\)\\}\")\ndef parse_string_value(str_value):\n    \"\"\" parse string to number if possible\n    e.g. \"123\" => 123",
        "detail": "custard.script.parser",
        "documentation": {}
    },
    {
        "label": "dolloar_regex_compile",
        "kind": 5,
        "importPath": "custard.script.parser",
        "description": "custard.script.parser",
        "peekOfCode": "dolloar_regex_compile = re.compile(r\"\\$\\$\")\n# variable notation, e.g. ${var} or $var\nvariable_regex_compile = re.compile(r\"\\$\\{(\\w+)\\}|\\$(\\w+)\")\n# function notation, e.g. ${func1($var_1, $var_3)}\nfunction_regex_compile = re.compile(r\"\\$\\{(\\w+)\\(([\\$\\w\\.\\-/\\s=,]*)\\)\\}\")\ndef parse_string_value(str_value):\n    \"\"\" parse string to number if possible\n    e.g. \"123\" => 123\n         \"12.2\" => 12.3\n         \"abc\" => \"abc\"",
        "detail": "custard.script.parser",
        "documentation": {}
    },
    {
        "label": "variable_regex_compile",
        "kind": 5,
        "importPath": "custard.script.parser",
        "description": "custard.script.parser",
        "peekOfCode": "variable_regex_compile = re.compile(r\"\\$\\{(\\w+)\\}|\\$(\\w+)\")\n# function notation, e.g. ${func1($var_1, $var_3)}\nfunction_regex_compile = re.compile(r\"\\$\\{(\\w+)\\(([\\$\\w\\.\\-/\\s=,]*)\\)\\}\")\ndef parse_string_value(str_value):\n    \"\"\" parse string to number if possible\n    e.g. \"123\" => 123\n         \"12.2\" => 12.3\n         \"abc\" => \"abc\"\n         \"$var\" => \"$var\"\n    \"\"\"",
        "detail": "custard.script.parser",
        "documentation": {}
    },
    {
        "label": "function_regex_compile",
        "kind": 5,
        "importPath": "custard.script.parser",
        "description": "custard.script.parser",
        "peekOfCode": "function_regex_compile = re.compile(r\"\\$\\{(\\w+)\\(([\\$\\w\\.\\-/\\s=,]*)\\)\\}\")\ndef parse_string_value(str_value):\n    \"\"\" parse string to number if possible\n    e.g. \"123\" => 123\n         \"12.2\" => 12.3\n         \"abc\" => \"abc\"\n         \"$var\" => \"$var\"\n    \"\"\"\n    try:\n        return ast.literal_eval(str_value)",
        "detail": "custard.script.parser",
        "documentation": {}
    },
    {
        "label": "JsonToSchema",
        "kind": 6,
        "importPath": "custard.script.schema",
        "description": "custard.script.schema",
        "peekOfCode": "class JsonToSchema:\n    # 遍历列表\n    @classmethod\n    def get_object_data(cls, dict_data):\n        # 外层dict\n        schema_data = {}\n        # 遍历字典中的key\n        for dict_data_k in dict_data.keys():\n            # 如果value是字符串/数字/布尔值/小数/None,则直接存入schema_data\n            if type(dict_data[dict_data_k]) in (str, int, bool, float, list):",
        "detail": "custard.script.schema",
        "documentation": {}
    },
    {
        "label": "IncompleteModelError",
        "kind": 6,
        "importPath": "custard.swagger.exception",
        "description": "custard.swagger.exception",
        "peekOfCode": "class IncompleteModelError(BaseException):\n    pass\nclass ParseMethodError(Exception):\n    pass",
        "detail": "custard.swagger.exception",
        "documentation": {}
    },
    {
        "label": "ParseMethodError",
        "kind": 6,
        "importPath": "custard.swagger.exception",
        "description": "custard.swagger.exception",
        "peekOfCode": "class ParseMethodError(Exception):\n    pass",
        "detail": "custard.swagger.exception",
        "documentation": {}
    },
    {
        "label": "load_json",
        "kind": 2,
        "importPath": "custard.swagger.loader",
        "description": "custard.swagger.loader",
        "peekOfCode": "def load_json(json_str):\n    \"\"\"\n    加载json数据\n    Args:\n        json_str:\n    Returns:\n    \"\"\"\n    return json.loads(json_str)\ndef load_file(path):\n    \"\"\"",
        "detail": "custard.swagger.loader",
        "documentation": {}
    },
    {
        "label": "load_file",
        "kind": 2,
        "importPath": "custard.swagger.loader",
        "description": "custard.swagger.loader",
        "peekOfCode": "def load_file(path):\n    \"\"\"\n    加载json文件\n    Args:\n        path:\n    Returns:\n    \"\"\"\n    with open(path, encoding='utf8') as f:\n        return load_json(f.read())\ndef load_url(url, method='get', **kwargs):",
        "detail": "custard.swagger.loader",
        "documentation": {}
    },
    {
        "label": "load_url",
        "kind": 2,
        "importPath": "custard.swagger.loader",
        "description": "custard.swagger.loader",
        "peekOfCode": "def load_url(url, method='get', **kwargs):\n    \"\"\"\n    通过url加载json\n    Args:\n        url:\n        method:\n        **kwargs:\n    Returns:\n    \"\"\"\n    return requests.request(url=url, method=method, **kwargs).json()",
        "detail": "custard.swagger.loader",
        "documentation": {}
    },
    {
        "label": "Swagger2",
        "kind": 6,
        "importPath": "custard.swagger.swagger",
        "description": "custard.swagger.swagger",
        "peekOfCode": "class Swagger2:\n    def __init__(self, source, deep=5):\n        self.source = source\n        self.deep = deep\n        self.__scheme = self.schemes[0]\n        self.__host = self.source.get('host') or 'localhost'\n    def __property__(self, prop):\n        if isinstance(prop, dict):\n            _type = prop.get('type')\n            _format = prop.get('format')",
        "detail": "custard.swagger.swagger",
        "documentation": {}
    },
    {
        "label": "path_format",
        "kind": 2,
        "importPath": "custard.swagger.utils",
        "description": "custard.swagger.utils",
        "peekOfCode": "def path_format(url, params):\n    t = string.Template(re.subn(r'{(\\w+)}', r'${\\1}', url)[0])\n    return t.safe_substitute(params)\ndef form_format(data: dict, file:str):\n    _data = dict()\n    for k, v in data.items():\n        if v == file:\n            v = (k, open(file, mode='rb'))\n        else:\n            v = (None, v)",
        "detail": "custard.swagger.utils",
        "documentation": {}
    },
    {
        "label": "form_format",
        "kind": 2,
        "importPath": "custard.swagger.utils",
        "description": "custard.swagger.utils",
        "peekOfCode": "def form_format(data: dict, file:str):\n    _data = dict()\n    for k, v in data.items():\n        if v == file:\n            v = (k, open(file, mode='rb'))\n        else:\n            v = (None, v)\n        _data.update({k: v})\n    return _data",
        "detail": "custard.swagger.utils",
        "documentation": {}
    },
    {
        "label": "TimerContextManager",
        "kind": 6,
        "importPath": "custard.time.dafunc",
        "description": "custard.time.dafunc",
        "peekOfCode": "class TimerContextManager(object):\n    \"\"\"\n    用上下文管理器计时，可对代码片段计时\n    \"\"\"\n    def __init__(self, is_print_log=True, logger=None):\n        self._is_print_log = is_print_log\n        self.logger = logger\n        self.t_spend = None\n        self._line = None\n        self._file_name = None",
        "detail": "custard.time.dafunc",
        "documentation": {}
    },
    {
        "label": "func_timeout",
        "kind": 2,
        "importPath": "custard.time.dafunc",
        "description": "custard.time.dafunc",
        "peekOfCode": "def func_timeout(timeout, func, args=(), kwargs=None):\n    \"\"\"\n    Args:\n        timeout:\n        func:\n        args:\n        kwargs:\n    Returns:\n    \"\"\"\n    if not kwargs:",
        "detail": "custard.time.dafunc",
        "documentation": {}
    },
    {
        "label": "bind_timeout",
        "kind": 2,
        "importPath": "custard.time.dafunc",
        "description": "custard.time.dafunc",
        "peekOfCode": "def bind_timeout(timeout, allow_override=False):\n    \"\"\"\n    Args:\n        timeout:\n        allow_override:\n    Returns:\n    \"\"\"\n    default_timeout = copy.copy(timeout)\n    is_timeout_function = bool(issubclass(timeout.__class__, (\n        types.FunctionType, types.MethodType, types.LambdaType, types.BuiltinFunctionType, types.BuiltinMethodType)))",
        "detail": "custard.time.dafunc",
        "documentation": {}
    },
    {
        "label": "calc_time",
        "kind": 2,
        "importPath": "custard.time.dafunc",
        "description": "custard.time.dafunc",
        "peekOfCode": "def calc_time(logger: Any = None):\n    \"\"\"\n    统计给目标函数运行时间\n    Args:\n        logger:\n    Returns:\n    Examples:\n        >>> @calc_time(\"（自定义模块名）\")\n        ... def test_calc_time(num=100):\n        ...     return sum([x for x in range(num + 1)])",
        "detail": "custard.time.dafunc",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "custard.time.dafunc",
        "description": "custard.time.dafunc",
        "peekOfCode": "__all__ = ('func_timeout', 'bind_timeout', 'calc_time', 'FunctionTimedOut', 'TimerContextManager', 'StoppableThread')\ndef func_timeout(timeout, func, args=(), kwargs=None):\n    \"\"\"\n    Args:\n        timeout:\n        func:\n        args:\n        kwargs:\n    Returns:\n    \"\"\"",
        "detail": "custard.time.dafunc",
        "documentation": {}
    },
    {
        "label": "TimeOutError",
        "kind": 6,
        "importPath": "custard.time.exceptions",
        "description": "custard.time.exceptions",
        "peekOfCode": "class TimeOutError(Exception):\n    \"\"\"\n    An operation timed out\n    \"\"\"\n    pass\nclass FunctionTimedOut(BaseException):\n    def __init__(self, msg='', timed_out_after=None, timed_out_function=None,\n                 timed_out_args=None, timed_out_kwargs=None):\n        \"\"\"\n        Args:",
        "detail": "custard.time.exceptions",
        "documentation": {}
    },
    {
        "label": "FunctionTimedOut",
        "kind": 6,
        "importPath": "custard.time.exceptions",
        "description": "custard.time.exceptions",
        "peekOfCode": "class FunctionTimedOut(BaseException):\n    def __init__(self, msg='', timed_out_after=None, timed_out_function=None,\n                 timed_out_args=None, timed_out_kwargs=None):\n        \"\"\"\n        Args:\n            msg:\n            timed_out_after:\n            timed_out_function:\n            timed_out_args:\n            timed_out_kwargs:",
        "detail": "custard.time.exceptions",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "custard.time.exceptions",
        "description": "custard.time.exceptions",
        "peekOfCode": "__all__ = ('FunctionTimedOut', 'RETRY_SAME_TIMEOUT')\nRETRY_SAME_TIMEOUT = 'RETRY_SAME_TIMEOUT'\nclass TimeOutError(Exception):\n    \"\"\"\n    An operation timed out\n    \"\"\"\n    pass\nclass FunctionTimedOut(BaseException):\n    def __init__(self, msg='', timed_out_after=None, timed_out_function=None,\n                 timed_out_args=None, timed_out_kwargs=None):",
        "detail": "custard.time.exceptions",
        "documentation": {}
    },
    {
        "label": "RETRY_SAME_TIMEOUT",
        "kind": 5,
        "importPath": "custard.time.exceptions",
        "description": "custard.time.exceptions",
        "peekOfCode": "RETRY_SAME_TIMEOUT = 'RETRY_SAME_TIMEOUT'\nclass TimeOutError(Exception):\n    \"\"\"\n    An operation timed out\n    \"\"\"\n    pass\nclass FunctionTimedOut(BaseException):\n    def __init__(self, msg='', timed_out_after=None, timed_out_function=None,\n                 timed_out_args=None, timed_out_kwargs=None):\n        \"\"\"",
        "detail": "custard.time.exceptions",
        "documentation": {}
    },
    {
        "label": "Moment",
        "kind": 6,
        "importPath": "custard.time.moment",
        "description": "custard.time.moment",
        "peekOfCode": "class Moment:\n    @staticmethod\n    def get_now_time(layout=\"%Y-%m-%d %H:%M:%S\") -> str:\n        \"\"\"\n        获取当前时间\n        Args:\n            layout: 10timestamp， 13timestamp,  else  时间类型\n        Returns:\n        Examples:\n            >>> print(Moment.get_now_time(\"%Y-%m-%d %H:%M:%S\"))",
        "detail": "custard.time.moment",
        "documentation": {}
    },
    {
        "label": "StoppableThread",
        "kind": 6,
        "importPath": "custard.time.stoppable_thread",
        "description": "custard.time.stoppable_thread",
        "peekOfCode": "class StoppableThread(threading.Thread):\n    def stop_thread(self, exception, repeat_every=2.0):\n        if self.is_alive() is False:\n            return True\n        self._stderr = open(os.devnull, 'w')\n        join_thread = JoinThread(self, exception, repeat_every=repeat_every)\n        join_thread._stderr = self._stderr\n        join_thread.start()\n        join_thread._stderr = self._stderr\n    def stop(self, exception, repeat_every=2.0):",
        "detail": "custard.time.stoppable_thread",
        "documentation": {}
    },
    {
        "label": "JoinThread",
        "kind": 6,
        "importPath": "custard.time.stoppable_thread",
        "description": "custard.time.stoppable_thread",
        "peekOfCode": "class JoinThread(threading.Thread):\n    def __init__(self, other_thread, exception, repeat_every=2.0):\n        threading.Thread.__init__(self)\n        self.other_thread = other_thread\n        self.exception = exception\n        self.repeat_every = repeat_every\n        self.daemon = True\n    def run(self):\n        self.other_thread._Thread__stderr = self._stderr\n        if hasattr(self.other_thread, '_thread__stop'):",
        "detail": "custard.time.stoppable_thread",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "custard.time.stoppable_thread",
        "description": "custard.time.stoppable_thread",
        "peekOfCode": "__all__ = ('StoppableThread', 'JoinThread')\nclass StoppableThread(threading.Thread):\n    def stop_thread(self, exception, repeat_every=2.0):\n        if self.is_alive() is False:\n            return True\n        self._stderr = open(os.devnull, 'w')\n        join_thread = JoinThread(self, exception, repeat_every=repeat_every)\n        join_thread._stderr = self._stderr\n        join_thread.start()\n        join_thread._stderr = self._stderr",
        "detail": "custard.time.stoppable_thread",
        "documentation": {}
    },
    {
        "label": "add_dicts",
        "kind": 2,
        "importPath": "custard.utils.datasets",
        "description": "custard.utils.datasets",
        "peekOfCode": "def add_dicts(*args: Tuple[Dict, ...]) -> Dict:\n    \"\"\"\n    Adds two or more dicts together. Common keys will have their values added.\n    Returns:\n    Example:\n        >>> t1 = {'a':1, 'b':2}\n        >>> t2 = {'b':1, 'c':3}\n        >>> t3 = {'d':5}\n        >>> add_dicts(t1, t2, t3)\n        {'a': 1, 'c': 3, 'b': 3, 'd': 5}",
        "detail": "custard.utils.datasets",
        "documentation": {}
    },
    {
        "label": "slugify",
        "kind": 2,
        "importPath": "custard.utils.decorators",
        "description": "custard.utils.decorators",
        "peekOfCode": "def slugify(fn: Callable) -> Callable:\n    @wraps(fn)\n    def wrapper(*args: Tuple[T, ...], **kwargs: Dict[str, T]) -> str:\n        return text.slugify(fn(*args, **kwargs))\n    return wrapper\ndef slugify_domain(fn: Callable) -> Callable:\n    @wraps(fn)\n    def wrapper(*args: Tuple[T, ...], **kwargs: Dict[str, T]) -> str:\n        return text.slugify(fn(*args, **kwargs), allow_dots=True)\n    return wrapper",
        "detail": "custard.utils.decorators",
        "documentation": {}
    },
    {
        "label": "slugify_domain",
        "kind": 2,
        "importPath": "custard.utils.decorators",
        "description": "custard.utils.decorators",
        "peekOfCode": "def slugify_domain(fn: Callable) -> Callable:\n    @wraps(fn)\n    def wrapper(*args: Tuple[T, ...], **kwargs: Dict[str, T]) -> str:\n        return text.slugify(fn(*args, **kwargs), allow_dots=True)\n    return wrapper\ndef slugify_unicode(fn: Callable) -> Callable:\n    @wraps(fn)\n    def wrapper(*args: Tuple[T, ...], **kwargs: Dict[str, T]) -> str:\n        return text.slugify(fn(*args, **kwargs), allow_unicode=True)\n    return wrapper",
        "detail": "custard.utils.decorators",
        "documentation": {}
    },
    {
        "label": "slugify_unicode",
        "kind": 2,
        "importPath": "custard.utils.decorators",
        "description": "custard.utils.decorators",
        "peekOfCode": "def slugify_unicode(fn: Callable) -> Callable:\n    @wraps(fn)\n    def wrapper(*args: Tuple[T, ...], **kwargs: Dict[str, T]) -> str:\n        return text.slugify(fn(*args, **kwargs), allow_unicode=True)\n    return wrapper\ndef lowercase(fn: Callable) -> Callable:\n    @wraps(fn)\n    def wrapper(*args: Tuple[T, ...], **kwargs: Dict[str, T]) -> str:\n        return fn(*args, **kwargs).lower()\n    return wrapper",
        "detail": "custard.utils.decorators",
        "documentation": {}
    },
    {
        "label": "lowercase",
        "kind": 2,
        "importPath": "custard.utils.decorators",
        "description": "custard.utils.decorators",
        "peekOfCode": "def lowercase(fn: Callable) -> Callable:\n    @wraps(fn)\n    def wrapper(*args: Tuple[T, ...], **kwargs: Dict[str, T]) -> str:\n        return fn(*args, **kwargs).lower()\n    return wrapper",
        "detail": "custard.utils.decorators",
        "documentation": {}
    },
    {
        "label": "T",
        "kind": 5,
        "importPath": "custard.utils.decorators",
        "description": "custard.utils.decorators",
        "peekOfCode": "T = TypeVar(\"T\")\ndef slugify(fn: Callable) -> Callable:\n    @wraps(fn)\n    def wrapper(*args: Tuple[T, ...], **kwargs: Dict[str, T]) -> str:\n        return text.slugify(fn(*args, **kwargs))\n    return wrapper\ndef slugify_domain(fn: Callable) -> Callable:\n    @wraps(fn)\n    def wrapper(*args: Tuple[T, ...], **kwargs: Dict[str, T]) -> str:\n        return text.slugify(fn(*args, **kwargs), allow_dots=True)",
        "detail": "custard.utils.decorators",
        "documentation": {}
    },
    {
        "label": "slugify",
        "kind": 2,
        "importPath": "custard.utils.text",
        "description": "custard.utils.text",
        "peekOfCode": "def slugify(value: str, allow_dots: bool = False, allow_unicode: bool = False) -> str:\n    \"\"\"\n    Converts to lowercase, removes non-word characters (alphanumerics and\n    underscores) and converts spaces to hyphens. Also strips leading and\n    trailing whitespace. Modified to optionally allow dots.\n    Adapted from Django 1.9\n    \"\"\"\n    pattern: Pattern = _re_pattern_allow_dots if allow_dots else _re_pattern\n    value = str(value)\n    if allow_unicode:",
        "detail": "custard.utils.text",
        "documentation": {}
    },
    {
        "label": "loop",
        "kind": 5,
        "importPath": "examples.async_lur",
        "description": "examples.async_lur",
        "peekOfCode": "loop = asyncio.get_event_loop()\nloop.run_until_complete(main())\nloop.close()",
        "detail": "examples.async_lur",
        "documentation": {}
    },
    {
        "label": "_Test",
        "kind": 6,
        "importPath": "examples.decorator",
        "description": "examples.decorator",
        "peekOfCode": "class _Test(unittest.TestCase):\n    @unittest.skip\n    @bind_timeout(timeout=0.5)\n    def test_not_time_out(self):\n        print(\"未超出限定的时间测试\")\n        time.sleep(0.2)\n    @unittest.skip\n    @bind_timeout(timeout=0.5)\n    def test_time_out(self):\n        print(\"超出限定的时间测试\")",
        "detail": "examples.decorator",
        "documentation": {}
    },
    {
        "label": "is_execute",
        "kind": 5,
        "importPath": "examples.dts",
        "description": "examples.dts",
        "peekOfCode": "is_execute = True\nsource_schema = \"dts\"\nsource_url = \"localhost\"\nsource_user = \"root\"\nsource_password = \"PassWord@Mysql123\"\nsource_port = 3306\ntarget_schema = \"dts_bak\"\ntarget_url = \"localhost\"\ntarget_user = \"root\"\ntarget_password = \"PassWord@Redis123\"",
        "detail": "examples.dts",
        "documentation": {}
    },
    {
        "label": "source_schema",
        "kind": 5,
        "importPath": "examples.dts",
        "description": "examples.dts",
        "peekOfCode": "source_schema = \"dts\"\nsource_url = \"localhost\"\nsource_user = \"root\"\nsource_password = \"PassWord@Mysql123\"\nsource_port = 3306\ntarget_schema = \"dts_bak\"\ntarget_url = \"localhost\"\ntarget_user = \"root\"\ntarget_password = \"PassWord@Redis123\"\ntarget_port = 3306",
        "detail": "examples.dts",
        "documentation": {}
    },
    {
        "label": "source_url",
        "kind": 5,
        "importPath": "examples.dts",
        "description": "examples.dts",
        "peekOfCode": "source_url = \"localhost\"\nsource_user = \"root\"\nsource_password = \"PassWord@Mysql123\"\nsource_port = 3306\ntarget_schema = \"dts_bak\"\ntarget_url = \"localhost\"\ntarget_user = \"root\"\ntarget_password = \"PassWord@Redis123\"\ntarget_port = 3306\nsql_inspect = MySqlInspect(source_schema, source_url, source_user, source_password, source_port,",
        "detail": "examples.dts",
        "documentation": {}
    },
    {
        "label": "source_user",
        "kind": 5,
        "importPath": "examples.dts",
        "description": "examples.dts",
        "peekOfCode": "source_user = \"root\"\nsource_password = \"PassWord@Mysql123\"\nsource_port = 3306\ntarget_schema = \"dts_bak\"\ntarget_url = \"localhost\"\ntarget_user = \"root\"\ntarget_password = \"PassWord@Redis123\"\ntarget_port = 3306\nsql_inspect = MySqlInspect(source_schema, source_url, source_user, source_password, source_port,\n                           target_schema, target_url, target_user, target_password, target_port)",
        "detail": "examples.dts",
        "documentation": {}
    },
    {
        "label": "source_password",
        "kind": 5,
        "importPath": "examples.dts",
        "description": "examples.dts",
        "peekOfCode": "source_password = \"PassWord@Mysql123\"\nsource_port = 3306\ntarget_schema = \"dts_bak\"\ntarget_url = \"localhost\"\ntarget_user = \"root\"\ntarget_password = \"PassWord@Redis123\"\ntarget_port = 3306\nsql_inspect = MySqlInspect(source_schema, source_url, source_user, source_password, source_port,\n                           target_schema, target_url, target_user, target_password, target_port)\nsql_util = MysqlUtil(source_schema, source_url, source_user, source_password, source_port)",
        "detail": "examples.dts",
        "documentation": {}
    },
    {
        "label": "source_port",
        "kind": 5,
        "importPath": "examples.dts",
        "description": "examples.dts",
        "peekOfCode": "source_port = 3306\ntarget_schema = \"dts_bak\"\ntarget_url = \"localhost\"\ntarget_user = \"root\"\ntarget_password = \"PassWord@Redis123\"\ntarget_port = 3306\nsql_inspect = MySqlInspect(source_schema, source_url, source_user, source_password, source_port,\n                           target_schema, target_url, target_user, target_password, target_port)\nsql_util = MysqlUtil(source_schema, source_url, source_user, source_password, source_port)\nsql_util.get_columns(\"pika_sensitive_word\")",
        "detail": "examples.dts",
        "documentation": {}
    },
    {
        "label": "target_schema",
        "kind": 5,
        "importPath": "examples.dts",
        "description": "examples.dts",
        "peekOfCode": "target_schema = \"dts_bak\"\ntarget_url = \"localhost\"\ntarget_user = \"root\"\ntarget_password = \"PassWord@Redis123\"\ntarget_port = 3306\nsql_inspect = MySqlInspect(source_schema, source_url, source_user, source_password, source_port,\n                           target_schema, target_url, target_user, target_password, target_port)\nsql_util = MysqlUtil(source_schema, source_url, source_user, source_password, source_port)\nsql_util.get_columns(\"pika_sensitive_word\")\nsql_inspect.inspect_table(is_execute)",
        "detail": "examples.dts",
        "documentation": {}
    },
    {
        "label": "target_url",
        "kind": 5,
        "importPath": "examples.dts",
        "description": "examples.dts",
        "peekOfCode": "target_url = \"localhost\"\ntarget_user = \"root\"\ntarget_password = \"PassWord@Redis123\"\ntarget_port = 3306\nsql_inspect = MySqlInspect(source_schema, source_url, source_user, source_password, source_port,\n                           target_schema, target_url, target_user, target_password, target_port)\nsql_util = MysqlUtil(source_schema, source_url, source_user, source_password, source_port)\nsql_util.get_columns(\"pika_sensitive_word\")\nsql_inspect.inspect_table(is_execute)",
        "detail": "examples.dts",
        "documentation": {}
    },
    {
        "label": "target_user",
        "kind": 5,
        "importPath": "examples.dts",
        "description": "examples.dts",
        "peekOfCode": "target_user = \"root\"\ntarget_password = \"PassWord@Redis123\"\ntarget_port = 3306\nsql_inspect = MySqlInspect(source_schema, source_url, source_user, source_password, source_port,\n                           target_schema, target_url, target_user, target_password, target_port)\nsql_util = MysqlUtil(source_schema, source_url, source_user, source_password, source_port)\nsql_util.get_columns(\"pika_sensitive_word\")\nsql_inspect.inspect_table(is_execute)",
        "detail": "examples.dts",
        "documentation": {}
    },
    {
        "label": "target_password",
        "kind": 5,
        "importPath": "examples.dts",
        "description": "examples.dts",
        "peekOfCode": "target_password = \"PassWord@Redis123\"\ntarget_port = 3306\nsql_inspect = MySqlInspect(source_schema, source_url, source_user, source_password, source_port,\n                           target_schema, target_url, target_user, target_password, target_port)\nsql_util = MysqlUtil(source_schema, source_url, source_user, source_password, source_port)\nsql_util.get_columns(\"pika_sensitive_word\")\nsql_inspect.inspect_table(is_execute)",
        "detail": "examples.dts",
        "documentation": {}
    },
    {
        "label": "target_port",
        "kind": 5,
        "importPath": "examples.dts",
        "description": "examples.dts",
        "peekOfCode": "target_port = 3306\nsql_inspect = MySqlInspect(source_schema, source_url, source_user, source_password, source_port,\n                           target_schema, target_url, target_user, target_password, target_port)\nsql_util = MysqlUtil(source_schema, source_url, source_user, source_password, source_port)\nsql_util.get_columns(\"pika_sensitive_word\")\nsql_inspect.inspect_table(is_execute)",
        "detail": "examples.dts",
        "documentation": {}
    },
    {
        "label": "sql_inspect",
        "kind": 5,
        "importPath": "examples.dts",
        "description": "examples.dts",
        "peekOfCode": "sql_inspect = MySqlInspect(source_schema, source_url, source_user, source_password, source_port,\n                           target_schema, target_url, target_user, target_password, target_port)\nsql_util = MysqlUtil(source_schema, source_url, source_user, source_password, source_port)\nsql_util.get_columns(\"pika_sensitive_word\")\nsql_inspect.inspect_table(is_execute)",
        "detail": "examples.dts",
        "documentation": {}
    },
    {
        "label": "sql_util",
        "kind": 5,
        "importPath": "examples.dts",
        "description": "examples.dts",
        "peekOfCode": "sql_util = MysqlUtil(source_schema, source_url, source_user, source_password, source_port)\nsql_util.get_columns(\"pika_sensitive_word\")\nsql_inspect.inspect_table(is_execute)",
        "detail": "examples.dts",
        "documentation": {}
    },
    {
        "label": "TestJsonLogger",
        "kind": 6,
        "importPath": "examples.json_logger",
        "description": "examples.json_logger",
        "peekOfCode": "class TestJsonLogger(unittest.TestCase):\n    def setUp(self):\n        self.logger = logging.getLogger(\"logging-test-{}\".format(random.randint(1, 101)))\n        self.logger.setLevel(logging.DEBUG)\n        self.buffer = StringIO()\n        self.logHandler = logging.StreamHandler(self.buffer)\n        self.logger.addHandler(self.logHandler)\n    def testDefaultFormat(self):\n        fr = jsonlogger.JsonFormatter()\n        self.logHandler.setFormatter(fr)",
        "detail": "examples.json_logger",
        "documentation": {}
    },
    {
        "label": "test4",
        "kind": 2,
        "importPath": "examples.kaptcha_execution_time",
        "description": "examples.kaptcha_execution_time",
        "peekOfCode": "def test4():\n    start = time.time()\n    obj = kaptcha.Captcha(gif=True)\n    for _ in range(1000):\n        obj.letter_digit()\n    print(f\"<gif动画>1000次测试平均单次生成时间: {(time.time() - start) / 1000:.5f}\")\ndef test3():\n    start = time.time()\n    obj = kaptcha.Captcha(imageObj=True)\n    for _ in range(1000):",
        "detail": "examples.kaptcha_execution_time",
        "documentation": {}
    },
    {
        "label": "test3",
        "kind": 2,
        "importPath": "examples.kaptcha_execution_time",
        "description": "examples.kaptcha_execution_time",
        "peekOfCode": "def test3():\n    start = time.time()\n    obj = kaptcha.Captcha(imageObj=True)\n    for _ in range(1000):\n        obj.letter_digit()\n    print(f\"<Image返回>1000次测试平均单次生成时间: {(time.time() - start) / 1000:.5f}\")\ndef test2():\n    start = time.time()\n    obj = kaptcha.Captcha(enhance=True, chips=15)\n    for _ in range(1000):",
        "detail": "examples.kaptcha_execution_time",
        "documentation": {}
    },
    {
        "label": "test2",
        "kind": 2,
        "importPath": "examples.kaptcha_execution_time",
        "description": "examples.kaptcha_execution_time",
        "peekOfCode": "def test2():\n    start = time.time()\n    obj = kaptcha.Captcha(enhance=True, chips=15)\n    for _ in range(1000):\n        obj.letter_digit()\n    print(f\"<滤镜渲染、超高干扰点>1000次测试平均单次生成时间: {(time.time() - start) / 1000:.5f}\")\ndef test1():\n    start = time.time()\n    for _ in range(1000):\n        kaptcha.Captcha().letter_digit()",
        "detail": "examples.kaptcha_execution_time",
        "documentation": {}
    },
    {
        "label": "test1",
        "kind": 2,
        "importPath": "examples.kaptcha_execution_time",
        "description": "examples.kaptcha_execution_time",
        "peekOfCode": "def test1():\n    start = time.time()\n    for _ in range(1000):\n        kaptcha.Captcha().letter_digit()\n    print(f\"1000次测试平均单次生成时间: {(time.time() - start) / 1000:.5f}\")\ntest1()\ntest2()\ntest3()\ntest4()",
        "detail": "examples.kaptcha_execution_time",
        "documentation": {}
    },
    {
        "label": "app",
        "kind": 5,
        "importPath": "examples.limiter",
        "description": "examples.limiter",
        "peekOfCode": "app = FastAPI()\n@app.on_event(\"startup\")\nasync def startup():\n    \"\"\"https://aioredis.readthedocs.io/en/latest/getting-started/\"\"\"\n    redis = await aioredis.from_url(\"redis://localhost:6379\", password=\"PassWord@Redis123\", encoding=\"utf8\")\n    await Limiter.init(redis)\n@app.on_event(\"shutdown\")\nasync def shutdown():\n    await Limiter.close()\n@app.get(\"/\", dependencies=[Depends(RateLimiter(counts=2, seconds=5))])",
        "detail": "examples.limiter",
        "documentation": {}
    },
    {
        "label": "Mock",
        "kind": 5,
        "importPath": "examples.mock",
        "description": "examples.mock",
        "peekOfCode": "Mock = Mock()\npprint(Mock.mock('@csentence 变量示例'))\npprint(Mock.mock('@paragraph 变量示例'))\npprint(Mock.mock('@cparagraph 变量示例'))\npprint(Mock.mock('@sentence 变量示例'))\npprint(Mock.mock('@csentence 变量示例'))\npprint(Mock.mock('@word 变量示例'))\npprint(Mock.mock('@cword 变量示例'))\npprint(Mock.mock('@emoji 变量示例'))\npprint(Mock.mock('@title 变量示例'))",
        "detail": "examples.mock",
        "documentation": {}
    },
    {
        "label": "User",
        "kind": 6,
        "importPath": "examples.pagination_async_sqlalchemy",
        "description": "examples.pagination_async_sqlalchemy",
        "peekOfCode": "class User(Base):\n    __tablename__ = \"users\"\n    id = Column(Integer, primary_key=True, autoincrement=True)\n    name = Column(String, nullable=False)\n    email = Column(String, nullable=False)\nclass UserIn(BaseModel):\n    name: str\n    email: str\nclass UserOut(UserIn):\n    id: int",
        "detail": "examples.pagination_async_sqlalchemy",
        "documentation": {}
    },
    {
        "label": "UserIn",
        "kind": 6,
        "importPath": "examples.pagination_async_sqlalchemy",
        "description": "examples.pagination_async_sqlalchemy",
        "peekOfCode": "class UserIn(BaseModel):\n    name: str\n    email: str\nclass UserOut(UserIn):\n    id: int\n    class Config:\n        orm_mode = True\napp = FastAPI()\n@app.on_event(\"startup\")\nasync def on_startup() -> None:",
        "detail": "examples.pagination_async_sqlalchemy",
        "documentation": {}
    },
    {
        "label": "UserOut",
        "kind": 6,
        "importPath": "examples.pagination_async_sqlalchemy",
        "description": "examples.pagination_async_sqlalchemy",
        "peekOfCode": "class UserOut(UserIn):\n    id: int\n    class Config:\n        orm_mode = True\napp = FastAPI()\n@app.on_event(\"startup\")\nasync def on_startup() -> None:\n    async with engine.begin() as conn:\n        await conn.run_sync(Base.metadata.drop_all)\n        await conn.run_sync(Base.metadata.create_all)",
        "detail": "examples.pagination_async_sqlalchemy",
        "documentation": {}
    },
    {
        "label": "faker",
        "kind": 5,
        "importPath": "examples.pagination_async_sqlalchemy",
        "description": "examples.pagination_async_sqlalchemy",
        "peekOfCode": "faker = Faker()\nengine = create_async_engine(\"sqlite+aiosqlite:///.db\")\nasync_session = sessionmaker(engine, class_=AsyncSession)\nBase = declarative_base()\nclass User(Base):\n    __tablename__ = \"users\"\n    id = Column(Integer, primary_key=True, autoincrement=True)\n    name = Column(String, nullable=False)\n    email = Column(String, nullable=False)\nclass UserIn(BaseModel):",
        "detail": "examples.pagination_async_sqlalchemy",
        "documentation": {}
    },
    {
        "label": "engine",
        "kind": 5,
        "importPath": "examples.pagination_async_sqlalchemy",
        "description": "examples.pagination_async_sqlalchemy",
        "peekOfCode": "engine = create_async_engine(\"sqlite+aiosqlite:///.db\")\nasync_session = sessionmaker(engine, class_=AsyncSession)\nBase = declarative_base()\nclass User(Base):\n    __tablename__ = \"users\"\n    id = Column(Integer, primary_key=True, autoincrement=True)\n    name = Column(String, nullable=False)\n    email = Column(String, nullable=False)\nclass UserIn(BaseModel):\n    name: str",
        "detail": "examples.pagination_async_sqlalchemy",
        "documentation": {}
    },
    {
        "label": "async_session",
        "kind": 5,
        "importPath": "examples.pagination_async_sqlalchemy",
        "description": "examples.pagination_async_sqlalchemy",
        "peekOfCode": "async_session = sessionmaker(engine, class_=AsyncSession)\nBase = declarative_base()\nclass User(Base):\n    __tablename__ = \"users\"\n    id = Column(Integer, primary_key=True, autoincrement=True)\n    name = Column(String, nullable=False)\n    email = Column(String, nullable=False)\nclass UserIn(BaseModel):\n    name: str\n    email: str",
        "detail": "examples.pagination_async_sqlalchemy",
        "documentation": {}
    },
    {
        "label": "Base",
        "kind": 5,
        "importPath": "examples.pagination_async_sqlalchemy",
        "description": "examples.pagination_async_sqlalchemy",
        "peekOfCode": "Base = declarative_base()\nclass User(Base):\n    __tablename__ = \"users\"\n    id = Column(Integer, primary_key=True, autoincrement=True)\n    name = Column(String, nullable=False)\n    email = Column(String, nullable=False)\nclass UserIn(BaseModel):\n    name: str\n    email: str\nclass UserOut(UserIn):",
        "detail": "examples.pagination_async_sqlalchemy",
        "documentation": {}
    },
    {
        "label": "app",
        "kind": 5,
        "importPath": "examples.pagination_async_sqlalchemy",
        "description": "examples.pagination_async_sqlalchemy",
        "peekOfCode": "app = FastAPI()\n@app.on_event(\"startup\")\nasync def on_startup() -> None:\n    async with engine.begin() as conn:\n        await conn.run_sync(Base.metadata.drop_all)\n        await conn.run_sync(Base.metadata.create_all)\n    async with async_session() as session:\n        session.add_all([User(name=faker.name(), email=faker.email()) for _ in range(10)])\n        await session.commit()\nasync def get_db() -> AsyncIterator[AsyncSession]:",
        "detail": "examples.pagination_async_sqlalchemy",
        "documentation": {}
    },
    {
        "label": "User",
        "kind": 6,
        "importPath": "examples.pagination_sqlalchemy",
        "description": "examples.pagination_sqlalchemy",
        "peekOfCode": "class User(Base):\n    __tablename__ = \"users\"\n    id = Column(Integer, primary_key=True, autoincrement=True)\n    name = Column(String, nullable=False)\n    email = Column(String, nullable=False)\nBase.metadata.drop_all()\nBase.metadata.create_all()\nclass UserIn(BaseModel):\n    name: str\n    email: str",
        "detail": "examples.pagination_sqlalchemy",
        "documentation": {}
    },
    {
        "label": "UserIn",
        "kind": 6,
        "importPath": "examples.pagination_sqlalchemy",
        "description": "examples.pagination_sqlalchemy",
        "peekOfCode": "class UserIn(BaseModel):\n    name: str\n    email: str\nclass UserOut(UserIn):\n    id: int\n    class Config:\n        orm_mode = True\napp = FastAPI()\n@app.on_event(\"startup\")\ndef on_startup() -> None:",
        "detail": "examples.pagination_sqlalchemy",
        "documentation": {}
    },
    {
        "label": "UserOut",
        "kind": 6,
        "importPath": "examples.pagination_sqlalchemy",
        "description": "examples.pagination_sqlalchemy",
        "peekOfCode": "class UserOut(UserIn):\n    id: int\n    class Config:\n        orm_mode = True\napp = FastAPI()\n@app.on_event(\"startup\")\ndef on_startup() -> None:\n    session = SessionLocal()\n    session.add_all([User(name=faker.name(), email=faker.email()) for _ in range(100)])\n    session.flush()",
        "detail": "examples.pagination_sqlalchemy",
        "documentation": {}
    },
    {
        "label": "on_startup",
        "kind": 2,
        "importPath": "examples.pagination_sqlalchemy",
        "description": "examples.pagination_sqlalchemy",
        "peekOfCode": "def on_startup() -> None:\n    session = SessionLocal()\n    session.add_all([User(name=faker.name(), email=faker.email()) for _ in range(100)])\n    session.flush()\n    session.close()\ndef get_db() -> Iterator[Session]:\n    db = SessionLocal()\n    try:\n        yield db\n    finally:",
        "detail": "examples.pagination_sqlalchemy",
        "documentation": {}
    },
    {
        "label": "get_db",
        "kind": 2,
        "importPath": "examples.pagination_sqlalchemy",
        "description": "examples.pagination_sqlalchemy",
        "peekOfCode": "def get_db() -> Iterator[Session]:\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n@app.post(\"/users\", response_model=UserOut)\ndef create_user(user_in: UserIn, db: Session = Depends(get_db)) -> User:\n    user = User(name=user_in.name, email=user_in.email)\n    db.add(user)",
        "detail": "examples.pagination_sqlalchemy",
        "documentation": {}
    },
    {
        "label": "create_user",
        "kind": 2,
        "importPath": "examples.pagination_sqlalchemy",
        "description": "examples.pagination_sqlalchemy",
        "peekOfCode": "def create_user(user_in: UserIn, db: Session = Depends(get_db)) -> User:\n    user = User(name=user_in.name, email=user_in.email)\n    db.add(user)\n    db.flush()\n    return user\n@app.get(\"/users/default\", response_model=Page[UserOut])\n@app.get(\"/users/limit-offset\", response_model=LimitOffsetPage[UserOut])\ndef get_users(db: Session = Depends(get_db)) -> Any:\n    return paginate(db.query(User))\nadd_pagination(app)",
        "detail": "examples.pagination_sqlalchemy",
        "documentation": {}
    },
    {
        "label": "get_users",
        "kind": 2,
        "importPath": "examples.pagination_sqlalchemy",
        "description": "examples.pagination_sqlalchemy",
        "peekOfCode": "def get_users(db: Session = Depends(get_db)) -> Any:\n    return paginate(db.query(User))\nadd_pagination(app)\nif __name__ == \"__main__\":\n    uvicorn.run(\"pagination_sqlalchemy:app\")",
        "detail": "examples.pagination_sqlalchemy",
        "documentation": {}
    },
    {
        "label": "faker",
        "kind": 5,
        "importPath": "examples.pagination_sqlalchemy",
        "description": "examples.pagination_sqlalchemy",
        "peekOfCode": "faker = Faker()\nengine = create_engine(\"sqlite:///.db\", connect_args={\"check_same_thread\": False})\nSessionLocal = sessionmaker(autocommit=True, autoflush=True, bind=engine)\nBase = declarative_base(bind=engine)\nclass User(Base):\n    __tablename__ = \"users\"\n    id = Column(Integer, primary_key=True, autoincrement=True)\n    name = Column(String, nullable=False)\n    email = Column(String, nullable=False)\nBase.metadata.drop_all()",
        "detail": "examples.pagination_sqlalchemy",
        "documentation": {}
    },
    {
        "label": "engine",
        "kind": 5,
        "importPath": "examples.pagination_sqlalchemy",
        "description": "examples.pagination_sqlalchemy",
        "peekOfCode": "engine = create_engine(\"sqlite:///.db\", connect_args={\"check_same_thread\": False})\nSessionLocal = sessionmaker(autocommit=True, autoflush=True, bind=engine)\nBase = declarative_base(bind=engine)\nclass User(Base):\n    __tablename__ = \"users\"\n    id = Column(Integer, primary_key=True, autoincrement=True)\n    name = Column(String, nullable=False)\n    email = Column(String, nullable=False)\nBase.metadata.drop_all()\nBase.metadata.create_all()",
        "detail": "examples.pagination_sqlalchemy",
        "documentation": {}
    },
    {
        "label": "SessionLocal",
        "kind": 5,
        "importPath": "examples.pagination_sqlalchemy",
        "description": "examples.pagination_sqlalchemy",
        "peekOfCode": "SessionLocal = sessionmaker(autocommit=True, autoflush=True, bind=engine)\nBase = declarative_base(bind=engine)\nclass User(Base):\n    __tablename__ = \"users\"\n    id = Column(Integer, primary_key=True, autoincrement=True)\n    name = Column(String, nullable=False)\n    email = Column(String, nullable=False)\nBase.metadata.drop_all()\nBase.metadata.create_all()\nclass UserIn(BaseModel):",
        "detail": "examples.pagination_sqlalchemy",
        "documentation": {}
    },
    {
        "label": "Base",
        "kind": 5,
        "importPath": "examples.pagination_sqlalchemy",
        "description": "examples.pagination_sqlalchemy",
        "peekOfCode": "Base = declarative_base(bind=engine)\nclass User(Base):\n    __tablename__ = \"users\"\n    id = Column(Integer, primary_key=True, autoincrement=True)\n    name = Column(String, nullable=False)\n    email = Column(String, nullable=False)\nBase.metadata.drop_all()\nBase.metadata.create_all()\nclass UserIn(BaseModel):\n    name: str",
        "detail": "examples.pagination_sqlalchemy",
        "documentation": {}
    },
    {
        "label": "app",
        "kind": 5,
        "importPath": "examples.pagination_sqlalchemy",
        "description": "examples.pagination_sqlalchemy",
        "peekOfCode": "app = FastAPI()\n@app.on_event(\"startup\")\ndef on_startup() -> None:\n    session = SessionLocal()\n    session.add_all([User(name=faker.name(), email=faker.email()) for _ in range(100)])\n    session.flush()\n    session.close()\ndef get_db() -> Iterator[Session]:\n    db = SessionLocal()\n    try:",
        "detail": "examples.pagination_sqlalchemy",
        "documentation": {}
    },
    {
        "label": "url",
        "kind": 5,
        "importPath": "examples.swagger_online_change",
        "description": "examples.swagger_online_change",
        "peekOfCode": "url = 'http://xxxx/doctor-api/swagger/doc.json'\nswagger = custard.swagger_parse(url)\nprint('转换接口：{}个'.format(len(swagger.apis)))\napi_path = 'doctor-api.json'\nwith open(api_path, mode='w', encoding='utf8') as f:\n    f.write(json.dumps(swagger.apis, indent=4, ensure_ascii=False))",
        "detail": "examples.swagger_online_change",
        "documentation": {}
    },
    {
        "label": "swagger",
        "kind": 5,
        "importPath": "examples.swagger_online_change",
        "description": "examples.swagger_online_change",
        "peekOfCode": "swagger = custard.swagger_parse(url)\nprint('转换接口：{}个'.format(len(swagger.apis)))\napi_path = 'doctor-api.json'\nwith open(api_path, mode='w', encoding='utf8') as f:\n    f.write(json.dumps(swagger.apis, indent=4, ensure_ascii=False))",
        "detail": "examples.swagger_online_change",
        "documentation": {}
    },
    {
        "label": "api_path",
        "kind": 5,
        "importPath": "examples.swagger_online_change",
        "description": "examples.swagger_online_change",
        "peekOfCode": "api_path = 'doctor-api.json'\nwith open(api_path, mode='w', encoding='utf8') as f:\n    f.write(json.dumps(swagger.apis, indent=4, ensure_ascii=False))",
        "detail": "examples.swagger_online_change",
        "documentation": {}
    },
    {
        "label": "APITestCase",
        "kind": 6,
        "importPath": "examples.swagger_usabletest",
        "description": "examples.swagger_usabletest",
        "peekOfCode": "class APITestCase(unittest.TestCase):\n    default_file = './file.txt'\n    result_path = 'result/接口鉴权报告'\n    @classmethod\n    def setUpClass(cls, run_host=None):\n        warnings.simplefilter('ignore', ResourceWarning)\n        # 准备测试资源\n        if not os.path.exists(cls.default_file):\n            with open(cls.default_file, mode='w') as f:\n                f.write('Hello world!')",
        "detail": "examples.swagger_usabletest",
        "documentation": {}
    }
]