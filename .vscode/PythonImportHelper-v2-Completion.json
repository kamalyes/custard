[
    {
        "label": "asyncio",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "asyncio",
        "description": "asyncio",
        "detail": "asyncio",
        "documentation": {}
    },
    {
        "label": "OrderedDict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "defaultdict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "OrderedDict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "OrderedDict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "ChainMap",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "Counter",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "functools",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "functools",
        "description": "functools",
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "_CacheInfo",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "_make_key",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "partial",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "wraps",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "reduce",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "wraps",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "wraps",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "wraps",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "wraps",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "wraps",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "wraps",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "wraps",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "reduce",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "wraps",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "logging",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "logging",
        "description": "logging",
        "detail": "logging",
        "documentation": {}
    },
    {
        "label": "DEBUG",
        "importPath": "logging",
        "description": "logging",
        "isExtraImport": true,
        "detail": "logging",
        "documentation": {}
    },
    {
        "label": "ERROR",
        "importPath": "logging",
        "description": "logging",
        "isExtraImport": true,
        "detail": "logging",
        "documentation": {}
    },
    {
        "label": "FATAL",
        "importPath": "logging",
        "description": "logging",
        "isExtraImport": true,
        "detail": "logging",
        "documentation": {}
    },
    {
        "label": "INFO",
        "importPath": "logging",
        "description": "logging",
        "isExtraImport": true,
        "detail": "logging",
        "documentation": {}
    },
    {
        "label": "WARN",
        "importPath": "logging",
        "description": "logging",
        "isExtraImport": true,
        "detail": "logging",
        "documentation": {}
    },
    {
        "label": "getLogger",
        "importPath": "logging",
        "description": "logging",
        "isExtraImport": true,
        "detail": "logging",
        "documentation": {}
    },
    {
        "label": "threading",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "threading",
        "description": "threading",
        "detail": "threading",
        "documentation": {}
    },
    {
        "label": "redis",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "redis",
        "description": "redis",
        "detail": "redis",
        "documentation": {}
    },
    {
        "label": "json",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "json",
        "description": "json",
        "detail": "json",
        "documentation": {}
    },
    {
        "label": "random",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "random",
        "description": "random",
        "detail": "random",
        "documentation": {}
    },
    {
        "label": "randint",
        "importPath": "random",
        "description": "random",
        "isExtraImport": true,
        "detail": "random",
        "documentation": {}
    },
    {
        "label": "uniform",
        "importPath": "random",
        "description": "random",
        "isExtraImport": true,
        "detail": "random",
        "documentation": {}
    },
    {
        "label": "re",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "re",
        "description": "re",
        "detail": "re",
        "documentation": {}
    },
    {
        "label": "string",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "string",
        "description": "string",
        "detail": "string",
        "documentation": {}
    },
    {
        "label": "ascii_letters",
        "importPath": "string",
        "description": "string",
        "isExtraImport": true,
        "detail": "string",
        "documentation": {}
    },
    {
        "label": "digits",
        "importPath": "string",
        "description": "string",
        "isExtraImport": true,
        "detail": "string",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Text",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Collection",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypeVar",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "AsyncIterator",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "ContextManager",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterator",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Type",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypeVar",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "cast",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "ClassVar",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Generic",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Mapping",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Type",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypeVar",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "cast",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Generic",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypeVar",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Generic",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypeVar",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Generic",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypeVar",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypeVar",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Generic",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypeVar",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypeVar",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypeVar",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Pattern",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "AsyncIterator",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterator",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "urllib.parse",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "urllib.parse",
        "description": "urllib.parse",
        "detail": "urllib.parse",
        "documentation": {}
    },
    {
        "label": "quote",
        "importPath": "urllib.parse",
        "description": "urllib.parse",
        "isExtraImport": true,
        "detail": "urllib.parse",
        "documentation": {}
    },
    {
        "label": "pypinyin",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pypinyin",
        "description": "pypinyin",
        "detail": "pypinyin",
        "documentation": {}
    },
    {
        "label": "Faker",
        "importPath": "faker",
        "description": "faker",
        "isExtraImport": true,
        "detail": "faker",
        "documentation": {}
    },
    {
        "label": "Faker",
        "importPath": "faker",
        "description": "faker",
        "isExtraImport": true,
        "detail": "faker",
        "documentation": {}
    },
    {
        "label": "Faker",
        "importPath": "faker",
        "description": "faker",
        "isExtraImport": true,
        "detail": "faker",
        "documentation": {}
    },
    {
        "label": "InvalidURL",
        "importPath": "requests.exceptions",
        "description": "requests.exceptions",
        "isExtraImport": true,
        "detail": "requests.exceptions",
        "documentation": {}
    },
    {
        "label": "LocationParseError",
        "importPath": "urllib3.exceptions",
        "description": "urllib3.exceptions",
        "isExtraImport": true,
        "detail": "urllib3.exceptions",
        "documentation": {}
    },
    {
        "label": "parse_url",
        "importPath": "urllib3.util",
        "description": "urllib3.util",
        "isExtraImport": true,
        "detail": "urllib3.util",
        "documentation": {}
    },
    {
        "label": "Moment",
        "importPath": "custard.time.moment",
        "description": "custard.time.moment",
        "isExtraImport": true,
        "detail": "custard.time.moment",
        "documentation": {}
    },
    {
        "label": "base64",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "base64",
        "description": "base64",
        "detail": "base64",
        "documentation": {}
    },
    {
        "label": "hashlib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "hashlib",
        "description": "hashlib",
        "detail": "hashlib",
        "documentation": {}
    },
    {
        "label": "sha1",
        "importPath": "hashlib",
        "description": "hashlib",
        "isExtraImport": true,
        "detail": "hashlib",
        "documentation": {}
    },
    {
        "label": "datetime",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "datetime",
        "description": "datetime",
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timedelta",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "date",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timedelta",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "date",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "date",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "time",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timezone",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "jwt",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "jwt",
        "description": "jwt",
        "detail": "jwt",
        "documentation": {}
    },
    {
        "label": "sys",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sys",
        "description": "sys",
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "xml.dom.minidom",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "xml.dom.minidom",
        "description": "xml.dom.minidom",
        "detail": "xml.dom.minidom",
        "documentation": {}
    },
    {
        "label": "xml.etree.ElementTree",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "xml.etree.ElementTree",
        "description": "xml.etree.ElementTree",
        "detail": "xml.etree.ElementTree",
        "documentation": {}
    },
    {
        "label": "zip_longest",
        "importPath": "itertools",
        "description": "itertools",
        "isExtraImport": true,
        "detail": "itertools",
        "documentation": {}
    },
    {
        "label": "islice",
        "importPath": "itertools",
        "description": "itertools",
        "isExtraImport": true,
        "detail": "itertools",
        "documentation": {}
    },
    {
        "label": "dicttoxml",
        "importPath": "dicttoxml",
        "description": "dicttoxml",
        "isExtraImport": true,
        "detail": "dicttoxml",
        "documentation": {}
    },
    {
        "label": "etree",
        "importPath": "lxml",
        "description": "lxml",
        "isExtraImport": true,
        "detail": "lxml",
        "documentation": {}
    },
    {
        "label": "text_type",
        "importPath": "six",
        "description": "six",
        "isExtraImport": true,
        "detail": "six",
        "documentation": {}
    },
    {
        "label": "binary_type",
        "importPath": "six",
        "description": "six",
        "isExtraImport": true,
        "detail": "six",
        "documentation": {}
    },
    {
        "label": "text_type",
        "importPath": "six",
        "description": "six",
        "isExtraImport": true,
        "detail": "six",
        "documentation": {}
    },
    {
        "label": "Xml2Dict",
        "importPath": "custard.core.xml2dict",
        "description": "custard.core.xml2dict",
        "isExtraImport": true,
        "detail": "custard.core.xml2dict",
        "documentation": {}
    },
    {
        "label": "BatchTask",
        "importPath": "custard.cron",
        "description": "custard.cron",
        "isExtraImport": true,
        "detail": "custard.cron",
        "documentation": {}
    },
    {
        "label": "time",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "time",
        "description": "time",
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "perf_counter",
        "importPath": "time",
        "description": "time",
        "isExtraImport": true,
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "csv",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "csv",
        "description": "csv",
        "detail": "csv",
        "documentation": {}
    },
    {
        "label": "custard",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "custard",
        "description": "custard",
        "detail": "custard",
        "documentation": {}
    },
    {
        "label": "kaptcha",
        "importPath": "custard",
        "description": "custard",
        "isExtraImport": true,
        "detail": "custard",
        "documentation": {}
    },
    {
        "label": "kaptcha",
        "importPath": "custard",
        "description": "custard",
        "isExtraImport": true,
        "detail": "custard",
        "documentation": {}
    },
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "platform",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "platform",
        "description": "platform",
        "detail": "platform",
        "documentation": {}
    },
    {
        "label": "yaml",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "yaml",
        "description": "yaml",
        "detail": "yaml",
        "documentation": {}
    },
    {
        "label": "DataHand",
        "importPath": "custard.core.processor",
        "description": "custard.core.processor",
        "isExtraImport": true,
        "detail": "custard.core.processor",
        "documentation": {}
    },
    {
        "label": "bisect",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "bisect",
        "description": "bisect",
        "detail": "bisect",
        "documentation": {}
    },
    {
        "label": "timegm",
        "importPath": "calendar",
        "description": "calendar",
        "isExtraImport": true,
        "detail": "calendar",
        "documentation": {}
    },
    {
        "label": "tzutc",
        "importPath": "dateutil.tz",
        "description": "dateutil.tz",
        "isExtraImport": true,
        "detail": "dateutil.tz",
        "documentation": {}
    },
    {
        "label": "copy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "copy",
        "description": "copy",
        "detail": "copy",
        "documentation": {}
    },
    {
        "label": "struct",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "struct",
        "description": "struct",
        "detail": "struct",
        "documentation": {}
    },
    {
        "label": "abstractmethod",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "ABC",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "abstractmethod",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "Random",
        "importPath": "Crypto",
        "description": "Crypto",
        "isExtraImport": true,
        "detail": "Crypto",
        "documentation": {}
    },
    {
        "label": "AES",
        "importPath": "Crypto.Cipher",
        "description": "Crypto.Cipher",
        "isExtraImport": true,
        "detail": "Crypto.Cipher",
        "documentation": {}
    },
    {
        "label": "PKCS1_OAEP",
        "importPath": "Crypto.Cipher",
        "description": "Crypto.Cipher",
        "isExtraImport": true,
        "detail": "Crypto.Cipher",
        "documentation": {}
    },
    {
        "label": "PKCS1_v1_5",
        "importPath": "Crypto.Cipher",
        "description": "Crypto.Cipher",
        "isExtraImport": true,
        "detail": "Crypto.Cipher",
        "documentation": {}
    },
    {
        "label": "RSA",
        "importPath": "Crypto.PublicKey",
        "description": "Crypto.PublicKey",
        "isExtraImport": true,
        "detail": "Crypto.PublicKey",
        "documentation": {}
    },
    {
        "label": "Counter",
        "importPath": "Crypto.Util",
        "description": "Crypto.Util",
        "isExtraImport": true,
        "detail": "Crypto.Util",
        "documentation": {}
    },
    {
        "label": "uuid",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "uuid",
        "description": "uuid",
        "detail": "uuid",
        "documentation": {}
    },
    {
        "label": "pymysql",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pymysql",
        "description": "pymysql",
        "detail": "pymysql",
        "documentation": {}
    },
    {
        "label": "traceback",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "traceback",
        "description": "traceback",
        "detail": "traceback",
        "documentation": {}
    },
    {
        "label": "FileNotFoundError",
        "importPath": "custard.script.compat",
        "description": "custard.script.compat",
        "isExtraImport": true,
        "detail": "custard.script.compat",
        "documentation": {}
    },
    {
        "label": "basestring",
        "importPath": "custard.script.compat",
        "description": "custard.script.compat",
        "isExtraImport": true,
        "detail": "custard.script.compat",
        "documentation": {}
    },
    {
        "label": "builtin_str",
        "importPath": "custard.script.compat",
        "description": "custard.script.compat",
        "isExtraImport": true,
        "detail": "custard.script.compat",
        "documentation": {}
    },
    {
        "label": "numeric_types",
        "importPath": "custard.script.compat",
        "description": "custard.script.compat",
        "isExtraImport": true,
        "detail": "custard.script.compat",
        "documentation": {}
    },
    {
        "label": "str",
        "importPath": "custard.script.compat",
        "description": "custard.script.compat",
        "isExtraImport": true,
        "detail": "custard.script.compat",
        "documentation": {}
    },
    {
        "label": "stdev",
        "importPath": "statistics",
        "description": "statistics",
        "isExtraImport": true,
        "detail": "statistics",
        "documentation": {}
    },
    {
        "label": "fmean",
        "importPath": "statistics",
        "description": "statistics",
        "isExtraImport": true,
        "detail": "statistics",
        "documentation": {}
    },
    {
        "label": "importlib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "importlib",
        "description": "importlib",
        "detail": "importlib",
        "documentation": {}
    },
    {
        "label": "inspect",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "inspect",
        "description": "inspect",
        "detail": "inspect",
        "documentation": {}
    },
    {
        "label": "istraceback",
        "importPath": "inspect",
        "description": "inspect",
        "isExtraImport": true,
        "detail": "inspect",
        "documentation": {}
    },
    {
        "label": "BytesIO",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "Image",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "ImageDraw",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "ImageFont",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "ImageFilter",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "conint",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "create_model",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "conint",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "conint",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "Request",
        "importPath": "starlette.requests",
        "description": "starlette.requests",
        "isExtraImport": true,
        "detail": "starlette.requests",
        "documentation": {}
    },
    {
        "label": "Response",
        "importPath": "starlette.responses",
        "description": "starlette.responses",
        "isExtraImport": true,
        "detail": "starlette.responses",
        "documentation": {}
    },
    {
        "label": "status",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "Depends",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "FastAPI",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "Request",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "Response",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "Query",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "Query",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "Query",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "Depends",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "FastAPI",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "Depends",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "FastAPI",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "Depends",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "FastAPI",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "utilities",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "utilities",
        "description": "utilities",
        "detail": "utilities",
        "documentation": {}
    },
    {
        "label": "math",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "math",
        "description": "math",
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "arrays",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "arrays",
        "description": "arrays",
        "detail": "arrays",
        "documentation": {}
    },
    {
        "label": "ctypes",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "ctypes",
        "description": "ctypes",
        "detail": "ctypes",
        "documentation": {}
    },
    {
        "label": "sysconfig",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sysconfig",
        "description": "sysconfig",
        "detail": "sysconfig",
        "documentation": {}
    },
    {
        "label": "IntEnum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "requests",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "requests",
        "description": "requests",
        "detail": "requests",
        "documentation": {}
    },
    {
        "label": "contextmanager",
        "importPath": "contextlib",
        "description": "contextlib",
        "isExtraImport": true,
        "detail": "contextlib",
        "documentation": {}
    },
    {
        "label": "suppress",
        "importPath": "contextlib",
        "description": "contextlib",
        "isExtraImport": true,
        "detail": "contextlib",
        "documentation": {}
    },
    {
        "label": "ContextVar",
        "importPath": "contextvars",
        "description": "contextvars",
        "isExtraImport": true,
        "detail": "contextvars",
        "documentation": {}
    },
    {
        "label": "get_parameterless_sub_dependant",
        "importPath": "fastapi.dependencies.utils",
        "description": "fastapi.dependencies.utils",
        "isExtraImport": true,
        "detail": "fastapi.dependencies.utils",
        "documentation": {}
    },
    {
        "label": "lenient_issubclass",
        "importPath": "fastapi.dependencies.utils",
        "description": "fastapi.dependencies.utils",
        "isExtraImport": true,
        "detail": "fastapi.dependencies.utils",
        "documentation": {}
    },
    {
        "label": "APIRoute",
        "importPath": "fastapi.routing",
        "description": "fastapi.routing",
        "isExtraImport": true,
        "detail": "fastapi.routing",
        "documentation": {}
    },
    {
        "label": "APIRouter",
        "importPath": "fastapi.routing",
        "description": "fastapi.routing",
        "isExtraImport": true,
        "detail": "fastapi.routing",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "func",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "select",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "Column",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "Integer",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "String",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "Column",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "Integer",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "String",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "create_engine",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "asdict",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "GenericModel",
        "importPath": "pydantic.generics",
        "description": "pydantic.generics",
        "isExtraImport": true,
        "detail": "pydantic.generics",
        "documentation": {}
    },
    {
        "label": "conint",
        "importPath": "pydantic.types",
        "description": "pydantic.types",
        "isExtraImport": true,
        "detail": "pydantic.types",
        "documentation": {}
    },
    {
        "label": "conint",
        "importPath": "pydantic.types",
        "description": "pydantic.types",
        "isExtraImport": true,
        "detail": "pydantic.types",
        "documentation": {}
    },
    {
        "label": "Query",
        "importPath": "sqlalchemy.orm",
        "description": "sqlalchemy.orm",
        "isExtraImport": true,
        "detail": "sqlalchemy.orm",
        "documentation": {}
    },
    {
        "label": "sessionmaker",
        "importPath": "sqlalchemy.orm",
        "description": "sqlalchemy.orm",
        "isExtraImport": true,
        "detail": "sqlalchemy.orm",
        "documentation": {}
    },
    {
        "label": "Session",
        "importPath": "sqlalchemy.orm",
        "description": "sqlalchemy.orm",
        "isExtraImport": true,
        "detail": "sqlalchemy.orm",
        "documentation": {}
    },
    {
        "label": "sessionmaker",
        "importPath": "sqlalchemy.orm",
        "description": "sqlalchemy.orm",
        "isExtraImport": true,
        "detail": "sqlalchemy.orm",
        "documentation": {}
    },
    {
        "label": "Select",
        "importPath": "sqlalchemy.sql",
        "description": "sqlalchemy.sql",
        "isExtraImport": true,
        "detail": "sqlalchemy.sql",
        "documentation": {}
    },
    {
        "label": "ast",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "ast",
        "description": "ast",
        "detail": "ast",
        "documentation": {}
    },
    {
        "label": "logger",
        "importPath": "loguru",
        "description": "loguru",
        "isExtraImport": true,
        "detail": "loguru",
        "documentation": {}
    },
    {
        "label": "exceptions",
        "importPath": "custard.expect",
        "description": "custard.expect",
        "isExtraImport": true,
        "detail": "custard.expect",
        "documentation": {}
    },
    {
        "label": "ExcContextManager",
        "importPath": "custard.expect",
        "description": "custard.expect",
        "isExtraImport": true,
        "detail": "custard.expect",
        "documentation": {}
    },
    {
        "label": "types",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "types",
        "description": "types",
        "detail": "types",
        "documentation": {}
    },
    {
        "label": "operator",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "operator",
        "description": "operator",
        "detail": "operator",
        "documentation": {}
    },
    {
        "label": "text",
        "importPath": "custard.utils",
        "description": "custard.utils",
        "isExtraImport": true,
        "detail": "custard.utils",
        "documentation": {}
    },
    {
        "label": "unicodedata",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "unicodedata",
        "description": "unicodedata",
        "detail": "unicodedata",
        "documentation": {}
    },
    {
        "label": "aiohttp",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "aiohttp",
        "description": "aiohttp",
        "detail": "aiohttp",
        "documentation": {}
    },
    {
        "label": "alru_cache",
        "importPath": "custard.cache.async_lru",
        "description": "custard.cache.async_lru",
        "isExtraImport": true,
        "detail": "custard.cache.async_lru",
        "documentation": {}
    },
    {
        "label": "RSAProvider",
        "importPath": "custard.crypto",
        "description": "custard.crypto",
        "isExtraImport": true,
        "detail": "custard.crypto",
        "documentation": {}
    },
    {
        "label": "unittest",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "unittest",
        "description": "unittest",
        "detail": "unittest",
        "documentation": {}
    },
    {
        "label": "handle_exception",
        "importPath": "custard.expect.record",
        "description": "custard.expect.record",
        "isExtraImport": true,
        "detail": "custard.expect.record",
        "documentation": {}
    },
    {
        "label": "keep_circulating",
        "importPath": "custard.expect.spacer",
        "description": "custard.expect.spacer",
        "isExtraImport": true,
        "detail": "custard.expect.spacer",
        "documentation": {}
    },
    {
        "label": "bind_run_many_times",
        "importPath": "custard.function",
        "description": "custard.function",
        "isExtraImport": true,
        "detail": "custard.function",
        "documentation": {}
    },
    {
        "label": "where_is_it_called",
        "importPath": "custard.function",
        "description": "custard.function",
        "isExtraImport": true,
        "detail": "custard.function",
        "documentation": {}
    },
    {
        "label": "singleton_lock",
        "importPath": "custard.lock",
        "description": "custard.lock",
        "isExtraImport": true,
        "detail": "custard.lock",
        "documentation": {}
    },
    {
        "label": "TimerContextManager",
        "importPath": "custard.time",
        "description": "custard.time",
        "isExtraImport": true,
        "detail": "custard.time",
        "documentation": {}
    },
    {
        "label": "calc_time",
        "importPath": "custard.time",
        "description": "custard.time",
        "isExtraImport": true,
        "detail": "custard.time",
        "documentation": {}
    },
    {
        "label": "bind_timeout",
        "importPath": "custard.time",
        "description": "custard.time",
        "isExtraImport": true,
        "detail": "custard.time",
        "documentation": {}
    },
    {
        "label": "TimerContextManager",
        "importPath": "custard.time",
        "description": "custard.time",
        "isExtraImport": true,
        "detail": "custard.time",
        "documentation": {}
    },
    {
        "label": "calc_time",
        "importPath": "custard.time",
        "description": "custard.time",
        "isExtraImport": true,
        "detail": "custard.time",
        "documentation": {}
    },
    {
        "label": "MySqlInspect",
        "importPath": "custard.db",
        "description": "custard.db",
        "isExtraImport": true,
        "detail": "custard.db",
        "documentation": {}
    },
    {
        "label": "MysqlUtil",
        "importPath": "custard.db ",
        "description": "custard.db ",
        "isExtraImport": true,
        "detail": "custard.db ",
        "documentation": {}
    },
    {
        "label": "hitfilter",
        "importPath": "custard.hitfilter",
        "description": "custard.hitfilter",
        "isExtraImport": true,
        "detail": "custard.hitfilter",
        "documentation": {}
    },
    {
        "label": "unittest.mock",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "jsonlogger",
        "importPath": "custard.json",
        "description": "custard.json",
        "isExtraImport": true,
        "detail": "custard.json",
        "documentation": {}
    },
    {
        "label": "aioredis",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "aioredis",
        "description": "aioredis",
        "detail": "aioredis",
        "documentation": {}
    },
    {
        "label": "uvicorn",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "uvicorn",
        "description": "uvicorn",
        "detail": "uvicorn",
        "documentation": {}
    },
    {
        "label": "Limiter",
        "importPath": "custard.limiter",
        "description": "custard.limiter",
        "isExtraImport": true,
        "detail": "custard.limiter",
        "documentation": {}
    },
    {
        "label": "RateLimiter",
        "importPath": "custard.limiter.depends",
        "description": "custard.limiter.depends",
        "isExtraImport": true,
        "detail": "custard.limiter.depends",
        "documentation": {}
    },
    {
        "label": "pprint",
        "importPath": "pprint",
        "description": "pprint",
        "isExtraImport": true,
        "detail": "pprint",
        "documentation": {}
    },
    {
        "label": "Mock",
        "importPath": "custard.mock",
        "description": "custard.mock",
        "isExtraImport": true,
        "detail": "custard.mock",
        "documentation": {}
    },
    {
        "label": "AsyncSession",
        "importPath": "sqlalchemy.ext.asyncio",
        "description": "sqlalchemy.ext.asyncio",
        "isExtraImport": true,
        "detail": "sqlalchemy.ext.asyncio",
        "documentation": {}
    },
    {
        "label": "create_async_engine",
        "importPath": "sqlalchemy.ext.asyncio",
        "description": "sqlalchemy.ext.asyncio",
        "isExtraImport": true,
        "detail": "sqlalchemy.ext.asyncio",
        "documentation": {}
    },
    {
        "label": "declarative_base",
        "importPath": "sqlalchemy.ext.declarative",
        "description": "sqlalchemy.ext.declarative",
        "isExtraImport": true,
        "detail": "sqlalchemy.ext.declarative",
        "documentation": {}
    },
    {
        "label": "declarative_base",
        "importPath": "sqlalchemy.ext.declarative",
        "description": "sqlalchemy.ext.declarative",
        "isExtraImport": true,
        "detail": "sqlalchemy.ext.declarative",
        "documentation": {}
    },
    {
        "label": "select",
        "importPath": "sqlalchemy.future",
        "description": "sqlalchemy.future",
        "isExtraImport": true,
        "detail": "sqlalchemy.future",
        "documentation": {}
    },
    {
        "label": "LimitOffsetPage",
        "importPath": "custard.pagination",
        "description": "custard.pagination",
        "isExtraImport": true,
        "detail": "custard.pagination",
        "documentation": {}
    },
    {
        "label": "Page",
        "importPath": "custard.pagination",
        "description": "custard.pagination",
        "isExtraImport": true,
        "detail": "custard.pagination",
        "documentation": {}
    },
    {
        "label": "paginate",
        "importPath": "custard.pagination",
        "description": "custard.pagination",
        "isExtraImport": true,
        "detail": "custard.pagination",
        "documentation": {}
    },
    {
        "label": "add_pagination",
        "importPath": "custard.pagination",
        "description": "custard.pagination",
        "isExtraImport": true,
        "detail": "custard.pagination",
        "documentation": {}
    },
    {
        "label": "LimitOffsetPage",
        "importPath": "custard.pagination",
        "description": "custard.pagination",
        "isExtraImport": true,
        "detail": "custard.pagination",
        "documentation": {}
    },
    {
        "label": "Page",
        "importPath": "custard.pagination",
        "description": "custard.pagination",
        "isExtraImport": true,
        "detail": "custard.pagination",
        "documentation": {}
    },
    {
        "label": "add_pagination",
        "importPath": "custard.pagination",
        "description": "custard.pagination",
        "isExtraImport": true,
        "detail": "custard.pagination",
        "documentation": {}
    },
    {
        "label": "paginate",
        "importPath": "custard.pagination.sync_sqlalchemy",
        "description": "custard.pagination.sync_sqlalchemy",
        "isExtraImport": true,
        "detail": "custard.pagination.sync_sqlalchemy",
        "documentation": {}
    },
    {
        "label": "warnings",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "warnings",
        "description": "warnings",
        "detail": "warnings",
        "documentation": {}
    },
    {
        "label": "parse",
        "importPath": "urllib",
        "description": "urllib",
        "isExtraImport": true,
        "detail": "urllib",
        "documentation": {}
    },
    {
        "label": "utils",
        "importPath": "custard.swagger",
        "description": "custard.swagger",
        "isExtraImport": true,
        "detail": "custard.swagger",
        "documentation": {}
    },
    {
        "label": "swagger_parse",
        "importPath": "custard.swagger",
        "description": "custard.swagger",
        "isExtraImport": true,
        "detail": "custard.swagger",
        "documentation": {}
    },
    {
        "label": "MsHelper",
        "importPath": "custard.core.factory",
        "description": "custard.core.factory",
        "isExtraImport": true,
        "detail": "custard.core.factory",
        "documentation": {}
    },
    {
        "label": "JSONDecodeError",
        "importPath": "simplejson",
        "description": "simplejson",
        "isExtraImport": true,
        "detail": "simplejson",
        "documentation": {}
    },
    {
        "label": "firefox",
        "importPath": "custard.core.useragent",
        "description": "custard.core.useragent",
        "isExtraImport": true,
        "detail": "custard.core.useragent",
        "documentation": {}
    },
    {
        "label": "safari",
        "importPath": "custard.core.useragent",
        "description": "custard.core.useragent",
        "isExtraImport": true,
        "detail": "custard.core.useragent",
        "documentation": {}
    },
    {
        "label": "internet_explorer",
        "importPath": "custard.core.useragent",
        "description": "custard.core.useragent",
        "isExtraImport": true,
        "detail": "custard.core.useragent",
        "documentation": {}
    },
    {
        "label": "opera",
        "importPath": "custard.core.useragent",
        "description": "custard.core.useragent",
        "isExtraImport": true,
        "detail": "custard.core.useragent",
        "documentation": {}
    },
    {
        "label": "linux_platform_token",
        "importPath": "custard.core.useragent",
        "description": "custard.core.useragent",
        "isExtraImport": true,
        "detail": "custard.core.useragent",
        "documentation": {}
    },
    {
        "label": "mac_platform_token",
        "importPath": "custard.core.useragent",
        "description": "custard.core.useragent",
        "isExtraImport": true,
        "detail": "custard.core.useragent",
        "documentation": {}
    },
    {
        "label": "win_platform_token",
        "importPath": "custard.core.useragent",
        "description": "custard.core.useragent",
        "isExtraImport": true,
        "detail": "custard.core.useragent",
        "documentation": {}
    },
    {
        "label": "android_platform_token",
        "importPath": "custard.core.useragent",
        "description": "custard.core.useragent",
        "isExtraImport": true,
        "detail": "custard.core.useragent",
        "documentation": {}
    },
    {
        "label": "unpartial",
        "kind": 2,
        "importPath": "custard.cache.async_lru",
        "description": "custard.cache.async_lru",
        "peekOfCode": "def unpartial(fn):\n    while hasattr(fn, \"func\"):\n        fn = fn.func\n    return fn\ndef _done_callback(fut, task):\n    if task.cancelled():\n        fut.cancel()\n        return\n    exc = task.exception()\n    if exc is not None:",
        "detail": "custard.cache.async_lru",
        "documentation": {}
    },
    {
        "label": "alru_cache",
        "kind": 2,
        "importPath": "custard.cache.async_lru",
        "description": "custard.cache.async_lru",
        "peekOfCode": "def alru_cache(\n        fn=None,\n        maxsize=128,\n        typed=False,\n        *,\n        cache_exceptions=True,\n):\n    def wrapper(fn):\n        _origin = unpartial(fn)\n        if not asyncio.iscoroutinefunction(_origin):",
        "detail": "custard.cache.async_lru",
        "documentation": {}
    },
    {
        "label": "RedisClient",
        "kind": 6,
        "importPath": "custard.cache.redis",
        "description": "custard.cache.redis",
        "peekOfCode": "class RedisClient(object):\n    \"\"\"\n    py2.7, py3.7\n    \"\"\"\n    mutex = threading.Lock()  # gevent \n    config = None\n    connection_pool = None\n    connection_client = None\n    def __init__(self, config):\n        \"\"\"",
        "detail": "custard.cache.redis",
        "documentation": {}
    },
    {
        "label": "unidecode",
        "kind": 2,
        "importPath": "custard.core.decode",
        "description": "custard.core.decode",
        "peekOfCode": "def unidecode(txt: str) -> str:\n    \"\"\"\n    Args:\n        txt:\n    Returns:\n    Examples:\n        >>> print(unidecode(\"ah \"))\n    \"\"\"\n    chars = \"\"\n    for ch in txt:",
        "detail": "custard.core.decode",
        "documentation": {}
    },
    {
        "label": "codes",
        "kind": 5,
        "importPath": "custard.core.decode",
        "description": "custard.core.decode",
        "peekOfCode": "codes = (\n    \"\\x00\",\n    \"\\x01\",\n    \"\\x02\",\n    \"\\x03\",\n    \"\\x04\",\n    \"\\x05\",\n    \"\\x06\",\n    \"\\x07\",\n    \"\\x08\",",
        "detail": "custard.core.decode",
        "documentation": {}
    },
    {
        "label": "MockHelper",
        "kind": 6,
        "importPath": "custard.core.factory",
        "description": "custard.core.factory",
        "peekOfCode": "class MockHelper:\n    @staticmethod\n    def hans2pinyin(hans, style='A'):\n        \"\"\"\n        \n        Args:\n            hans: \n            style:  A F\n        Returns:\n        Examples:",
        "detail": "custard.core.factory",
        "documentation": {}
    },
    {
        "label": "AutoVivification",
        "kind": 6,
        "importPath": "custard.core.factory",
        "description": "custard.core.factory",
        "peekOfCode": "class AutoVivification(dict):\n  def __getitem__(self, item):\n    try:\n      return dict.__getitem__(self, item)\n    except KeyError:\n      value = self[item] = type(self)()\n    return value\nclass MsHelper(object):\n    GLOBAL_PAGE_INDEX = [\"page_index\" \"pageindex\"]\n    GLOBAL_PAGE_SIZE = [\"page_size\" \"pagesize\"]",
        "detail": "custard.core.factory",
        "documentation": {}
    },
    {
        "label": "MsHelper",
        "kind": 6,
        "importPath": "custard.core.factory",
        "description": "custard.core.factory",
        "peekOfCode": "class MsHelper(object):\n    GLOBAL_PAGE_INDEX = [\"page_index\" \"pageindex\"]\n    GLOBAL_PAGE_SIZE = [\"page_size\" \"pagesize\"]\n    @classmethod\n    def __property__(cls, prop):\n        \"\"\"\n        \n        Args:\n            prop:\n        Returns:",
        "detail": "custard.core.factory",
        "documentation": {}
    },
    {
        "label": "fake",
        "kind": 5,
        "importPath": "custard.core.factory",
        "description": "custard.core.factory",
        "peekOfCode": "fake = Faker(['zh_CN'])\nclass MockHelper:\n    @staticmethod\n    def hans2pinyin(hans, style='A'):\n        \"\"\"\n        \n        Args:\n            hans: \n            style:  A F\n        Returns:",
        "detail": "custard.core.factory",
        "documentation": {}
    },
    {
        "label": "Kerberos",
        "kind": 6,
        "importPath": "custard.core.kerberos",
        "description": "custard.core.kerberos",
        "peekOfCode": "class Kerberos:\n    @staticmethod\n    def jwt_encode(secret_key, target_value, seconds):\n        \"\"\"\n        jwt\n        Args:\n            secret_key:\n            target_value:\n            seconds:\n        Returns:",
        "detail": "custard.core.kerberos",
        "documentation": {}
    },
    {
        "label": "DataHand",
        "kind": 6,
        "importPath": "custard.core.processor",
        "description": "custard.core.processor",
        "peekOfCode": "class DataHand:\n    @staticmethod\n    def to_str(variable):\n        \"\"\"\"\"\"\n        if isinstance(variable, text_type) or isinstance(variable, binary_type):\n            return variable\n        return str(variable)\n    @staticmethod\n    def to_unicode(variable):\n        \"\"\"unicode\"\"\"",
        "detail": "custard.core.processor",
        "documentation": {}
    },
    {
        "label": "HtmlHand",
        "kind": 6,
        "importPath": "custard.core.processor",
        "description": "custard.core.processor",
        "peekOfCode": "class HtmlHand:\n    @staticmethod\n    def find(res, xpath, index) -> Text:\n        \"\"\"\n        html\n        :param res:\n        :param xpath:\n        :param index:\n        :return:\n        \"\"\"",
        "detail": "custard.core.processor",
        "documentation": {}
    },
    {
        "label": "JsonHand",
        "kind": 6,
        "importPath": "custard.core.processor",
        "description": "custard.core.processor",
        "peekOfCode": "class JsonHand:\n    @staticmethod\n    def normalize(filter):\n        \"\"\"\n        normalize the path expression; outside JsonHand to allow testings\n        :param filter: \n        :return:\n        \"\"\"\n        subx = []\n        # replace index/filter expressions with placeholders",
        "detail": "custard.core.processor",
        "documentation": {}
    },
    {
        "label": "SINGLE_UPLOAD_LENGTH",
        "kind": 5,
        "importPath": "custard.core.processor",
        "description": "custard.core.processor",
        "peekOfCode": "SINGLE_UPLOAD_LENGTH = 5 * 1024 * 1024 * 1024  # 5GB\nDEFAULT_CHUNK_SIZE = 1024 * 1024  # MD5,1MB\nclass DataHand:\n    @staticmethod\n    def to_str(variable):\n        \"\"\"\"\"\"\n        if isinstance(variable, text_type) or isinstance(variable, binary_type):\n            return variable\n        return str(variable)\n    @staticmethod",
        "detail": "custard.core.processor",
        "documentation": {}
    },
    {
        "label": "DEFAULT_CHUNK_SIZE",
        "kind": 5,
        "importPath": "custard.core.processor",
        "description": "custard.core.processor",
        "peekOfCode": "DEFAULT_CHUNK_SIZE = 1024 * 1024  # MD5,1MB\nclass DataHand:\n    @staticmethod\n    def to_str(variable):\n        \"\"\"\"\"\"\n        if isinstance(variable, text_type) or isinstance(variable, binary_type):\n            return variable\n        return str(variable)\n    @staticmethod\n    def to_unicode(variable):",
        "detail": "custard.core.processor",
        "documentation": {}
    },
    {
        "label": "RegEx",
        "kind": 6,
        "importPath": "custard.core.regular",
        "description": "custard.core.regular",
        "peekOfCode": "class RegEx:\n    @staticmethod\n    def match_email(context: Any) -> bool:\n        \"\"\"\n        \n        Args:\n            context:\n        Returns:\n        Examples:\n            >>> examples = [\"test@163.com\",\"test163.com\",\"155555@qq.com\"]",
        "detail": "custard.core.regular",
        "documentation": {}
    },
    {
        "label": "snowflake_to_timestamp",
        "kind": 2,
        "importPath": "custard.core.snowflake",
        "description": "custard.core.snowflake",
        "peekOfCode": "def snowflake_to_timestamp(_id):\n    _id = _id >> 22  # strip the lower 22 bits\n    _id += twepoch  # adjust for twitter epoch\n    _id = _id / 1000  # convert from milliseconds to seconds\n    return _id\ndef generator(worker_id, data_center_id, sleep=lambda x: time.sleep(x / 1000.0)):\n    assert 0 <= worker_id <= max_worker_id\n    assert 0 <= data_center_id <= max_data_center_id\n    last_timestamp = -1\n    sequence = 0",
        "detail": "custard.core.snowflake",
        "documentation": {}
    },
    {
        "label": "generator",
        "kind": 2,
        "importPath": "custard.core.snowflake",
        "description": "custard.core.snowflake",
        "peekOfCode": "def generator(worker_id, data_center_id, sleep=lambda x: time.sleep(x / 1000.0)):\n    assert 0 <= worker_id <= max_worker_id\n    assert 0 <= data_center_id <= max_data_center_id\n    last_timestamp = -1\n    sequence = 0\n    while True:\n        timestamp = int(time.time() * 1000)\n        if last_timestamp > timestamp:\n            print(\"clock is moving backwards. waiting until %i\" % last_timestamp)\n            sleep(last_timestamp - timestamp)",
        "detail": "custard.core.snowflake",
        "documentation": {}
    },
    {
        "label": "twepoch",
        "kind": 5,
        "importPath": "custard.core.snowflake",
        "description": "custard.core.snowflake",
        "peekOfCode": "twepoch = 1292978355588\nworker_id_bits = 5\ndata_center_id_bits = 5\nmax_worker_id = -1 ^ (-1 << worker_id_bits)\nmax_data_center_id = -1 ^ (-1 << data_center_id_bits)\nsequence_bits = 12\nworker_id_shift = sequence_bits\ndata_center_id_shift = sequence_bits + worker_id_bits\ntimestamp_left_shift = sequence_bits + worker_id_bits + data_center_id_bits\nsequence_mask = -1 ^ (-1 << sequence_bits)",
        "detail": "custard.core.snowflake",
        "documentation": {}
    },
    {
        "label": "worker_id_bits",
        "kind": 5,
        "importPath": "custard.core.snowflake",
        "description": "custard.core.snowflake",
        "peekOfCode": "worker_id_bits = 5\ndata_center_id_bits = 5\nmax_worker_id = -1 ^ (-1 << worker_id_bits)\nmax_data_center_id = -1 ^ (-1 << data_center_id_bits)\nsequence_bits = 12\nworker_id_shift = sequence_bits\ndata_center_id_shift = sequence_bits + worker_id_bits\ntimestamp_left_shift = sequence_bits + worker_id_bits + data_center_id_bits\nsequence_mask = -1 ^ (-1 << sequence_bits)\ndef snowflake_to_timestamp(_id):",
        "detail": "custard.core.snowflake",
        "documentation": {}
    },
    {
        "label": "data_center_id_bits",
        "kind": 5,
        "importPath": "custard.core.snowflake",
        "description": "custard.core.snowflake",
        "peekOfCode": "data_center_id_bits = 5\nmax_worker_id = -1 ^ (-1 << worker_id_bits)\nmax_data_center_id = -1 ^ (-1 << data_center_id_bits)\nsequence_bits = 12\nworker_id_shift = sequence_bits\ndata_center_id_shift = sequence_bits + worker_id_bits\ntimestamp_left_shift = sequence_bits + worker_id_bits + data_center_id_bits\nsequence_mask = -1 ^ (-1 << sequence_bits)\ndef snowflake_to_timestamp(_id):\n    _id = _id >> 22  # strip the lower 22 bits",
        "detail": "custard.core.snowflake",
        "documentation": {}
    },
    {
        "label": "max_worker_id",
        "kind": 5,
        "importPath": "custard.core.snowflake",
        "description": "custard.core.snowflake",
        "peekOfCode": "max_worker_id = -1 ^ (-1 << worker_id_bits)\nmax_data_center_id = -1 ^ (-1 << data_center_id_bits)\nsequence_bits = 12\nworker_id_shift = sequence_bits\ndata_center_id_shift = sequence_bits + worker_id_bits\ntimestamp_left_shift = sequence_bits + worker_id_bits + data_center_id_bits\nsequence_mask = -1 ^ (-1 << sequence_bits)\ndef snowflake_to_timestamp(_id):\n    _id = _id >> 22  # strip the lower 22 bits\n    _id += twepoch  # adjust for twitter epoch",
        "detail": "custard.core.snowflake",
        "documentation": {}
    },
    {
        "label": "max_data_center_id",
        "kind": 5,
        "importPath": "custard.core.snowflake",
        "description": "custard.core.snowflake",
        "peekOfCode": "max_data_center_id = -1 ^ (-1 << data_center_id_bits)\nsequence_bits = 12\nworker_id_shift = sequence_bits\ndata_center_id_shift = sequence_bits + worker_id_bits\ntimestamp_left_shift = sequence_bits + worker_id_bits + data_center_id_bits\nsequence_mask = -1 ^ (-1 << sequence_bits)\ndef snowflake_to_timestamp(_id):\n    _id = _id >> 22  # strip the lower 22 bits\n    _id += twepoch  # adjust for twitter epoch\n    _id = _id / 1000  # convert from milliseconds to seconds",
        "detail": "custard.core.snowflake",
        "documentation": {}
    },
    {
        "label": "sequence_bits",
        "kind": 5,
        "importPath": "custard.core.snowflake",
        "description": "custard.core.snowflake",
        "peekOfCode": "sequence_bits = 12\nworker_id_shift = sequence_bits\ndata_center_id_shift = sequence_bits + worker_id_bits\ntimestamp_left_shift = sequence_bits + worker_id_bits + data_center_id_bits\nsequence_mask = -1 ^ (-1 << sequence_bits)\ndef snowflake_to_timestamp(_id):\n    _id = _id >> 22  # strip the lower 22 bits\n    _id += twepoch  # adjust for twitter epoch\n    _id = _id / 1000  # convert from milliseconds to seconds\n    return _id",
        "detail": "custard.core.snowflake",
        "documentation": {}
    },
    {
        "label": "worker_id_shift",
        "kind": 5,
        "importPath": "custard.core.snowflake",
        "description": "custard.core.snowflake",
        "peekOfCode": "worker_id_shift = sequence_bits\ndata_center_id_shift = sequence_bits + worker_id_bits\ntimestamp_left_shift = sequence_bits + worker_id_bits + data_center_id_bits\nsequence_mask = -1 ^ (-1 << sequence_bits)\ndef snowflake_to_timestamp(_id):\n    _id = _id >> 22  # strip the lower 22 bits\n    _id += twepoch  # adjust for twitter epoch\n    _id = _id / 1000  # convert from milliseconds to seconds\n    return _id\ndef generator(worker_id, data_center_id, sleep=lambda x: time.sleep(x / 1000.0)):",
        "detail": "custard.core.snowflake",
        "documentation": {}
    },
    {
        "label": "data_center_id_shift",
        "kind": 5,
        "importPath": "custard.core.snowflake",
        "description": "custard.core.snowflake",
        "peekOfCode": "data_center_id_shift = sequence_bits + worker_id_bits\ntimestamp_left_shift = sequence_bits + worker_id_bits + data_center_id_bits\nsequence_mask = -1 ^ (-1 << sequence_bits)\ndef snowflake_to_timestamp(_id):\n    _id = _id >> 22  # strip the lower 22 bits\n    _id += twepoch  # adjust for twitter epoch\n    _id = _id / 1000  # convert from milliseconds to seconds\n    return _id\ndef generator(worker_id, data_center_id, sleep=lambda x: time.sleep(x / 1000.0)):\n    assert 0 <= worker_id <= max_worker_id",
        "detail": "custard.core.snowflake",
        "documentation": {}
    },
    {
        "label": "timestamp_left_shift",
        "kind": 5,
        "importPath": "custard.core.snowflake",
        "description": "custard.core.snowflake",
        "peekOfCode": "timestamp_left_shift = sequence_bits + worker_id_bits + data_center_id_bits\nsequence_mask = -1 ^ (-1 << sequence_bits)\ndef snowflake_to_timestamp(_id):\n    _id = _id >> 22  # strip the lower 22 bits\n    _id += twepoch  # adjust for twitter epoch\n    _id = _id / 1000  # convert from milliseconds to seconds\n    return _id\ndef generator(worker_id, data_center_id, sleep=lambda x: time.sleep(x / 1000.0)):\n    assert 0 <= worker_id <= max_worker_id\n    assert 0 <= data_center_id <= max_data_center_id",
        "detail": "custard.core.snowflake",
        "documentation": {}
    },
    {
        "label": "sequence_mask",
        "kind": 5,
        "importPath": "custard.core.snowflake",
        "description": "custard.core.snowflake",
        "peekOfCode": "sequence_mask = -1 ^ (-1 << sequence_bits)\ndef snowflake_to_timestamp(_id):\n    _id = _id >> 22  # strip the lower 22 bits\n    _id += twepoch  # adjust for twitter epoch\n    _id = _id / 1000  # convert from milliseconds to seconds\n    return _id\ndef generator(worker_id, data_center_id, sleep=lambda x: time.sleep(x / 1000.0)):\n    assert 0 <= worker_id <= max_worker_id\n    assert 0 <= data_center_id <= max_data_center_id\n    last_timestamp = -1",
        "detail": "custard.core.snowflake",
        "documentation": {}
    },
    {
        "label": "System",
        "kind": 6,
        "importPath": "custard.core.system",
        "description": "custard.core.system",
        "peekOfCode": "class System:\n    @staticmethod\n    def get_depend_libs(file_path):\n        \"\"\"\n        \n        Args:\n            file_path:\n        Returns:\n        Examples:\n        \"\"\"",
        "detail": "custard.core.system",
        "documentation": {}
    },
    {
        "label": "random_sample",
        "kind": 2,
        "importPath": "custard.core.useragent",
        "description": "custard.core.useragent",
        "peekOfCode": "def random_sample(random=None) -> float:\n    if random is None:\n        random = mod_random\n    return random.uniform(0.0, 1.0)\ndef cumsum(it: Iterable[float]):\n    total: float = 0\n    for x in it:\n        total += x\n        yield total\ndef choices_distribution_unique(a, p, random=None, length: int = 1):",
        "detail": "custard.core.useragent",
        "documentation": {}
    },
    {
        "label": "cumsum",
        "kind": 2,
        "importPath": "custard.core.useragent",
        "description": "custard.core.useragent",
        "peekOfCode": "def cumsum(it: Iterable[float]):\n    total: float = 0\n    for x in it:\n        total += x\n        yield total\ndef choices_distribution_unique(a, p, random=None, length: int = 1):\n    # As of Python 3.7, there isn't a way to sample unique elements that takes\n    # weight into account.\n    if random is None:\n        random = mod_random",
        "detail": "custard.core.useragent",
        "documentation": {}
    },
    {
        "label": "choices_distribution_unique",
        "kind": 2,
        "importPath": "custard.core.useragent",
        "description": "custard.core.useragent",
        "peekOfCode": "def choices_distribution_unique(a, p, random=None, length: int = 1):\n    # As of Python 3.7, there isn't a way to sample unique elements that takes\n    # weight into account.\n    if random is None:\n        random = mod_random\n    assert p is not None\n    assert len(a) == len(p)\n    assert len(a) >= length, \"You can't request more unique samples than elements in the dataset.\"\n    choices = []\n    items = list(a)",
        "detail": "custard.core.useragent",
        "documentation": {}
    },
    {
        "label": "choices_distribution",
        "kind": 2,
        "importPath": "custard.core.useragent",
        "description": "custard.core.useragent",
        "peekOfCode": "def choices_distribution(a, p, random=None, length: int = 1):\n    if random is None:\n        random = mod_random\n    if p is not None:\n        assert len(a) == len(p)\n    if hasattr(random, \"choices\"):\n        if length == 1 and p is None:\n            return [random.choice(a)]\n        else:\n            return random.choices(a, weights=p, k=length)",
        "detail": "custard.core.useragent",
        "documentation": {}
    },
    {
        "label": "random_elements",
        "kind": 2,
        "importPath": "custard.core.useragent",
        "description": "custard.core.useragent",
        "peekOfCode": "def random_elements(\n        elements: ElementsType = (\"a\", \"b\", \"c\"),\n        length=None,\n        unique: bool = False,\n        use_weighting=None,\n):\n    use_weighting = use_weighting if use_weighting is not None else __use_weighting__\n    if isinstance(elements, dict) and not isinstance(elements, OrderedDict):\n        raise ValueError(\"Use OrderedDict only to avoid dependency on PYTHONHASHSEED (See #363).\")\n    fn = choices_distribution_unique if unique else choices_distribution",
        "detail": "custard.core.useragent",
        "documentation": {}
    },
    {
        "label": "mac_processor",
        "kind": 2,
        "importPath": "custard.core.useragent",
        "description": "custard.core.useragent",
        "peekOfCode": "def mac_processor() -> str:\n    \"\"\"Generate a MacOS processor token used in user agent strings.\"\"\"\n    return random_element(mac_processors)\ndef linux_processor() -> str:\n    \"\"\"Generate a Linux processor token used in user agent strings.\"\"\"\n    return random_element(linux_processors)\nuser_agents: ElementsType = (\n    \"chrome\",\n    \"firefox\",\n    \"internet_explorer\",",
        "detail": "custard.core.useragent",
        "documentation": {}
    },
    {
        "label": "linux_processor",
        "kind": 2,
        "importPath": "custard.core.useragent",
        "description": "custard.core.useragent",
        "peekOfCode": "def linux_processor() -> str:\n    \"\"\"Generate a Linux processor token used in user agent strings.\"\"\"\n    return random_element(linux_processors)\nuser_agents: ElementsType = (\n    \"chrome\",\n    \"firefox\",\n    \"internet_explorer\",\n    \"opera\",\n    \"safari\",\n)",
        "detail": "custard.core.useragent",
        "documentation": {}
    },
    {
        "label": "user_agent",
        "kind": 2,
        "importPath": "custard.core.useragent",
        "description": "custard.core.useragent",
        "peekOfCode": "def user_agent() -> str:\n    name: str = random_element(user_agents)\n    print(name)\ndef chrome(\n        version_from: int = 13,\n        version_to: int = 63,\n        build_from: int = 800,\n        build_to: int = 899,\n) -> str:\n    \"\"\"Generate a Chrome web browser user agent string.\"\"\"",
        "detail": "custard.core.useragent",
        "documentation": {}
    },
    {
        "label": "chrome",
        "kind": 2,
        "importPath": "custard.core.useragent",
        "description": "custard.core.useragent",
        "peekOfCode": "def chrome(\n        version_from: int = 13,\n        version_to: int = 63,\n        build_from: int = 800,\n        build_to: int = 899,\n) -> str:\n    \"\"\"Generate a Chrome web browser user agent string.\"\"\"\n    saf: str = f\"{random.randint(531, 536)}.{random.randint(0, 2)}\"\n    bld: str = lexify(numerify(\"##?###\"), string.ascii_uppercase)\n    tmplt: str = \"({0}) AppleWebKit/{1} (KHTML, like Gecko)\" \" Chrome/{2}.0.{3}.0 Safari/{4}\"",
        "detail": "custard.core.useragent",
        "documentation": {}
    },
    {
        "label": "languageCode",
        "kind": 2,
        "importPath": "custard.core.useragent",
        "description": "custard.core.useragent",
        "peekOfCode": "def languageCode():\n    return random_element(language_locale_codes.keys())\ndef localeLang():\n    language_code = languageCode()\n    return (\n            language_code\n            + \"_\"\n            + random_element(\n        language_locale_codes[language_code],\n    )",
        "detail": "custard.core.useragent",
        "documentation": {}
    },
    {
        "label": "localeLang",
        "kind": 2,
        "importPath": "custard.core.useragent",
        "description": "custard.core.useragent",
        "peekOfCode": "def localeLang():\n    language_code = languageCode()\n    return (\n            language_code\n            + \"_\"\n            + random_element(\n        language_locale_codes[language_code],\n    )\n    )\ndef random_int(min: int = 0, max: int = 9999, step: int = 1) -> int:",
        "detail": "custard.core.useragent",
        "documentation": {}
    },
    {
        "label": "random_int",
        "kind": 2,
        "importPath": "custard.core.useragent",
        "description": "custard.core.useragent",
        "peekOfCode": "def random_int(min: int = 0, max: int = 9999, step: int = 1) -> int:\n    return random.randrange(min, max + 1, step)\ndef random_digit() -> int:\n    \"\"\"Generate a random digit (0 to 9).\"\"\"\n    return random.randint(0, 9)\ndef random_digit_not_null() -> int:\n    return random.randint(1, 9)\ndef random_digit_or_empty() -> Union[int, str]:\n    if random.randint(0, 1):\n        return random.randint(0, 9)",
        "detail": "custard.core.useragent",
        "documentation": {}
    },
    {
        "label": "random_digit",
        "kind": 2,
        "importPath": "custard.core.useragent",
        "description": "custard.core.useragent",
        "peekOfCode": "def random_digit() -> int:\n    \"\"\"Generate a random digit (0 to 9).\"\"\"\n    return random.randint(0, 9)\ndef random_digit_not_null() -> int:\n    return random.randint(1, 9)\ndef random_digit_or_empty() -> Union[int, str]:\n    if random.randint(0, 1):\n        return random.randint(0, 9)\n    else:\n        return \"\"",
        "detail": "custard.core.useragent",
        "documentation": {}
    },
    {
        "label": "random_digit_not_null",
        "kind": 2,
        "importPath": "custard.core.useragent",
        "description": "custard.core.useragent",
        "peekOfCode": "def random_digit_not_null() -> int:\n    return random.randint(1, 9)\ndef random_digit_or_empty() -> Union[int, str]:\n    if random.randint(0, 1):\n        return random.randint(0, 9)\n    else:\n        return \"\"\ndef random_digit_not_null_or_empty() -> Union[int, str]:\n    if random.randint(0, 1):\n        return random.randint(1, 9)",
        "detail": "custard.core.useragent",
        "documentation": {}
    },
    {
        "label": "random_digit_or_empty",
        "kind": 2,
        "importPath": "custard.core.useragent",
        "description": "custard.core.useragent",
        "peekOfCode": "def random_digit_or_empty() -> Union[int, str]:\n    if random.randint(0, 1):\n        return random.randint(0, 9)\n    else:\n        return \"\"\ndef random_digit_not_null_or_empty() -> Union[int, str]:\n    if random.randint(0, 1):\n        return random.randint(1, 9)\n    else:\n        return \"\"",
        "detail": "custard.core.useragent",
        "documentation": {}
    },
    {
        "label": "random_digit_not_null_or_empty",
        "kind": 2,
        "importPath": "custard.core.useragent",
        "description": "custard.core.useragent",
        "peekOfCode": "def random_digit_not_null_or_empty() -> Union[int, str]:\n    if random.randint(0, 1):\n        return random.randint(1, 9)\n    else:\n        return \"\"\ndef random_number(digits=None, fix_len: bool = False) -> int:\n    if digits is None:\n        digits = random_digit_not_null()\n    if digits < 0:\n        raise ValueError(\"The digit parameter must be greater than or equal to 0.\")",
        "detail": "custard.core.useragent",
        "documentation": {}
    },
    {
        "label": "random_number",
        "kind": 2,
        "importPath": "custard.core.useragent",
        "description": "custard.core.useragent",
        "peekOfCode": "def random_number(digits=None, fix_len: bool = False) -> int:\n    if digits is None:\n        digits = random_digit_not_null()\n    if digits < 0:\n        raise ValueError(\"The digit parameter must be greater than or equal to 0.\")\n    if fix_len:\n        if digits > 0:\n            return random.randint(pow(10, digits - 1), pow(10, digits) - 1)\n        else:\n            raise ValueError(\"A number of fixed length cannot have less than 1 digit in it.\")",
        "detail": "custard.core.useragent",
        "documentation": {}
    },
    {
        "label": "random_letter",
        "kind": 2,
        "importPath": "custard.core.useragent",
        "description": "custard.core.useragent",
        "peekOfCode": "def random_letter() -> str:\n    return random.choice(getattr(string, \"letters\", string.ascii_letters))\ndef random_choices(self, elements: ElementsType = (\"a\", \"b\", \"c\"), length: int = None) -> Sequence[T]:\n    return self.random_elements(elements, length, unique=False)\ndef random_letters(length: int = 16) -> Sequence[str]:\n    return random_choices(\n        getattr(string, \"letters\", string.ascii_letters),\n        length=length,\n    )\ndef rand_lowercase_letter() -> str:",
        "detail": "custard.core.useragent",
        "documentation": {}
    },
    {
        "label": "random_choices",
        "kind": 2,
        "importPath": "custard.core.useragent",
        "description": "custard.core.useragent",
        "peekOfCode": "def random_choices(self, elements: ElementsType = (\"a\", \"b\", \"c\"), length: int = None) -> Sequence[T]:\n    return self.random_elements(elements, length, unique=False)\ndef random_letters(length: int = 16) -> Sequence[str]:\n    return random_choices(\n        getattr(string, \"letters\", string.ascii_letters),\n        length=length,\n    )\ndef rand_lowercase_letter() -> str:\n    return random.choice(string.ascii_lowercase)\ndef rand_uppercase_letter() -> str:",
        "detail": "custard.core.useragent",
        "documentation": {}
    },
    {
        "label": "random_letters",
        "kind": 2,
        "importPath": "custard.core.useragent",
        "description": "custard.core.useragent",
        "peekOfCode": "def random_letters(length: int = 16) -> Sequence[str]:\n    return random_choices(\n        getattr(string, \"letters\", string.ascii_letters),\n        length=length,\n    )\ndef rand_lowercase_letter() -> str:\n    return random.choice(string.ascii_lowercase)\ndef rand_uppercase_letter() -> str:\n    return random.choice(string.ascii_uppercase)\ndef numerify(text: str = \"###\") -> str:",
        "detail": "custard.core.useragent",
        "documentation": {}
    },
    {
        "label": "rand_lowercase_letter",
        "kind": 2,
        "importPath": "custard.core.useragent",
        "description": "custard.core.useragent",
        "peekOfCode": "def rand_lowercase_letter() -> str:\n    return random.choice(string.ascii_lowercase)\ndef rand_uppercase_letter() -> str:\n    return random.choice(string.ascii_uppercase)\ndef numerify(text: str = \"###\") -> str:\n    text = _re_hash.sub(lambda x: str(random_digit()), text)\n    text = _re_perc.sub(lambda x: str(random_digit_not_null()), text)\n    text = _re_excl.sub(lambda x: str(random_digit_or_empty()), text)\n    text = _re_at.sub(lambda x: str(random_digit_not_null_or_empty()), text)\n    return text",
        "detail": "custard.core.useragent",
        "documentation": {}
    },
    {
        "label": "rand_uppercase_letter",
        "kind": 2,
        "importPath": "custard.core.useragent",
        "description": "custard.core.useragent",
        "peekOfCode": "def rand_uppercase_letter() -> str:\n    return random.choice(string.ascii_uppercase)\ndef numerify(text: str = \"###\") -> str:\n    text = _re_hash.sub(lambda x: str(random_digit()), text)\n    text = _re_perc.sub(lambda x: str(random_digit_not_null()), text)\n    text = _re_excl.sub(lambda x: str(random_digit_or_empty()), text)\n    text = _re_at.sub(lambda x: str(random_digit_not_null_or_empty()), text)\n    return text\ndef lexify(text: str = \"????\", letters: str = string.ascii_letters) -> str:\n    return _re_qm.sub(lambda x: random_element(letters), text)",
        "detail": "custard.core.useragent",
        "documentation": {}
    },
    {
        "label": "numerify",
        "kind": 2,
        "importPath": "custard.core.useragent",
        "description": "custard.core.useragent",
        "peekOfCode": "def numerify(text: str = \"###\") -> str:\n    text = _re_hash.sub(lambda x: str(random_digit()), text)\n    text = _re_perc.sub(lambda x: str(random_digit_not_null()), text)\n    text = _re_excl.sub(lambda x: str(random_digit_or_empty()), text)\n    text = _re_at.sub(lambda x: str(random_digit_not_null_or_empty()), text)\n    return text\ndef lexify(text: str = \"????\", letters: str = string.ascii_letters) -> str:\n    return _re_qm.sub(lambda x: random_element(letters), text)\ndef datetime_to_timestamp(dt: Union[dtdate, datetime]) -> int:\n    if isinstance(dt, datetime) and getattr(dt, \"tzinfo\", None) is not None:",
        "detail": "custard.core.useragent",
        "documentation": {}
    },
    {
        "label": "lexify",
        "kind": 2,
        "importPath": "custard.core.useragent",
        "description": "custard.core.useragent",
        "peekOfCode": "def lexify(text: str = \"????\", letters: str = string.ascii_letters) -> str:\n    return _re_qm.sub(lambda x: random_element(letters), text)\ndef datetime_to_timestamp(dt: Union[dtdate, datetime]) -> int:\n    if isinstance(dt, datetime) and getattr(dt, \"tzinfo\", None) is not None:\n        dt = dt.astimezone(tzutc())\n    return timegm(dt.timetuple())\ndef parse_date_string(cls, value: str) -> Dict[str, float]:\n    parts = cls.regex.match(value)\n    if not parts:\n        raise Exception(f\"Can't parse date string `{value}`\")",
        "detail": "custard.core.useragent",
        "documentation": {}
    },
    {
        "label": "datetime_to_timestamp",
        "kind": 2,
        "importPath": "custard.core.useragent",
        "description": "custard.core.useragent",
        "peekOfCode": "def datetime_to_timestamp(dt: Union[dtdate, datetime]) -> int:\n    if isinstance(dt, datetime) and getattr(dt, \"tzinfo\", None) is not None:\n        dt = dt.astimezone(tzutc())\n    return timegm(dt.timetuple())\ndef parse_date_string(cls, value: str) -> Dict[str, float]:\n    parts = cls.regex.match(value)\n    if not parts:\n        raise Exception(f\"Can't parse date string `{value}`\")\n    parts = parts.groupdict()\n    time_params: Dict[str, float] = {}",
        "detail": "custard.core.useragent",
        "documentation": {}
    },
    {
        "label": "parse_date_string",
        "kind": 2,
        "importPath": "custard.core.useragent",
        "description": "custard.core.useragent",
        "peekOfCode": "def parse_date_string(cls, value: str) -> Dict[str, float]:\n    parts = cls.regex.match(value)\n    if not parts:\n        raise Exception(f\"Can't parse date string `{value}`\")\n    parts = parts.groupdict()\n    time_params: Dict[str, float] = {}\n    for (name_, param_) in parts.items():\n        if param_:\n            time_params[name_] = int(param_)\n    if \"years\" in time_params:",
        "detail": "custard.core.useragent",
        "documentation": {}
    },
    {
        "label": "date_time_between",
        "kind": 2,
        "importPath": "custard.core.useragent",
        "description": "custard.core.useragent",
        "peekOfCode": "def date_time_between(\n        start_date: DateParseType = \"-30y\",\n        end_date: DateParseType = \"now\",\n        tzinfo=None,\n) -> datetime:\n    start_date = _parse_date_time(start_date, tzinfo=tzinfo)\n    end_date = _parse_date_time(end_date, tzinfo=tzinfo)\n    if end_date - start_date <= 1:\n        ts = start_date + random.random()\n    else:",
        "detail": "custard.core.useragent",
        "documentation": {}
    },
    {
        "label": "firefox",
        "kind": 2,
        "importPath": "custard.core.useragent",
        "description": "custard.core.useragent",
        "peekOfCode": "def firefox() -> str:\n    \"\"\"Generate a Mozilla Firefox web browser user agent string.\"\"\"\n    ver: ElementsType = (\n        (\n            f\"Gecko/{date_time_between(datetime(2011, 1, 1))} \"\n            f\"Firefox/{random.randint(4, 15)}.0\"\n        ),\n        (\n            f\"Gecko/{date_time_between(datetime(2010, 1, 1))} \"\n            f\"Firefox/3.6.{random.randint(1, 20)}\"",
        "detail": "custard.core.useragent",
        "documentation": {}
    },
    {
        "label": "localeLang",
        "kind": 2,
        "importPath": "custard.core.useragent",
        "description": "custard.core.useragent",
        "peekOfCode": "def localeLang() -> str:\n    language_code = languageCode()\n    return (\n            language_code\n            + \"_\"\n            + random_element(\n        language_locale_codes[language_code],\n    )\n    )\ndef safari() -> str:",
        "detail": "custard.core.useragent",
        "documentation": {}
    },
    {
        "label": "safari",
        "kind": 2,
        "importPath": "custard.core.useragent",
        "description": "custard.core.useragent",
        "peekOfCode": "def safari() -> str:\n    saf: str = (\n        f\"{random.randint(531, 535)}.\"\n        f\"{random.randint(1, 50)}.\"\n        f\"{random.randint(1, 7)}\"\n    )\n    ver: str = (\n        f\"{random.randint(4, 5)}.{random.randint(0, 1)}\"\n        if not random.getrandbits(1)\n        else f\"{random.randint(4, 5)}.0.{random.randint(1, 5)}\"",
        "detail": "custard.core.useragent",
        "documentation": {}
    },
    {
        "label": "opera",
        "kind": 2,
        "importPath": "custard.core.useragent",
        "description": "custard.core.useragent",
        "peekOfCode": "def opera() -> str:\n    token: str = (\n        linux_platform_token() if random.getrandbits(1) else win_platform_token()\n    )\n    locale: str = localeLang().replace(\"_\", \"-\")\n    platform: str = (\n        f\"({token}; {locale}) Presto/2.9.{random.randint(160, 190)} \"\n        f\"Version/{random.randint(10, 12)}.00\"\n    )\n    return f\"Opera/{random.randint(8, 9)}.{random.randint(10, 99)}.{platform}\"",
        "detail": "custard.core.useragent",
        "documentation": {}
    },
    {
        "label": "internet_explorer",
        "kind": 2,
        "importPath": "custard.core.useragent",
        "description": "custard.core.useragent",
        "peekOfCode": "def internet_explorer() -> str:\n    return (\n        f\"Mozilla/5.0 (compatible; MSIE {random.randint(5, 9)}.0; \"\n        f\"{win_platform_token()}; \"\n        f\"Trident/{random.randint(3, 5)}.{random.randint(0, 1)})\"\n    )\ndef random_element(elements: ElementsType = (\"a\", \"b\", \"c\")) -> T:\n    return random_elements(elements, length=1)[0]\ndef win_platform_token() -> str:\n    return random_element(win_platform_tokens)",
        "detail": "custard.core.useragent",
        "documentation": {}
    },
    {
        "label": "random_element",
        "kind": 2,
        "importPath": "custard.core.useragent",
        "description": "custard.core.useragent",
        "peekOfCode": "def random_element(elements: ElementsType = (\"a\", \"b\", \"c\")) -> T:\n    return random_elements(elements, length=1)[0]\ndef win_platform_token() -> str:\n    return random_element(win_platform_tokens)\ndef linux_platform_token() -> str:\n    return f\"X11; Linux {random_element(linux_processors)}\"\ndef mac_platform_token() -> str:\n    return (\n        f\"Macintosh; {random_element(mac_processors)} Mac OS X 10_\"\n        f\"{random.randint(5, 12)}_{random.randint(0, 9)}\"",
        "detail": "custard.core.useragent",
        "documentation": {}
    },
    {
        "label": "win_platform_token",
        "kind": 2,
        "importPath": "custard.core.useragent",
        "description": "custard.core.useragent",
        "peekOfCode": "def win_platform_token() -> str:\n    return random_element(win_platform_tokens)\ndef linux_platform_token() -> str:\n    return f\"X11; Linux {random_element(linux_processors)}\"\ndef mac_platform_token() -> str:\n    return (\n        f\"Macintosh; {random_element(mac_processors)} Mac OS X 10_\"\n        f\"{random.randint(5, 12)}_{random.randint(0, 9)}\"\n    )\ndef android_platform_token() -> str:",
        "detail": "custard.core.useragent",
        "documentation": {}
    },
    {
        "label": "linux_platform_token",
        "kind": 2,
        "importPath": "custard.core.useragent",
        "description": "custard.core.useragent",
        "peekOfCode": "def linux_platform_token() -> str:\n    return f\"X11; Linux {random_element(linux_processors)}\"\ndef mac_platform_token() -> str:\n    return (\n        f\"Macintosh; {random_element(mac_processors)} Mac OS X 10_\"\n        f\"{random.randint(5, 12)}_{random.randint(0, 9)}\"\n    )\ndef android_platform_token() -> str:\n    return f\"Android {random_element(android_versions)}\"\ndef ios_platform_token() -> str:",
        "detail": "custard.core.useragent",
        "documentation": {}
    },
    {
        "label": "mac_platform_token",
        "kind": 2,
        "importPath": "custard.core.useragent",
        "description": "custard.core.useragent",
        "peekOfCode": "def mac_platform_token() -> str:\n    return (\n        f\"Macintosh; {random_element(mac_processors)} Mac OS X 10_\"\n        f\"{random.randint(5, 12)}_{random.randint(0, 9)}\"\n    )\ndef android_platform_token() -> str:\n    return f\"Android {random_element(android_versions)}\"\ndef ios_platform_token() -> str:\n    apple_device: str = random_element(apple_devices)\n    ios_version: str = random_element(ios_versions)",
        "detail": "custard.core.useragent",
        "documentation": {}
    },
    {
        "label": "android_platform_token",
        "kind": 2,
        "importPath": "custard.core.useragent",
        "description": "custard.core.useragent",
        "peekOfCode": "def android_platform_token() -> str:\n    return f\"Android {random_element(android_versions)}\"\ndef ios_platform_token() -> str:\n    apple_device: str = random_element(apple_devices)\n    ios_version: str = random_element(ios_versions)\n    return f\"{apple_device}; CPU {apple_device} \" f'OS {ios_version.replace(\".\", \"_\")} like Mac OS X'",
        "detail": "custard.core.useragent",
        "documentation": {}
    },
    {
        "label": "ios_platform_token",
        "kind": 2,
        "importPath": "custard.core.useragent",
        "description": "custard.core.useragent",
        "peekOfCode": "def ios_platform_token() -> str:\n    apple_device: str = random_element(apple_devices)\n    ios_version: str = random_element(ios_versions)\n    return f\"{apple_device}; CPU {apple_device} \" f'OS {ios_version.replace(\".\", \"_\")} like Mac OS X'",
        "detail": "custard.core.useragent",
        "documentation": {}
    },
    {
        "label": "T",
        "kind": 5,
        "importPath": "custard.core.useragent",
        "description": "custard.core.useragent",
        "peekOfCode": "T = TypeVar(\"T\")\nElementsType = Collection[T]\nDateParseType = Union[date, datetime, timedelta, str, int]\nHueType = TypeVar(\"HueType\", str, float, Sequence[int])\nGenderType = TypeVar(\"GenderType\", bound=Literal[\"M\", \"F\"])\n_re_hash = re.compile(r\"#\")\n_re_perc = re.compile(r\"%\")\n_re_excl = re.compile(r\"!\")\n_re_at = re.compile(r\"@\")\n_re_qm = re.compile(r\"\\?\")",
        "detail": "custard.core.useragent",
        "documentation": {}
    },
    {
        "label": "ElementsType",
        "kind": 5,
        "importPath": "custard.core.useragent",
        "description": "custard.core.useragent",
        "peekOfCode": "ElementsType = Collection[T]\nDateParseType = Union[date, datetime, timedelta, str, int]\nHueType = TypeVar(\"HueType\", str, float, Sequence[int])\nGenderType = TypeVar(\"GenderType\", bound=Literal[\"M\", \"F\"])\n_re_hash = re.compile(r\"#\")\n_re_perc = re.compile(r\"%\")\n_re_excl = re.compile(r\"!\")\n_re_at = re.compile(r\"@\")\n_re_qm = re.compile(r\"\\?\")\n_re_cir = re.compile(r\"\\^\")",
        "detail": "custard.core.useragent",
        "documentation": {}
    },
    {
        "label": "DateParseType",
        "kind": 5,
        "importPath": "custard.core.useragent",
        "description": "custard.core.useragent",
        "peekOfCode": "DateParseType = Union[date, datetime, timedelta, str, int]\nHueType = TypeVar(\"HueType\", str, float, Sequence[int])\nGenderType = TypeVar(\"GenderType\", bound=Literal[\"M\", \"F\"])\n_re_hash = re.compile(r\"#\")\n_re_perc = re.compile(r\"%\")\n_re_excl = re.compile(r\"!\")\n_re_at = re.compile(r\"@\")\n_re_qm = re.compile(r\"\\?\")\n_re_cir = re.compile(r\"\\^\")\n__use_weighting__ = False",
        "detail": "custard.core.useragent",
        "documentation": {}
    },
    {
        "label": "HueType",
        "kind": 5,
        "importPath": "custard.core.useragent",
        "description": "custard.core.useragent",
        "peekOfCode": "HueType = TypeVar(\"HueType\", str, float, Sequence[int])\nGenderType = TypeVar(\"GenderType\", bound=Literal[\"M\", \"F\"])\n_re_hash = re.compile(r\"#\")\n_re_perc = re.compile(r\"%\")\n_re_excl = re.compile(r\"!\")\n_re_at = re.compile(r\"@\")\n_re_qm = re.compile(r\"\\?\")\n_re_cir = re.compile(r\"\\^\")\n__use_weighting__ = False\nuserAgents: ElementsType = (",
        "detail": "custard.core.useragent",
        "documentation": {}
    },
    {
        "label": "GenderType",
        "kind": 5,
        "importPath": "custard.core.useragent",
        "description": "custard.core.useragent",
        "peekOfCode": "GenderType = TypeVar(\"GenderType\", bound=Literal[\"M\", \"F\"])\n_re_hash = re.compile(r\"#\")\n_re_perc = re.compile(r\"%\")\n_re_excl = re.compile(r\"!\")\n_re_at = re.compile(r\"@\")\n_re_qm = re.compile(r\"\\?\")\n_re_cir = re.compile(r\"\\^\")\n__use_weighting__ = False\nuserAgents: ElementsType = (\n    \"chrome\",",
        "detail": "custard.core.useragent",
        "documentation": {}
    },
    {
        "label": "_re_hash",
        "kind": 5,
        "importPath": "custard.core.useragent",
        "description": "custard.core.useragent",
        "peekOfCode": "_re_hash = re.compile(r\"#\")\n_re_perc = re.compile(r\"%\")\n_re_excl = re.compile(r\"!\")\n_re_at = re.compile(r\"@\")\n_re_qm = re.compile(r\"\\?\")\n_re_cir = re.compile(r\"\\^\")\n__use_weighting__ = False\nuserAgents: ElementsType = (\n    \"chrome\",\n    \"firefox\",",
        "detail": "custard.core.useragent",
        "documentation": {}
    },
    {
        "label": "_re_perc",
        "kind": 5,
        "importPath": "custard.core.useragent",
        "description": "custard.core.useragent",
        "peekOfCode": "_re_perc = re.compile(r\"%\")\n_re_excl = re.compile(r\"!\")\n_re_at = re.compile(r\"@\")\n_re_qm = re.compile(r\"\\?\")\n_re_cir = re.compile(r\"\\^\")\n__use_weighting__ = False\nuserAgents: ElementsType = (\n    \"chrome\",\n    \"firefox\",\n    \"internet_explorer\",",
        "detail": "custard.core.useragent",
        "documentation": {}
    },
    {
        "label": "_re_excl",
        "kind": 5,
        "importPath": "custard.core.useragent",
        "description": "custard.core.useragent",
        "peekOfCode": "_re_excl = re.compile(r\"!\")\n_re_at = re.compile(r\"@\")\n_re_qm = re.compile(r\"\\?\")\n_re_cir = re.compile(r\"\\^\")\n__use_weighting__ = False\nuserAgents: ElementsType = (\n    \"chrome\",\n    \"firefox\",\n    \"internet_explorer\",\n    \"opera\",",
        "detail": "custard.core.useragent",
        "documentation": {}
    },
    {
        "label": "_re_at",
        "kind": 5,
        "importPath": "custard.core.useragent",
        "description": "custard.core.useragent",
        "peekOfCode": "_re_at = re.compile(r\"@\")\n_re_qm = re.compile(r\"\\?\")\n_re_cir = re.compile(r\"\\^\")\n__use_weighting__ = False\nuserAgents: ElementsType = (\n    \"chrome\",\n    \"firefox\",\n    \"internet_explorer\",\n    \"opera\",\n    \"safari\",",
        "detail": "custard.core.useragent",
        "documentation": {}
    },
    {
        "label": "_re_qm",
        "kind": 5,
        "importPath": "custard.core.useragent",
        "description": "custard.core.useragent",
        "peekOfCode": "_re_qm = re.compile(r\"\\?\")\n_re_cir = re.compile(r\"\\^\")\n__use_weighting__ = False\nuserAgents: ElementsType = (\n    \"chrome\",\n    \"firefox\",\n    \"internet_explorer\",\n    \"opera\",\n    \"safari\",\n)",
        "detail": "custard.core.useragent",
        "documentation": {}
    },
    {
        "label": "_re_cir",
        "kind": 5,
        "importPath": "custard.core.useragent",
        "description": "custard.core.useragent",
        "peekOfCode": "_re_cir = re.compile(r\"\\^\")\n__use_weighting__ = False\nuserAgents: ElementsType = (\n    \"chrome\",\n    \"firefox\",\n    \"internet_explorer\",\n    \"opera\",\n    \"safari\",\n)\nwin_platform_tokens: ElementsType = (",
        "detail": "custard.core.useragent",
        "documentation": {}
    },
    {
        "label": "__use_weighting__",
        "kind": 5,
        "importPath": "custard.core.useragent",
        "description": "custard.core.useragent",
        "peekOfCode": "__use_weighting__ = False\nuserAgents: ElementsType = (\n    \"chrome\",\n    \"firefox\",\n    \"internet_explorer\",\n    \"opera\",\n    \"safari\",\n)\nwin_platform_tokens: ElementsType = (\n    \"win 95\",",
        "detail": "custard.core.useragent",
        "documentation": {}
    },
    {
        "label": "random",
        "kind": 5,
        "importPath": "custard.core.useragent",
        "description": "custard.core.useragent",
        "peekOfCode": "random = random_module.Random()\nmod_random = random  # compat with name released in 0.8\ndef random_sample(random=None) -> float:\n    if random is None:\n        random = mod_random\n    return random.uniform(0.0, 1.0)\ndef cumsum(it: Iterable[float]):\n    total: float = 0\n    for x in it:\n        total += x",
        "detail": "custard.core.useragent",
        "documentation": {}
    },
    {
        "label": "mod_random",
        "kind": 5,
        "importPath": "custard.core.useragent",
        "description": "custard.core.useragent",
        "peekOfCode": "mod_random = random  # compat with name released in 0.8\ndef random_sample(random=None) -> float:\n    if random is None:\n        random = mod_random\n    return random.uniform(0.0, 1.0)\ndef cumsum(it: Iterable[float]):\n    total: float = 0\n    for x in it:\n        total += x\n        yield total",
        "detail": "custard.core.useragent",
        "documentation": {}
    },
    {
        "label": "language_locale_codes",
        "kind": 5,
        "importPath": "custard.core.useragent",
        "description": "custard.core.useragent",
        "peekOfCode": "language_locale_codes = {\n    \"aa\": (\"DJ\", \"ER\", \"ET\"),\n    \"af\": (\"ZA\",),\n    \"ak\": (\"GH\",),\n    \"am\": (\"ET\",),\n    \"an\": (\"ES\",),\n    \"apn\": (\"IN\",),\n    \"ar\": (\n        \"AE\",\n        \"BH\",",
        "detail": "custard.core.useragent",
        "documentation": {}
    },
    {
        "label": "Xml2Dict",
        "kind": 6,
        "importPath": "custard.core.xml2dict",
        "description": "custard.core.xml2dict",
        "peekOfCode": "class Xml2Dict(dict):\n    def __init__(self, parent_node):\n        if parent_node.items():\n            self.update_dict(dict(parent_node.items()))\n        for element in parent_node:\n            if len(element):\n                adict = Xml2Dict(element)\n                self.update_dict({element.tag: adict})\n            elif element.items():\n                element_attrib = element.items()",
        "detail": "custard.core.xml2dict",
        "documentation": {}
    },
    {
        "label": "stdout_write",
        "kind": 2,
        "importPath": "custard.core.xprint",
        "description": "custard.core.xprint",
        "peekOfCode": "def stdout_write(msg: str):\n    sys.stdout.write(msg)\n    sys.stdout.flush()\ndef stderr_write(msg: str):\n    sys.stderr.write(msg)\n    sys.stderr.flush()\ndef reverse_patch_print():\n    \"\"\"\n    print\n    :return:",
        "detail": "custard.core.xprint",
        "documentation": {}
    },
    {
        "label": "stderr_write",
        "kind": 2,
        "importPath": "custard.core.xprint",
        "description": "custard.core.xprint",
        "peekOfCode": "def stderr_write(msg: str):\n    sys.stderr.write(msg)\n    sys.stderr.flush()\ndef reverse_patch_print():\n    \"\"\"\n    print\n    :return:\n    \"\"\"\n    try:\n        __builtins__.print = print_raw",
        "detail": "custard.core.xprint",
        "documentation": {}
    },
    {
        "label": "reverse_patch_print",
        "kind": 2,
        "importPath": "custard.core.xprint",
        "description": "custard.core.xprint",
        "peekOfCode": "def reverse_patch_print():\n    \"\"\"\n    print\n    :return:\n    \"\"\"\n    try:\n        __builtins__.print = print_raw\n    except AttributeError:\n        __builtins__['print'] = print_raw\ndef xprint(*args, sep=' ', end='\\n', file=None, color=True):",
        "detail": "custard.core.xprint",
        "documentation": {}
    },
    {
        "label": "xprint",
        "kind": 2,
        "importPath": "custard.core.xprint",
        "description": "custard.core.xprint",
        "peekOfCode": "def xprint(*args, sep=' ', end='\\n', file=None, color=True):\n    \"\"\"\n    print\n    Args:\n        *args:\n        sep:\n        end:\n        file:\n        color:\n    Returns:",
        "detail": "custard.core.xprint",
        "documentation": {}
    },
    {
        "label": "print_raw",
        "kind": 5,
        "importPath": "custard.core.xprint",
        "description": "custard.core.xprint",
        "peekOfCode": "print_raw = print\ndef stdout_write(msg: str):\n    sys.stdout.write(msg)\n    sys.stdout.flush()\ndef stderr_write(msg: str):\n    sys.stderr.write(msg)\n    sys.stderr.flush()\ndef reverse_patch_print():\n    \"\"\"\n    print",
        "detail": "custard.core.xprint",
        "documentation": {}
    },
    {
        "label": "BatchTask",
        "kind": 6,
        "importPath": "custard.cron.batch_task",
        "description": "custard.cron.batch_task",
        "peekOfCode": "class BatchTask:\n    @staticmethod\n    def list_jobs(func_name, context):\n        \"\"\"\n        \n        Args:\n            func_name:\n            context:\n        Returns:\n        Examples:",
        "detail": "custard.cron.batch_task",
        "documentation": {}
    },
    {
        "label": "CryptoException",
        "kind": 6,
        "importPath": "custard.crypto.crypto",
        "description": "custard.crypto.crypto",
        "peekOfCode": "class CryptoException(Exception):\n    def __init__(self, message):\n        self._message = message\n    def __str__(self):\n        return str(self._message)\nclass AESCTRCipher(object):\n    \"\"\"\"\"\"\n    def __init__(self):\n        \"\"\"\"\"\"\n        self.__block_size_len = AES.block_size",
        "detail": "custard.crypto.crypto",
        "documentation": {}
    },
    {
        "label": "AESCTRCipher",
        "kind": 6,
        "importPath": "custard.crypto.crypto",
        "description": "custard.crypto.crypto",
        "peekOfCode": "class AESCTRCipher(object):\n    \"\"\"\"\"\"\n    def __init__(self):\n        \"\"\"\"\"\"\n        self.__block_size_len = AES.block_size\n        self.__cipher = None\n        self.__key_len = _AES_256_KEY_SIZE\n    def new_cipher(self, key, start, offset=0):\n        \"\"\"\n        AES",
        "detail": "custard.crypto.crypto",
        "documentation": {}
    },
    {
        "label": "RSAKeyPair",
        "kind": 6,
        "importPath": "custard.crypto.crypto",
        "description": "custard.crypto.crypto",
        "peekOfCode": "class RSAKeyPair:\n    \"\"\"\"\"\"\n    def __init__(self, public_key, private_key):\n        self.public_key = public_key\n        self.private_key = private_key\nclass RSAKeyPairPath:\n    \"\"\"\"\"\"\n    def __init__(self, public_key_path, private_key_path):\n        self.public_key_path = public_key_path\n        self.private_key_path = private_key_path",
        "detail": "custard.crypto.crypto",
        "documentation": {}
    },
    {
        "label": "RSAKeyPairPath",
        "kind": 6,
        "importPath": "custard.crypto.crypto",
        "description": "custard.crypto.crypto",
        "peekOfCode": "class RSAKeyPairPath:\n    \"\"\"\"\"\"\n    def __init__(self, public_key_path, private_key_path):\n        self.public_key_path = public_key_path\n        self.private_key_path = private_key_path\nclass BaseProvider(object):\n    \"\"\"\"\"\"\n    def __init__(self, cipher):\n        \"\"\"\n        :param cipher(an AES object): ",
        "detail": "custard.crypto.crypto",
        "documentation": {}
    },
    {
        "label": "BaseProvider",
        "kind": 6,
        "importPath": "custard.crypto.crypto",
        "description": "custard.crypto.crypto",
        "peekOfCode": "class BaseProvider(object):\n    \"\"\"\"\"\"\n    def __init__(self, cipher):\n        \"\"\"\n        :param cipher(an AES object): \n        \"\"\"\n        self.data_cipher = cipher\n    def get_data_key(self):\n        \"\"\"\"\"\"\n        return self.data_cipher.get_key()",
        "detail": "custard.crypto.crypto",
        "documentation": {}
    },
    {
        "label": "RSAProvider",
        "kind": 6,
        "importPath": "custard.crypto.crypto",
        "description": "custard.crypto.crypto",
        "peekOfCode": "class RSAProvider(BaseProvider):\n    \"\"\"\"\"\"\n    def __init__(self, key_pair_info=None, cipher=AESCTRCipher(), passphrase=None):\n        \"\"\"\"\"\"\n        super(RSAProvider, self).__init__(cipher=cipher)\n        default_rsa_dir = os.path.expanduser('~/.local_rsa')\n        default_public_key_path = os.path.join(default_rsa_dir, '.public_key.pem')\n        default_private_key_path = os.path.join(default_rsa_dir, '.private_key.pem')\n        self.__encrypt_obj = None\n        self.__decrypt_obj = None",
        "detail": "custard.crypto.crypto",
        "documentation": {}
    },
    {
        "label": "AESProvider",
        "kind": 6,
        "importPath": "custard.crypto.crypto",
        "description": "custard.crypto.crypto",
        "peekOfCode": "class AESProvider(BaseProvider):\n    \"\"\"\"\"\"\n    def __init__(self, aes_key=None, aes_key_path=None, cipher=AESCTRCipher()):\n        \"\"\"\"\"\"\n        super(AESProvider, self).__init__(cipher=cipher)\n        self.__ed_obj = None\n        self.__data_key = None\n        self.__data_iv = None\n        self.__my_counter = Counter.new(_AES_CTR_COUNTER_BITS_LENGTH, initial_value=0)\n        self.__aes_key = aes_key",
        "detail": "custard.crypto.crypto",
        "documentation": {}
    },
    {
        "label": "DataEncryptAdapter",
        "kind": 6,
        "importPath": "custard.crypto.crypto",
        "description": "custard.crypto.crypto",
        "peekOfCode": "class DataEncryptAdapter(object):\n    \"\"\"\"\"\"\n    def __init__(self, data, content_len, data_cipher):\n        self._data = to_bytes(data)\n        self._data_cipher = data_cipher\n        self._content_len = content_len\n        self._read_len = 0\n    @property\n    def len(self):\n        return self._content_len",
        "detail": "custard.crypto.crypto",
        "documentation": {}
    },
    {
        "label": "DataDecryptAdapter",
        "kind": 6,
        "importPath": "custard.crypto.crypto",
        "description": "custard.crypto.crypto",
        "peekOfCode": "class DataDecryptAdapter(StreamBody):\n    \"\"\"\"\"\"\n    def __init__(self, rt, data_cipher, offset=0):\n        \"\"\"\n        :param rt(request object): request\n        :param data_cipher(an AES object): \n        :param offset(int): \n        \"\"\"\n        super(DataDecryptAdapter, self).__init__(rt)\n        self._data_cipher = data_cipher",
        "detail": "custard.crypto.crypto",
        "documentation": {}
    },
    {
        "label": "to_bytes",
        "kind": 2,
        "importPath": "custard.crypto.crypto",
        "description": "custard.crypto.crypto",
        "peekOfCode": "def to_bytes(str_):\n    \"\"\"\n    bytes\n    Args:\n        str_:\n    Returns:\n    \"\"\"\n    if isinstance(str_, text_type):\n        try:\n            return str_.encode('utf-8')",
        "detail": "custard.crypto.crypto",
        "documentation": {}
    },
    {
        "label": "random_key",
        "kind": 2,
        "importPath": "custard.crypto.crypto",
        "description": "custard.crypto.crypto",
        "peekOfCode": "def random_key(key_len):\n    \"\"\"\n    Args:\n        key_len:\n    Returns:\n    \"\"\"\n    return Random.new().read(key_len)\ndef random_iv():\n    \"\"\"\n    Returns:",
        "detail": "custard.crypto.crypto",
        "documentation": {}
    },
    {
        "label": "random_iv",
        "kind": 2,
        "importPath": "custard.crypto.crypto",
        "description": "custard.crypto.crypto",
        "peekOfCode": "def random_iv():\n    \"\"\"\n    Returns:\n    \"\"\"\n    iv = Random.new().read(16)\n    return iv\ndef iv_to_big_int(iv):\n    \"\"\"\n    Args:\n        iv:",
        "detail": "custard.crypto.crypto",
        "documentation": {}
    },
    {
        "label": "iv_to_big_int",
        "kind": 2,
        "importPath": "custard.crypto.crypto",
        "description": "custard.crypto.crypto",
        "peekOfCode": "def iv_to_big_int(iv):\n    \"\"\"\n    Args:\n        iv:\n    Returns:\n    \"\"\"\n    iv_pair = struct.unpack(\">QQ\", iv)\n    iv_int = iv_pair[0] << 64 | iv_pair[1]\n    return iv_int\nclass CryptoException(Exception):",
        "detail": "custard.crypto.crypto",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "custard.crypto.crypto",
        "description": "custard.crypto.crypto",
        "peekOfCode": "logger = logging.getLogger(__name__)\n_AES_CTR_COUNTER_BITS_LENGTH = 8 * 16\n_AES_256_KEY_SIZE = 32\n__all__ = [\"BaseProvider\", \"AESProvider\", \"RSAProvider\", \"AESCTRCipher\", \"DataDecryptAdapter\", \"DataEncryptAdapter\"]\ndef to_bytes(str_):\n    \"\"\"\n    bytes\n    Args:\n        str_:\n    Returns:",
        "detail": "custard.crypto.crypto",
        "documentation": {}
    },
    {
        "label": "_AES_CTR_COUNTER_BITS_LENGTH",
        "kind": 5,
        "importPath": "custard.crypto.crypto",
        "description": "custard.crypto.crypto",
        "peekOfCode": "_AES_CTR_COUNTER_BITS_LENGTH = 8 * 16\n_AES_256_KEY_SIZE = 32\n__all__ = [\"BaseProvider\", \"AESProvider\", \"RSAProvider\", \"AESCTRCipher\", \"DataDecryptAdapter\", \"DataEncryptAdapter\"]\ndef to_bytes(str_):\n    \"\"\"\n    bytes\n    Args:\n        str_:\n    Returns:\n    \"\"\"",
        "detail": "custard.crypto.crypto",
        "documentation": {}
    },
    {
        "label": "_AES_256_KEY_SIZE",
        "kind": 5,
        "importPath": "custard.crypto.crypto",
        "description": "custard.crypto.crypto",
        "peekOfCode": "_AES_256_KEY_SIZE = 32\n__all__ = [\"BaseProvider\", \"AESProvider\", \"RSAProvider\", \"AESCTRCipher\", \"DataDecryptAdapter\", \"DataEncryptAdapter\"]\ndef to_bytes(str_):\n    \"\"\"\n    bytes\n    Args:\n        str_:\n    Returns:\n    \"\"\"\n    if isinstance(str_, text_type):",
        "detail": "custard.crypto.crypto",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "custard.crypto.crypto",
        "description": "custard.crypto.crypto",
        "peekOfCode": "__all__ = [\"BaseProvider\", \"AESProvider\", \"RSAProvider\", \"AESCTRCipher\", \"DataDecryptAdapter\", \"DataEncryptAdapter\"]\ndef to_bytes(str_):\n    \"\"\"\n    bytes\n    Args:\n        str_:\n    Returns:\n    \"\"\"\n    if isinstance(str_, text_type):\n        try:",
        "detail": "custard.crypto.crypto",
        "documentation": {}
    },
    {
        "label": "StreamBody",
        "kind": 6,
        "importPath": "custard.crypto.streambody",
        "description": "custard.crypto.streambody",
        "peekOfCode": "class StreamBody(object):\n    def __init__(self, rt):\n        self._rt = rt\n        self._read_len = 0\n        self._content_len = 0\n        self._use_chunked = False\n        self._use_encoding = False\n        if 'Content-Length' in self._rt.headers:\n            self._content_len = int(self._rt.headers['Content-Length'])\n        elif 'Transfer-Encoding' in self._rt.headers and self._rt.headers['Transfer-Encoding'] == \"chunked\":",
        "detail": "custard.crypto.streambody",
        "documentation": {}
    },
    {
        "label": "TableNotFoundError",
        "kind": 6,
        "importPath": "custard.db.exc",
        "description": "custard.db.exc",
        "peekOfCode": "class TableNotFoundError(Exception):\n    pass\nclass TableTypeError(Exception):\n    pass",
        "detail": "custard.db.exc",
        "documentation": {}
    },
    {
        "label": "TableTypeError",
        "kind": 6,
        "importPath": "custard.db.exc",
        "description": "custard.db.exc",
        "peekOfCode": "class TableTypeError(Exception):\n    pass",
        "detail": "custard.db.exc",
        "documentation": {}
    },
    {
        "label": "MySqlInspect",
        "kind": 6,
        "importPath": "custard.db.inspect",
        "description": "custard.db.inspect",
        "peekOfCode": "class MySqlInspect:\n    def __init__(self, source_schema: Optional[str], source_url: Optional[str],\n                 source_user: Optional[str], source_password: Optional[str], source_port: Optional[int],\n                 target_schema: Optional[str], target_url: Optional[str],\n                 target_user: Optional[str], target_password: Optional[str], target_port: Optional[int]\n                 ):\n        \"\"\"\n        \n        source target\n        Args:",
        "detail": "custard.db.inspect",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "custard.db.logger",
        "description": "custard.db.logger",
        "peekOfCode": "__all__ = ['getLogger', 'INFO', 'WARN', 'DEBUG', 'TRACE', 'ERROR', 'FATAL', 'logger']\nTRACE = logging.TRACE = DEBUG - 5\nlogging.addLevelName(TRACE, 'TRACE')\nFORMAT = '%(relativeCreated)d %(levelname)s: %(message)s'\nlogging.basicConfig(format=FORMAT, level=logging.INFO)\nlogger = getLogger('dts')\ndef __add_options(parser):\n    levels = ('TRACE', 'DEBUG', 'INFO', 'WARN', 'ERROR', 'CRITICAL')\n    parser.add_argument(\n        '--log-level',",
        "detail": "custard.db.logger",
        "documentation": {}
    },
    {
        "label": "TRACE",
        "kind": 5,
        "importPath": "custard.db.logger",
        "description": "custard.db.logger",
        "peekOfCode": "TRACE = logging.TRACE = DEBUG - 5\nlogging.addLevelName(TRACE, 'TRACE')\nFORMAT = '%(relativeCreated)d %(levelname)s: %(message)s'\nlogging.basicConfig(format=FORMAT, level=logging.INFO)\nlogger = getLogger('dts')\ndef __add_options(parser):\n    levels = ('TRACE', 'DEBUG', 'INFO', 'WARN', 'ERROR', 'CRITICAL')\n    parser.add_argument(\n        '--log-level',\n        choices=levels,",
        "detail": "custard.db.logger",
        "documentation": {}
    },
    {
        "label": "FORMAT",
        "kind": 5,
        "importPath": "custard.db.logger",
        "description": "custard.db.logger",
        "peekOfCode": "FORMAT = '%(relativeCreated)d %(levelname)s: %(message)s'\nlogging.basicConfig(format=FORMAT, level=logging.INFO)\nlogger = getLogger('dts')\ndef __add_options(parser):\n    levels = ('TRACE', 'DEBUG', 'INFO', 'WARN', 'ERROR', 'CRITICAL')\n    parser.add_argument(\n        '--log-level',\n        choices=levels,\n        metavar=\"LEVEL\",\n        default='INFO',",
        "detail": "custard.db.logger",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "custard.db.logger",
        "description": "custard.db.logger",
        "peekOfCode": "logger = getLogger('dts')\ndef __add_options(parser):\n    levels = ('TRACE', 'DEBUG', 'INFO', 'WARN', 'ERROR', 'CRITICAL')\n    parser.add_argument(\n        '--log-level',\n        choices=levels,\n        metavar=\"LEVEL\",\n        default='INFO',\n        dest='loglevel',\n        help='Amount of detail in build-time console messages. LEVEL may be one of %s (default: %%(default)s).' %",
        "detail": "custard.db.logger",
        "documentation": {}
    },
    {
        "label": "MysqlUtil",
        "kind": 6,
        "importPath": "custard.db.utils",
        "description": "custard.db.utils",
        "peekOfCode": "class MysqlUtil:\n    def __init__(self, schema: Optional[str], url: Optional[str],\n                 user: Optional[str], password: Optional[str], port: Optional[int]):\n        self.__schema = schema\n        self.__url = url\n        self.__user = user\n        self.__password = password\n        self.__port = port\n        self.__config = {\n            'host': self.__url,",
        "detail": "custard.db.utils",
        "documentation": {}
    },
    {
        "label": "ExcContextManager",
        "kind": 6,
        "importPath": "custard.expect.context",
        "description": "custard.expect.context",
        "peekOfCode": "class ExcContextManager:\n    def __init__(self, verbose=100, donot_raise__exception=True):\n        \"\"\"\n        \n        Args:\n            verbose: ,tracebacklimit\n            donot_raise__exception: ,tracebacklimit\n        \"\"\"\n        self._verbose = verbose\n        self._donot_raise__exception = donot_raise__exception",
        "detail": "custard.expect.context",
        "documentation": {}
    },
    {
        "label": "MyBaseFailure",
        "kind": 6,
        "importPath": "custard.expect.exceptions",
        "description": "custard.expect.exceptions",
        "peekOfCode": "class MyBaseFailure(Exception):\n    pass\nclass ValidationFailure(MyBaseFailure):\n    pass\nclass ExtractFailure(MyBaseFailure):\n    pass\nclass SetupHooksFailure(MyBaseFailure):\n    pass\nclass TeardownHooksFailure(MyBaseFailure):\n    pass",
        "detail": "custard.expect.exceptions",
        "documentation": {}
    },
    {
        "label": "ValidationFailure",
        "kind": 6,
        "importPath": "custard.expect.exceptions",
        "description": "custard.expect.exceptions",
        "peekOfCode": "class ValidationFailure(MyBaseFailure):\n    pass\nclass ExtractFailure(MyBaseFailure):\n    pass\nclass SetupHooksFailure(MyBaseFailure):\n    pass\nclass TeardownHooksFailure(MyBaseFailure):\n    pass\nclass MyBaseError(Exception):\n    pass",
        "detail": "custard.expect.exceptions",
        "documentation": {}
    },
    {
        "label": "ExtractFailure",
        "kind": 6,
        "importPath": "custard.expect.exceptions",
        "description": "custard.expect.exceptions",
        "peekOfCode": "class ExtractFailure(MyBaseFailure):\n    pass\nclass SetupHooksFailure(MyBaseFailure):\n    pass\nclass TeardownHooksFailure(MyBaseFailure):\n    pass\nclass MyBaseError(Exception):\n    pass\nclass FileFormatError(MyBaseError):\n    pass",
        "detail": "custard.expect.exceptions",
        "documentation": {}
    },
    {
        "label": "SetupHooksFailure",
        "kind": 6,
        "importPath": "custard.expect.exceptions",
        "description": "custard.expect.exceptions",
        "peekOfCode": "class SetupHooksFailure(MyBaseFailure):\n    pass\nclass TeardownHooksFailure(MyBaseFailure):\n    pass\nclass MyBaseError(Exception):\n    pass\nclass FileFormatError(MyBaseError):\n    pass\nclass ParamsError(MyBaseError):\n    pass",
        "detail": "custard.expect.exceptions",
        "documentation": {}
    },
    {
        "label": "TeardownHooksFailure",
        "kind": 6,
        "importPath": "custard.expect.exceptions",
        "description": "custard.expect.exceptions",
        "peekOfCode": "class TeardownHooksFailure(MyBaseFailure):\n    pass\nclass MyBaseError(Exception):\n    pass\nclass FileFormatError(MyBaseError):\n    pass\nclass ParamsError(MyBaseError):\n    pass\nclass NotFoundError(MyBaseError):\n    pass",
        "detail": "custard.expect.exceptions",
        "documentation": {}
    },
    {
        "label": "MyBaseError",
        "kind": 6,
        "importPath": "custard.expect.exceptions",
        "description": "custard.expect.exceptions",
        "peekOfCode": "class MyBaseError(Exception):\n    pass\nclass FileFormatError(MyBaseError):\n    pass\nclass ParamsError(MyBaseError):\n    pass\nclass NotFoundError(MyBaseError):\n    pass\nclass FileNotFound(FileNotFoundError, NotFoundError):\n    pass",
        "detail": "custard.expect.exceptions",
        "documentation": {}
    },
    {
        "label": "FileFormatError",
        "kind": 6,
        "importPath": "custard.expect.exceptions",
        "description": "custard.expect.exceptions",
        "peekOfCode": "class FileFormatError(MyBaseError):\n    pass\nclass ParamsError(MyBaseError):\n    pass\nclass NotFoundError(MyBaseError):\n    pass\nclass FileNotFound(FileNotFoundError, NotFoundError):\n    pass\nclass FunctionNotFound(NotFoundError):\n    pass",
        "detail": "custard.expect.exceptions",
        "documentation": {}
    },
    {
        "label": "ParamsError",
        "kind": 6,
        "importPath": "custard.expect.exceptions",
        "description": "custard.expect.exceptions",
        "peekOfCode": "class ParamsError(MyBaseError):\n    pass\nclass NotFoundError(MyBaseError):\n    pass\nclass FileNotFound(FileNotFoundError, NotFoundError):\n    pass\nclass FunctionNotFound(NotFoundError):\n    pass\nclass VariableNotFound(NotFoundError):\n    pass",
        "detail": "custard.expect.exceptions",
        "documentation": {}
    },
    {
        "label": "NotFoundError",
        "kind": 6,
        "importPath": "custard.expect.exceptions",
        "description": "custard.expect.exceptions",
        "peekOfCode": "class NotFoundError(MyBaseError):\n    pass\nclass FileNotFound(FileNotFoundError, NotFoundError):\n    pass\nclass FunctionNotFound(NotFoundError):\n    pass\nclass VariableNotFound(NotFoundError):\n    pass\nclass ApiNotFound(NotFoundError):\n    pass",
        "detail": "custard.expect.exceptions",
        "documentation": {}
    },
    {
        "label": "FileNotFound",
        "kind": 6,
        "importPath": "custard.expect.exceptions",
        "description": "custard.expect.exceptions",
        "peekOfCode": "class FileNotFound(FileNotFoundError, NotFoundError):\n    pass\nclass FunctionNotFound(NotFoundError):\n    pass\nclass VariableNotFound(NotFoundError):\n    pass\nclass ApiNotFound(NotFoundError):\n    pass\nclass TestcaseNotFound(NotFoundError):\n    pass",
        "detail": "custard.expect.exceptions",
        "documentation": {}
    },
    {
        "label": "FunctionNotFound",
        "kind": 6,
        "importPath": "custard.expect.exceptions",
        "description": "custard.expect.exceptions",
        "peekOfCode": "class FunctionNotFound(NotFoundError):\n    pass\nclass VariableNotFound(NotFoundError):\n    pass\nclass ApiNotFound(NotFoundError):\n    pass\nclass TestcaseNotFound(NotFoundError):\n    pass\nclass ExpectValueParseFailure(Exception):\n    pass",
        "detail": "custard.expect.exceptions",
        "documentation": {}
    },
    {
        "label": "VariableNotFound",
        "kind": 6,
        "importPath": "custard.expect.exceptions",
        "description": "custard.expect.exceptions",
        "peekOfCode": "class VariableNotFound(NotFoundError):\n    pass\nclass ApiNotFound(NotFoundError):\n    pass\nclass TestcaseNotFound(NotFoundError):\n    pass\nclass ExpectValueParseFailure(Exception):\n    pass",
        "detail": "custard.expect.exceptions",
        "documentation": {}
    },
    {
        "label": "ApiNotFound",
        "kind": 6,
        "importPath": "custard.expect.exceptions",
        "description": "custard.expect.exceptions",
        "peekOfCode": "class ApiNotFound(NotFoundError):\n    pass\nclass TestcaseNotFound(NotFoundError):\n    pass\nclass ExpectValueParseFailure(Exception):\n    pass",
        "detail": "custard.expect.exceptions",
        "documentation": {}
    },
    {
        "label": "TestcaseNotFound",
        "kind": 6,
        "importPath": "custard.expect.exceptions",
        "description": "custard.expect.exceptions",
        "peekOfCode": "class TestcaseNotFound(NotFoundError):\n    pass\nclass ExpectValueParseFailure(Exception):\n    pass",
        "detail": "custard.expect.exceptions",
        "documentation": {}
    },
    {
        "label": "ExpectValueParseFailure",
        "kind": 6,
        "importPath": "custard.expect.exceptions",
        "description": "custard.expect.exceptions",
        "peekOfCode": "class ExpectValueParseFailure(Exception):\n    pass",
        "detail": "custard.expect.exceptions",
        "documentation": {}
    },
    {
        "label": "args_to_str",
        "kind": 2,
        "importPath": "custard.expect.record",
        "description": "custard.expect.record",
        "peekOfCode": "def args_to_str(*args, **kwargs):\n    \"\"\"\n    args  str\n    Args:\n        *args:\n        **kwargs:\n    Returns:\n    \"\"\"\n    str1 = \", \".join(str(i) for i in args)\n    kv = []",
        "detail": "custard.expect.record",
        "documentation": {}
    },
    {
        "label": "handle_exception",
        "kind": 2,
        "importPath": "custard.expect.record",
        "description": "custard.expect.record",
        "peekOfCode": "def handle_exception(retry_times=0, error_detail_level=0, is_throw_error=False, time_sleep=0, logger=None):\n    \"\"\"\n    ,\n    Args:\n        retry_times: \n        error_detail_level: 0exception132\n        is_throw_error: \n        time_sleep: \n        logger:\n    Returns:",
        "detail": "custard.expect.record",
        "documentation": {}
    },
    {
        "label": "keep_circulating",
        "kind": 2,
        "importPath": "custard.expect.spacer",
        "description": "custard.expect.spacer",
        "peekOfCode": "def keep_circulating(time_sleep=0.001, exit_if_function_run_succeed=True, is_display_detail_exception=True,\n                     block=True, daemon=False, logger=None):\n    \"\"\"\n    \n    Args:\n        time_sleep: \n        exit_if_function_run_succeed: \n        is_display_detail_exception:  \n        block: Falsewhile 1\n        daemon: while 1",
        "detail": "custard.expect.spacer",
        "documentation": {}
    },
    {
        "label": "where_is_it_called",
        "kind": 2,
        "importPath": "custard.function.callsource",
        "description": "custard.function.callsource",
        "peekOfCode": "def where_is_it_called(func):\n    \"\"\",\"\"\"\n    @wraps(func)\n    def _where_is_it_called(*args, **kwargs):\n        # \n        # func_name = sys._getframe().f_code.co_name\n        func_name = func.__name__\n        # \n        which_fun_call_this = sys._getframe(1).f_code.co_name  # NOQA\n        # ",
        "detail": "custard.function.callsource",
        "documentation": {}
    },
    {
        "label": "bind_run_many_times",
        "kind": 2,
        "importPath": "custard.function.traverse",
        "description": "custard.function.traverse",
        "peekOfCode": "def bind_run_many_times(times=1, logger=None):\n    \"\"\"\n    \n    Args:\n        times: \n        logger: \n    Returns: handle_exceptionn\n    Examples:\n        >>> import time\n        >>> @bind_run_many_times(5)",
        "detail": "custard.function.traverse",
        "documentation": {}
    },
    {
        "label": "DFAFilter",
        "kind": 6,
        "importPath": "custard.hitfilter.hitfilter",
        "description": "custard.hitfilter.hitfilter",
        "peekOfCode": "class DFAFilter:\n    \"\"\"\n    Filter Messages from keywords\n    Use DFA to keep algorithm perform constantly\n    >>> f = DFAFilter()\n    >>> f.add(\"sexy\")\n    >>> f.filter(\"hello sexy baby\")\n    \"\"\"\n    def __init__(self):\n        self.keyword_path = [f\"{os.path.dirname(os.path.realpath(__file__))}/keywords\"]",
        "detail": "custard.hitfilter.hitfilter",
        "documentation": {}
    },
    {
        "label": "JsonEncoder",
        "kind": 6,
        "importPath": "custard.json.jsonlogger",
        "description": "custard.json.jsonlogger",
        "peekOfCode": "class JsonEncoder(json.JSONEncoder):\n    \"\"\"\n    A custom encoder extending the default JSONEncoder\n    \"\"\"\n    def default(self, obj):\n        if isinstance(obj, (date, datetime, time)):\n            return self.format_datetime_obj(obj)\n        elif istraceback(obj):\n            return ''.join(traceback.format_tb(obj)).strip()\n        elif type(obj) == Exception \\",
        "detail": "custard.json.jsonlogger",
        "documentation": {}
    },
    {
        "label": "JsonFormatter",
        "kind": 6,
        "importPath": "custard.json.jsonlogger",
        "description": "custard.json.jsonlogger",
        "peekOfCode": "class JsonFormatter(logging.Formatter):\n    \"\"\"\n    A custom formatter to format logging records as json strings.\n    Extra values will be formatted as str() if not supported by\n    json default encoder\n    \"\"\"\n    def __init__(self, *args, **kwargs):\n        \"\"\"\n        Args:\n            json_default: a function for encoding non-standard objects",
        "detail": "custard.json.jsonlogger",
        "documentation": {}
    },
    {
        "label": "merge_record_extra",
        "kind": 2,
        "importPath": "custard.json.jsonlogger",
        "description": "custard.json.jsonlogger",
        "peekOfCode": "def merge_record_extra(record, target, reserved):\n    \"\"\"\n        Merges extra attributes from LogRecord object into target dictionary\n    Args:\n        record: logging.LogRecord\n        target: dict to update\n        reserved: dict or list with reserved keys to skip\n    Returns:\n    \"\"\"\n    for key, value in record.__dict__.items():",
        "detail": "custard.json.jsonlogger",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "custard.json.jsonlogger",
        "description": "custard.json.jsonlogger",
        "peekOfCode": "__all__ = (\"JsonEncoder\", \"JsonFormatter\", \"merge_record_extra\")\nRESERVED_ATTRS = (\n    'args', 'asctime', 'created', 'exc_info', 'exc_text', 'filename',\n    'funcName', 'levelname', 'levelno', 'lineno', 'module',\n    'msecs', 'message', 'msg', 'name', 'pathname', 'process',\n    'processName', 'relativeCreated', 'stack_info', 'thread', 'threadName')\ndef merge_record_extra(record, target, reserved):\n    \"\"\"\n        Merges extra attributes from LogRecord object into target dictionary\n    Args:",
        "detail": "custard.json.jsonlogger",
        "documentation": {}
    },
    {
        "label": "RESERVED_ATTRS",
        "kind": 5,
        "importPath": "custard.json.jsonlogger",
        "description": "custard.json.jsonlogger",
        "peekOfCode": "RESERVED_ATTRS = (\n    'args', 'asctime', 'created', 'exc_info', 'exc_text', 'filename',\n    'funcName', 'levelname', 'levelno', 'lineno', 'module',\n    'msecs', 'message', 'msg', 'name', 'pathname', 'process',\n    'processName', 'relativeCreated', 'stack_info', 'thread', 'threadName')\ndef merge_record_extra(record, target, reserved):\n    \"\"\"\n        Merges extra attributes from LogRecord object into target dictionary\n    Args:\n        record: logging.LogRecord",
        "detail": "custard.json.jsonlogger",
        "documentation": {}
    },
    {
        "label": "CaptchaPainter",
        "kind": 6,
        "importPath": "custard.kaptcha.captcha",
        "description": "custard.kaptcha.captcha",
        "peekOfCode": "class CaptchaPainter:\n    def __fill_color(self):\n        \"\"\"\n        \n        :return:\n        \"\"\"\n        if self.mode == \"RGB\" or self.mode == \"RGBW\":\n            return random.randint(0, 255), random.randint(0, 255), random.randint(0, 255), random.randint(150, 255)\n        else:\n            return random.randint(0, 155)",
        "detail": "custard.kaptcha.captcha",
        "documentation": {}
    },
    {
        "label": "Captcha",
        "kind": 6,
        "importPath": "custard.kaptcha.captcha",
        "description": "custard.kaptcha.captcha",
        "peekOfCode": "class Captcha:\n    @staticmethod\n    def __rand(string, k):\n        return \"\".join(random.choices(string, k=k))\n    def __filter(self, _im):\n        if self.contour:\n            return _im.filter(ImageFilter.CONTOUR)\n        elif self.enhance:\n            return _im.filter(ImageFilter.EDGE_ENHANCE_MORE)\n        elif self.edge:",
        "detail": "custard.kaptcha.captcha",
        "documentation": {}
    },
    {
        "label": "ascii_letters",
        "kind": 5,
        "importPath": "custard.kaptcha.captcha",
        "description": "custard.kaptcha.captcha",
        "peekOfCode": "ascii_letters = ascii_letters.replace(\"i\", \"\").replace(\"l\", \"\") \\\n    .replace(\"I\", \"\").replace(\"Q\", \"\").replace(\"j\", \"\").replace(\"q\", \"\")\ndigits = digits.replace(\"0\", \"\")\nBASE_DIR = os.path.dirname(os.path.realpath(__file__))\nFONT = [BASE_DIR + \"/font1.ttf\",\n        BASE_DIR + \"/font2.ttf\",\n        BASE_DIR + \"/font3.ttf\",\n        BASE_DIR + \"/font4.ttf\"]  # https://fonts.google.com/\nclass CaptchaPainter:\n    def __fill_color(self):",
        "detail": "custard.kaptcha.captcha",
        "documentation": {}
    },
    {
        "label": "digits",
        "kind": 5,
        "importPath": "custard.kaptcha.captcha",
        "description": "custard.kaptcha.captcha",
        "peekOfCode": "digits = digits.replace(\"0\", \"\")\nBASE_DIR = os.path.dirname(os.path.realpath(__file__))\nFONT = [BASE_DIR + \"/font1.ttf\",\n        BASE_DIR + \"/font2.ttf\",\n        BASE_DIR + \"/font3.ttf\",\n        BASE_DIR + \"/font4.ttf\"]  # https://fonts.google.com/\nclass CaptchaPainter:\n    def __fill_color(self):\n        \"\"\"\n        ",
        "detail": "custard.kaptcha.captcha",
        "documentation": {}
    },
    {
        "label": "BASE_DIR",
        "kind": 5,
        "importPath": "custard.kaptcha.captcha",
        "description": "custard.kaptcha.captcha",
        "peekOfCode": "BASE_DIR = os.path.dirname(os.path.realpath(__file__))\nFONT = [BASE_DIR + \"/font1.ttf\",\n        BASE_DIR + \"/font2.ttf\",\n        BASE_DIR + \"/font3.ttf\",\n        BASE_DIR + \"/font4.ttf\"]  # https://fonts.google.com/\nclass CaptchaPainter:\n    def __fill_color(self):\n        \"\"\"\n        \n        :return:",
        "detail": "custard.kaptcha.captcha",
        "documentation": {}
    },
    {
        "label": "FONT",
        "kind": 5,
        "importPath": "custard.kaptcha.captcha",
        "description": "custard.kaptcha.captcha",
        "peekOfCode": "FONT = [BASE_DIR + \"/font1.ttf\",\n        BASE_DIR + \"/font2.ttf\",\n        BASE_DIR + \"/font3.ttf\",\n        BASE_DIR + \"/font4.ttf\"]  # https://fonts.google.com/\nclass CaptchaPainter:\n    def __fill_color(self):\n        \"\"\"\n        \n        :return:\n        \"\"\"",
        "detail": "custard.kaptcha.captcha",
        "documentation": {}
    },
    {
        "label": "RateLimiter",
        "kind": 6,
        "importPath": "custard.limiter.depends",
        "description": "custard.limiter.depends",
        "peekOfCode": "class RateLimiter:\n    def __init__(\n            self,\n            counts: conint(ge=0) = 1,\n            milliseconds: conint(ge=-1) = 0,\n            seconds: conint(ge=-1) = 0,\n            minutes: conint(ge=-1) = 0,\n            hours: conint(ge=-1) = 0,\n            identifier: Optional[Callable] = None,\n            callback: Optional[Callable] = None,",
        "detail": "custard.limiter.depends",
        "documentation": {}
    },
    {
        "label": "GlobalVarEnum",
        "kind": 6,
        "importPath": "custard.limiter.enums",
        "description": "custard.limiter.enums",
        "peekOfCode": "class GlobalVarEnum:\n    APP_NAME = \"custard\"",
        "detail": "custard.limiter.enums",
        "documentation": {}
    },
    {
        "label": "RateLimitException",
        "kind": 6,
        "importPath": "custard.limiter.execres",
        "description": "custard.limiter.execres",
        "peekOfCode": "class RateLimitException(Exception):\n    def __init__(\n            self,\n            headers: dict,\n            code: int = 429,\n            detail: str = \"The interview is too fast, please have a cup of tea and take a break!\",\n            status_code: int = status.HTTP_429_TOO_MANY_REQUESTS,\n    ):\n        self.code = code\n        self.headers = headers",
        "detail": "custard.limiter.execres",
        "documentation": {}
    },
    {
        "label": "sync_redis_lock",
        "kind": 2,
        "importPath": "custard.lock.redis_lock",
        "description": "custard.lock.redis_lock",
        "peekOfCode": "def sync_redis_lock(key, client, lock_time_out):\n    \"\"\"\n    redis\n    todo:,,\n    redis\n        rediskey,value\n        get keyvalue\n        setnx str.key,0().key,1\n        getset strvaluevalue\n    ",
        "detail": "custard.lock.redis_lock",
        "documentation": {}
    },
    {
        "label": "synchronized_lock",
        "kind": 2,
        "importPath": "custard.lock.thread_lock",
        "description": "custard.lock.thread_lock",
        "peekOfCode": "def synchronized_lock(func):\n    \"\"\"\n    \n    Args:\n        func:\n    Returns:\n    \"\"\"\n    func.__lock__ = threading.Lock()\n    @wraps(func)\n    def lock_func(*args, **kwargs):",
        "detail": "custard.lock.thread_lock",
        "documentation": {}
    },
    {
        "label": "singleton_lock",
        "kind": 2,
        "importPath": "custard.lock.thread_lock",
        "description": "custard.lock.thread_lock",
        "peekOfCode": "def singleton_lock(cls):\n    \"\"\"\n    ,100,\n    Args:\n        cls:\n    Returns:\n    \"\"\"\n    _instance = {}\n    singleton_lock.__lock = threading.Lock()\n    @wraps(cls)",
        "detail": "custard.lock.thread_lock",
        "documentation": {}
    },
    {
        "label": "chunk",
        "kind": 2,
        "importPath": "custard.lodash.arrays",
        "description": "custard.lodash.arrays",
        "peekOfCode": "def chunk(array, size=1):\n    \"\"\"Creates an array of elements split into groups the length of size. If array can't be split evenly, the final chunk will be the remaining elements.\n    Arguments:\n        array {list} -- The array to process\n    Keyword Arguments:\n        size {int} -- The length of each chunk (default: {1})\n    Returns:\n        (list) -- Returns the new array of chunks.\n    \"\"\"\n    result = []",
        "detail": "custard.lodash.arrays",
        "documentation": {}
    },
    {
        "label": "append_list",
        "kind": 2,
        "importPath": "custard.lodash.arrays",
        "description": "custard.lodash.arrays",
        "peekOfCode": "def append_list(array, size, result):\n    \"\"\"Creates an arrays with small array inside\n    Arguments:\n        array {list} -- The array to process\n        size {int} -- The length of each chunk\n        result {type} -- New arrays of chunks\n    Returns:\n        (list) -- Returns the new array of chunks\n    \"\"\"\n    # condition to stop recusion",
        "detail": "custard.lodash.arrays",
        "documentation": {}
    },
    {
        "label": "compact",
        "kind": 2,
        "importPath": "custard.lodash.arrays",
        "description": "custard.lodash.arrays",
        "peekOfCode": "def compact(array):\n    \"\"\"Creates an array with all falsey values removed. The values False, None, and \"\" are falsey.\n    Arguments:\n        array {list} -- The array to compact.\n    Returns:\n        (list) -- Returns the new array of filtered values.\n    \"\"\"\n    return [i for i in array if i not in [False, None, '']]\ndef difference(array, values):\n    \"\"\"Creates an array of array values not included in the other given arrays using SameValueZero for equality comparisons. The order and references of result values are determined by the first array.",
        "detail": "custard.lodash.arrays",
        "documentation": {}
    },
    {
        "label": "difference",
        "kind": 2,
        "importPath": "custard.lodash.arrays",
        "description": "custard.lodash.arrays",
        "peekOfCode": "def difference(array, values):\n    \"\"\"Creates an array of array values not included in the other given arrays using SameValueZero for equality comparisons. The order and references of result values are determined by the first array.\n    Arguments:\n        array {list} -- The array to inspect.\n        values {list} -- The values to exclude.\n    Returns:\n        (list) -- Returns the new array of filtered values.\n    \"\"\"\n    return list(set(array) - set(values))\ndef drop(array, number=1):",
        "detail": "custard.lodash.arrays",
        "documentation": {}
    },
    {
        "label": "drop",
        "kind": 2,
        "importPath": "custard.lodash.arrays",
        "description": "custard.lodash.arrays",
        "peekOfCode": "def drop(array, number=1):\n    \"\"\"Creates a slice of array with n elements dropped from the beginning.\n    Arguments:\n        array {list} -- The array to query.\n    Keyword Arguments:\n        number {int} -- The number of elements to drop. (default: {1})\n    Returns:\n        (list) -- Returns the slice of array.\n    \"\"\"\n    return array[number: len(array)] if helper.is_number(number) else array",
        "detail": "custard.lodash.arrays",
        "documentation": {}
    },
    {
        "label": "drop_right",
        "kind": 2,
        "importPath": "custard.lodash.arrays",
        "description": "custard.lodash.arrays",
        "peekOfCode": "def drop_right(array, number=1):\n    \"\"\"Creates a slice of array with n elements dropped from the end.\n    Arguments:\n        array {list} -- The array to query.\n    Keyword Arguments:\n        number {int} -- The number of elements to drop. (default: {1})\n    Returns:\n        (list) -- Returns the slice of array.\n    \"\"\"\n    if helper.is_number(number) is True and len(array) < number:",
        "detail": "custard.lodash.arrays",
        "documentation": {}
    },
    {
        "label": "fill",
        "kind": 2,
        "importPath": "custard.lodash.arrays",
        "description": "custard.lodash.arrays",
        "peekOfCode": "def fill(array, value, start=0, end=None):\n    \"\"\"Fills elements of array with value from start up to, but not including, end.\n    Arguments:\n        array {list} -- The array to fill.\n        value {*} -- The value to fill array with.\n    Keyword Arguments:\n        start {int} -- The start position. (default: {0})\n        end {*} -- The end position. (default: {None})\n    Returns:\n        (list) -- Returns array",
        "detail": "custard.lodash.arrays",
        "documentation": {}
    },
    {
        "label": "index_of",
        "kind": 2,
        "importPath": "custard.lodash.arrays",
        "description": "custard.lodash.arrays",
        "peekOfCode": "def index_of(array, value=None, fromIndex=0):\n    \"\"\"Gets the index at which the first occurrence of value is found in array using SameValueZero for equality comparisons. If fromIndex is negative, it's used as the offset from the end of array.\n    Arguments:\n        array {list} -- The array to inspect\n    Keyword Arguments:\n        value {*} -- The value to search for (default: {None})\n        fromIndex {int} -- The index to search from (default: {0})\n    Returns:\n        (number) -- Returns the index of the matched value, else -1.\n    \"\"\"",
        "detail": "custard.lodash.arrays",
        "documentation": {}
    },
    {
        "label": "initial",
        "kind": 2,
        "importPath": "custard.lodash.arrays",
        "description": "custard.lodash.arrays",
        "peekOfCode": "def initial(array):\n    \"\"\"Gets all but the last element of array\n    Arguments:\n        array {list} -- The array to query\n    Returns:\n        (list) -- Returns the slice of array\n    \"\"\"\n    return [item for index, item in enumerate(array) if index != len(array) - 1] if isinstance(\n        array, list) else []\ndef pull(array, *args):",
        "detail": "custard.lodash.arrays",
        "documentation": {}
    },
    {
        "label": "pull",
        "kind": 2,
        "importPath": "custard.lodash.arrays",
        "description": "custard.lodash.arrays",
        "peekOfCode": "def pull(array, *args):\n    \"\"\"Removes all given values from array using SameValueZero for equality comparisons\n    Arguments:\n        array {list} -- The array to modify\n        [values](...*): -- The values to remove\n    Returns:\n        (list) -- Returns array\n    \"\"\"\n    return [i for i in array if i not in args]",
        "detail": "custard.lodash.arrays",
        "documentation": {}
    },
    {
        "label": "add",
        "kind": 2,
        "importPath": "custard.lodash.maths",
        "description": "custard.lodash.maths",
        "peekOfCode": "def add(augend, addend):\n    \"\"\"Adds two numbers\n    Arguments:\n        augend {number} -- The first number in an addition\n        addend {number} -- The second number in an addition\n    Returns:\n        (number) -- Returns the total\n    \"\"\"\n    return augend + addend if helpers.is_number(augend) and helpers.is_number(addend) else str(\n        augend) + str(addend)",
        "detail": "custard.lodash.maths",
        "documentation": {}
    },
    {
        "label": "ceil",
        "kind": 2,
        "importPath": "custard.lodash.maths",
        "description": "custard.lodash.maths",
        "peekOfCode": "def ceil(number, precision=0):\n    \"\"\"Computes number rounded up to precision\n    Arguments:\n        number {number} -- The number to round up\n    Keyword Arguments:\n        precision {int} -- The precision to round up to (default: {0})\n    Returns:\n        (number) -- Returns the rounded up number\n    \"\"\"\n    return call_math_operator(number, precision, math.ceil)",
        "detail": "custard.lodash.maths",
        "documentation": {}
    },
    {
        "label": "divide",
        "kind": 2,
        "importPath": "custard.lodash.maths",
        "description": "custard.lodash.maths",
        "peekOfCode": "def divide(dividend, divisor):\n    \"\"\"Divide two numbers\n    Arguments:\n        dividend {number]} -- The first number in a division\n        divisor {[number} -- The second number in a division\n    Returns:\n        (number) -- Returns the quotient\n    \"\"\"\n    try:\n        return dividend / divisor",
        "detail": "custard.lodash.maths",
        "documentation": {}
    },
    {
        "label": "call_math_operator",
        "kind": 2,
        "importPath": "custard.lodash.maths",
        "description": "custard.lodash.maths",
        "peekOfCode": "def call_math_operator(number, precision=0, op=None):\n    \"\"\"Computes numbers ceil or floor base on operator\n    Arguments:\n        number {number} -- The number to round\n    Keyword Arguments:\n        precision {int} -- The precision to round (default: {0})\n        op {*} -- The operator to round (default: {None})\n    Returns:\n        (number) -- Returns the rounded number\n    \"\"\"",
        "detail": "custard.lodash.maths",
        "documentation": {}
    },
    {
        "label": "floor",
        "kind": 2,
        "importPath": "custard.lodash.maths",
        "description": "custard.lodash.maths",
        "peekOfCode": "def floor(number, precision=0):\n    \"\"\"Computes number rounded down to precision.\n    Arguments:\n        number {number} -- The number to round down\n    Keyword Arguments:\n        precision {number} -- The precision to round down to (default: {0})\n    Returns:\n        (number) -- Returns the rounded down number.\n    \"\"\"\n    return call_math_operator(number, precision, math.floor)",
        "detail": "custard.lodash.maths",
        "documentation": {}
    },
    {
        "label": "max",
        "kind": 2,
        "importPath": "custard.lodash.maths",
        "description": "custard.lodash.maths",
        "peekOfCode": "def max(array):\n    \"\"\"Computes the maximum value of array. If array is empty or falsey, undefined is returned\n    Arguments:\n        array {list} -- The array to iterate over\n    Returns:\n        (*) -- Returns the maximum value\n    \"\"\"\n    if len(array) == 0:\n        return None\n    max = 0",
        "detail": "custard.lodash.maths",
        "documentation": {}
    },
    {
        "label": "mean",
        "kind": 2,
        "importPath": "custard.lodash.maths",
        "description": "custard.lodash.maths",
        "peekOfCode": "def mean(array):\n    \"\"\"Computes the mean of the values in array\n    Arguments:\n        array {list} -- The array to iterate over\n    Returns:\n        (number) -- Returns the mean\n    \"\"\"\n    try:\n        return sum(array) / len(array)\n    except ZeroDivisionError as detail:",
        "detail": "custard.lodash.maths",
        "documentation": {}
    },
    {
        "label": "min",
        "kind": 2,
        "importPath": "custard.lodash.maths",
        "description": "custard.lodash.maths",
        "peekOfCode": "def min(array):\n    \"\"\"Computes the minimum value of array. If array is empty or falsey, undefined is returned\n    Arguments:\n        array {list} -- The array to iterate over\n    Returns:\n        (*) -- Returns the minimum value\n    \"\"\"\n    if len(array) == 0:\n        return None\n    min = array[0]",
        "detail": "custard.lodash.maths",
        "documentation": {}
    },
    {
        "label": "multiply",
        "kind": 2,
        "importPath": "custard.lodash.maths",
        "description": "custard.lodash.maths",
        "peekOfCode": "def multiply(multiplier, multiplicand):\n    \"\"\"Multiply two numbers\n    Arguments:\n        multiplier {number} --  The first number in a multiplication.\n        multiplicand {number} -- The second number in a multiplication\n    Returns:\n        (number) -- Returns the product\n    \"\"\"\n    return multiplier * multiplicand\ndef substract(minuend, subtrahend):",
        "detail": "custard.lodash.maths",
        "documentation": {}
    },
    {
        "label": "substract",
        "kind": 2,
        "importPath": "custard.lodash.maths",
        "description": "custard.lodash.maths",
        "peekOfCode": "def substract(minuend, subtrahend):\n    \"\"\"Subtract two numbers\n    Arguments:\n        minuend {number} -- The first number in a subtraction\n        subtrahend {number} -- The second number in a subtraction\n    Returns:\n        (number) -- Returns the difference\n    \"\"\"\n    return minuend - subtrahend\ndef sum(array):",
        "detail": "custard.lodash.maths",
        "documentation": {}
    },
    {
        "label": "sum",
        "kind": 2,
        "importPath": "custard.lodash.maths",
        "description": "custard.lodash.maths",
        "peekOfCode": "def sum(array):\n    \"\"\"Computes the sum of the values in array\n    Arguments:\n        array {list} -- The array to iterate over\n    Returns:\n        (number) -- Returns the sum\n    \"\"\"\n    result = 0\n    for i in array:\n        result += i",
        "detail": "custard.lodash.maths",
        "documentation": {}
    },
    {
        "label": "clamp",
        "kind": 2,
        "importPath": "custard.lodash.number",
        "description": "custard.lodash.number",
        "peekOfCode": "def clamp(number, lower, upper):\n    \"\"\"Clamps number within the inclusive lower and upper bounds\n    Arguments:\n        number {number]} -- The number to clamp\n        lower {[number} -- The lower bound\n        upper {[number} -- The upper bound\n    Returns:\n        (number) -- Returns the clamped number\n    \"\"\"\n    if is_clamp(number, lower, upper):",
        "detail": "custard.lodash.number",
        "documentation": {}
    },
    {
        "label": "is_clamp",
        "kind": 2,
        "importPath": "custard.lodash.number",
        "description": "custard.lodash.number",
        "peekOfCode": "def is_clamp(number, lower, upper):\n    \"\"\"Check clamp number within the inclusive lower and upper bounds\n    Arguments:\n        number {number} -- The number to clamp\n        lower {number} -- The lower bound\n        upper {number} -- The upper bound\n    Returns:\n        (bool) -- Returns number is clamp or not\n    \"\"\"\n    return is_between(lower, number, upper) or is_between(upper, number, lower)",
        "detail": "custard.lodash.number",
        "documentation": {}
    },
    {
        "label": "is_between",
        "kind": 2,
        "importPath": "custard.lodash.number",
        "description": "custard.lodash.number",
        "peekOfCode": "def is_between(a, b, c):\n    \"\"\"Check a number is between two other numbers\n    Arguments:\n        a {number} -- The first number\n        b {number} -- The second number\n        c {number} -- The third number\n    Returns:\n        (bool) -- Return True if number is between else False\n    \"\"\"\n    return a <= b <= c",
        "detail": "custard.lodash.number",
        "documentation": {}
    },
    {
        "label": "in_range",
        "kind": 2,
        "importPath": "custard.lodash.number",
        "description": "custard.lodash.number",
        "peekOfCode": "def in_range(number, start, end=None):\n    \"\"\"Checks if n is between start and up to, but not including, end. If end is not specified, it's set to start with start then set to 0. If start is greater than end the params are swapped to support negative ranges.\n    Arguments:\n        number {number} -- The number to check\n        start {number} -- The start of the range\n    Keyword Arguments:\n        end {*} -- The end of the range. (default: {None})\n    Returns:\n        (boolean) -- Returns True if number is in the range, else False\n    \"\"\"",
        "detail": "custard.lodash.number",
        "documentation": {}
    },
    {
        "label": "basein_range",
        "kind": 2,
        "importPath": "custard.lodash.number",
        "description": "custard.lodash.number",
        "peekOfCode": "def basein_range(number, start, end):\n    \"\"\"Check number is between range\n    Arguments:\n        number {number} -- The number to check\n        start {number} -- The number start of range\n        end {number} -- The number end of range\n    Returns:\n        (boolean) -- Returns True if number is between of range\n    \"\"\"\n    return min(start, end) <= number < max(start, end)",
        "detail": "custard.lodash.number",
        "documentation": {}
    },
    {
        "label": "random",
        "kind": 2,
        "importPath": "custard.lodash.number",
        "description": "custard.lodash.number",
        "peekOfCode": "def random(lower=0, upper=1, floating=False):\n    \"\"\"Produces a random number between the inclusive lower and upper bounds. If only one argument is provided a number between 0 and the given number is returned. If floating is true, or either lower or upper are floats, a floating-point number is returned instead of an integer.\n    Keyword Arguments:\n        lower {int} -- The lower bound (default: {0})\n        upper {int} -- The upper bound (default: {1})\n        floating {bool} -- Specify returning a floating-point number (default: {False})\n    Returns:\n        (number) -- Returns the random number\n    \"\"\"\n    floating = (isinstance(lower, float) or",
        "detail": "custard.lodash.number",
        "documentation": {}
    },
    {
        "label": "camel_case",
        "kind": 2,
        "importPath": "custard.lodash.string",
        "description": "custard.lodash.string",
        "peekOfCode": "def camel_case(string=''):\n    \"\"\"Converts string to camel case\n    Keyword Arguments:\n        string {str} -- The string to convert (default: {''})\n    Returns:\n        (string) -- Returns the camel cased string\n    \"\"\"\n    items = replace_special_characters(string)\n    # format first letter for word\n    result = [item.lower() if index == 0 else item[0].upper() + item[1:].lower() for index, item in",
        "detail": "custard.lodash.string",
        "documentation": {}
    },
    {
        "label": "replace_special_characters",
        "kind": 2,
        "importPath": "custard.lodash.string",
        "description": "custard.lodash.string",
        "peekOfCode": "def replace_special_characters(string=''):\n    \"\"\"Replace all special characters of string\n    Keyword Arguments:\n        string {str} -- The string to replacement (default: {''})\n    Returns:\n        (list) -- Returns a list string\n    \"\"\"\n    # remove all special characters base on pattern\n    items = re.split('[-_*)( %^$#@!]', str(string))\n    # remove all elements is empty, None, False",
        "detail": "custard.lodash.string",
        "documentation": {}
    },
    {
        "label": "capitalize",
        "kind": 2,
        "importPath": "custard.lodash.string",
        "description": "custard.lodash.string",
        "peekOfCode": "def capitalize(string=''):\n    \"\"\"Converts the first character of string to upper case and the remaining to lower case\n    Keyword Arguments:\n        string {str} -- The string to capitalize (default: {''})\n    Returns:\n        (string) -- Returns the capitalized string\n    \"\"\"\n    format_string = str(string)\n    return format_string[0].upper() + format_string[1:].lower()\ndef ends_with(string='', target=None, position=None):",
        "detail": "custard.lodash.string",
        "documentation": {}
    },
    {
        "label": "ends_with",
        "kind": 2,
        "importPath": "custard.lodash.string",
        "description": "custard.lodash.string",
        "peekOfCode": "def ends_with(string='', target=None, position=None):\n    \"\"\"Checks if string ends with the given target string\n    Keyword Arguments:\n        string {str} -- The string to inspect (default: {''})\n        target {[type]} -- The string to search for (default: {None})\n        position {[type]} -- The position to search up to (default: {None})\n    Returns:\n        (boolean) -- Returns true if string ends with target, else false\n    \"\"\"\n    format_string = str(string)",
        "detail": "custard.lodash.string",
        "documentation": {}
    },
    {
        "label": "string_replace",
        "kind": 2,
        "importPath": "custard.lodash.string",
        "description": "custard.lodash.string",
        "peekOfCode": "def string_replace(string, old_character, new_character):\n    \"\"\"Replace string with new characters\n    Arguments:\n        string {string} -- The string to replace\n        old_character {string} -- Old character need to replace\n        new_character {string} -- New character to replace\n    Returns:\n        (string) -- Returns the string with new character\n    \"\"\"\n    if old_character in str(string):",
        "detail": "custard.lodash.string",
        "documentation": {}
    },
    {
        "label": "escape",
        "kind": 2,
        "importPath": "custard.lodash.string",
        "description": "custard.lodash.string",
        "peekOfCode": "def escape(string=''):\n    \"\"\"Converts the characters \"&\", \"<\", \">\", '\"', and \"'\" in string to their corresponding HTML entities\n    Keyword Arguments:\n        string {str} -- The string to escape (default: {''})\n    Returns:\n        (string) -- Returns the escaped string\n    \"\"\"\n    characters = {\n        '&': '&amp;',\n        '>': '&gt;',",
        "detail": "custard.lodash.string",
        "documentation": {}
    },
    {
        "label": "lower_case",
        "kind": 2,
        "importPath": "custard.lodash.string",
        "description": "custard.lodash.string",
        "peekOfCode": "def lower_case(string=''):\n    \"\"\"Converts string, as space separated words, to lower case\n    Keyword Arguments:\n        string {str} -- The string to convert (default: {''})\n    Returns:\n        string -- Returns the lower cased string\n    \"\"\"\n    items = replace_special_characters(string)\n    result = [i.lower() for i in items]\n    return ' '.join(result)",
        "detail": "custard.lodash.string",
        "documentation": {}
    },
    {
        "label": "lower_first",
        "kind": 2,
        "importPath": "custard.lodash.string",
        "description": "custard.lodash.string",
        "peekOfCode": "def lower_first(string=''):\n    \"\"\"Converts the first character of string to lower case\n    Keyword Arguments:\n        string {str} -- The string to convert (default: {''})\n    Returns:\n        (string) -- Returns the converted string\n    \"\"\"\n    format_string = str(string)\n    return format_string[0].lower() + format_string[1:]\ndef pad_characters(chars, position):",
        "detail": "custard.lodash.string",
        "documentation": {}
    },
    {
        "label": "pad_characters",
        "kind": 2,
        "importPath": "custard.lodash.string",
        "description": "custard.lodash.string",
        "peekOfCode": "def pad_characters(chars, position):\n    \"\"\"Split string with position\n    Arguments:\n        chars {string} -- The string to split\n        position {number} -- Position of string to split\n    Returns:\n        (string) -- Returns substring\n    \"\"\"\n    return (chars * position)[0:position]\ndef pad(string='', length=0, chars=' '):",
        "detail": "custard.lodash.string",
        "documentation": {}
    },
    {
        "label": "pad",
        "kind": 2,
        "importPath": "custard.lodash.string",
        "description": "custard.lodash.string",
        "peekOfCode": "def pad(string='', length=0, chars=' '):\n    \"\"\"Pads string on the left and right sides if it's shorter than length. Padding characters are truncated if they can't be evenly divided by length.\n    Keyword Arguments:\n        string {str} -- The string to pad (default: {''})\n        length {int} -- The padding length (default: {0})\n        chars {str} -- The string used as padding (default: {' '})\n    Returns:\n        (string) -- Returns the padded string\n    \"\"\"\n    format_string = str(string)",
        "detail": "custard.lodash.string",
        "documentation": {}
    },
    {
        "label": "pad_end",
        "kind": 2,
        "importPath": "custard.lodash.string",
        "description": "custard.lodash.string",
        "peekOfCode": "def pad_end(string='', length=0, chars=' '):\n    \"\"\"Pads string on the right side if it's shorter than length. Padding characters are truncated if they exceed length\n    Keyword Arguments:\n        string {str} -- The string to pad (default: {''})\n        length {int} -- The padding length (default: {0})\n        chars {str} -- The string used as padding (default: {' '})\n    Returns:\n        (string) -- Returns the padded string\n    \"\"\"\n    format_string = str(string)",
        "detail": "custard.lodash.string",
        "documentation": {}
    },
    {
        "label": "pad_start",
        "kind": 2,
        "importPath": "custard.lodash.string",
        "description": "custard.lodash.string",
        "peekOfCode": "def pad_start(string='', length=0, chars=' '):\n    \"\"\"Pads string on the left side if it's shorter than length. Padding characters are truncated if they exceed length\n    Keyword Arguments:\n        string {str} -- The string to pad (default: {''})\n        length {int} -- The padding length (default: {0})\n        chars {str} -- The string used as padding (default: {' '})\n    Returns:\n        (string) -- Returns the padded string\n    \"\"\"\n    format_string = str(string)",
        "detail": "custard.lodash.string",
        "documentation": {}
    },
    {
        "label": "repeat",
        "kind": 2,
        "importPath": "custard.lodash.string",
        "description": "custard.lodash.string",
        "peekOfCode": "def repeat(string='', n=1):\n    \"\"\"Repeats the given string n times\n    Keyword Arguments:\n        string {str} -- The string to repeat (default: {''})\n        n {int} -- The number of times to repeat the string (default: {1})\n    Returns:\n        (string) -- Returns the repeated string\n    \"\"\"\n    return str(string) * n\ndef replace(string, pattern, replacement):",
        "detail": "custard.lodash.string",
        "documentation": {}
    },
    {
        "label": "replace",
        "kind": 2,
        "importPath": "custard.lodash.string",
        "description": "custard.lodash.string",
        "peekOfCode": "def replace(string, pattern, replacement):\n    \"\"\"Replaces matches for pattern in string with replacement\n    Arguments:\n        string {string} -- The string to modify\n        pattern {RegExp|string} -- The pattern to replace\n        replacement {Function|string)} -- The match replacement\n    Returns:\n        (string) -- Returns the modified string\n    \"\"\"\n    return str(string).replace(pattern, replacement)",
        "detail": "custard.lodash.string",
        "documentation": {}
    },
    {
        "label": "starts_with",
        "kind": 2,
        "importPath": "custard.lodash.string",
        "description": "custard.lodash.string",
        "peekOfCode": "def starts_with(string, target, position=0):\n    \"\"\"Checks if string starts with the given target string\n    Arguments:\n        string {[type]} -- The string to inspect\n        target {[type]} -- The string to search for\n    Keyword Arguments:\n        position {int} -- The position to search from (default: {0})\n    Returns:\n        (boolean) -- Returns true if string starts with target, else false\n    \"\"\"",
        "detail": "custard.lodash.string",
        "documentation": {}
    },
    {
        "label": "is_number",
        "kind": 2,
        "importPath": "custard.lodash.utilities",
        "description": "custard.lodash.utilities",
        "peekOfCode": "def is_number(s):\n    \"\"\"Check input is number or not\n    Arguments:\n        s {*} -- The input to check\n    Returns:\n        (boolean)] -- Returns True if input a number else False\n    \"\"\"\n    try:\n        int(s)\n        return True",
        "detail": "custard.lodash.utilities",
        "documentation": {}
    },
    {
        "label": "MiniOssTypeEnum",
        "kind": 6,
        "importPath": "custard.minioss.enums",
        "description": "custard.minioss.enums",
        "peekOfCode": "class MiniOssTypeEnum:\n    ALIYUN = \"aliyun\"\n    GITEE = \"gitee\"\n    QINIU = \"qiniu\"",
        "detail": "custard.minioss.enums",
        "documentation": {}
    },
    {
        "label": "MiniRacerBaseException",
        "kind": 6,
        "importPath": "custard.mock.mini_racer",
        "description": "custard.mock.mini_racer",
        "peekOfCode": "class MiniRacerBaseException(Exception):\n    \"\"\"Base MiniRacer exception.\"\"\"\nclass JSParseException(MiniRacerBaseException):\n    \"\"\"JavaScript could not be parsed.\"\"\"\nclass JSEvalException(MiniRacerBaseException):\n    \"\"\"JavaScript could not be executed.\"\"\"\nclass JSOOMException(JSEvalException):\n    \"\"\"JavaScript execution ran out of memory.\"\"\"\nclass JSTimeoutException(JSEvalException):\n    \"\"\"JavaScript execution timed out.\"\"\"",
        "detail": "custard.mock.mini_racer",
        "documentation": {}
    },
    {
        "label": "JSParseException",
        "kind": 6,
        "importPath": "custard.mock.mini_racer",
        "description": "custard.mock.mini_racer",
        "peekOfCode": "class JSParseException(MiniRacerBaseException):\n    \"\"\"JavaScript could not be parsed.\"\"\"\nclass JSEvalException(MiniRacerBaseException):\n    \"\"\"JavaScript could not be executed.\"\"\"\nclass JSOOMException(JSEvalException):\n    \"\"\"JavaScript execution ran out of memory.\"\"\"\nclass JSTimeoutException(JSEvalException):\n    \"\"\"JavaScript execution timed out.\"\"\"\nclass JSConversionException(MiniRacerBaseException):\n    \"\"\"JavaScript type could not be converted.\"\"\"",
        "detail": "custard.mock.mini_racer",
        "documentation": {}
    },
    {
        "label": "JSEvalException",
        "kind": 6,
        "importPath": "custard.mock.mini_racer",
        "description": "custard.mock.mini_racer",
        "peekOfCode": "class JSEvalException(MiniRacerBaseException):\n    \"\"\"JavaScript could not be executed.\"\"\"\nclass JSOOMException(JSEvalException):\n    \"\"\"JavaScript execution ran out of memory.\"\"\"\nclass JSTimeoutException(JSEvalException):\n    \"\"\"JavaScript execution timed out.\"\"\"\nclass JSConversionException(MiniRacerBaseException):\n    \"\"\"JavaScript type could not be converted.\"\"\"\nclass WrongReturnTypeException(MiniRacerBaseException):\n    \"\"\"Invalid type returned by the JavaScript runtime.\"\"\"",
        "detail": "custard.mock.mini_racer",
        "documentation": {}
    },
    {
        "label": "JSOOMException",
        "kind": 6,
        "importPath": "custard.mock.mini_racer",
        "description": "custard.mock.mini_racer",
        "peekOfCode": "class JSOOMException(JSEvalException):\n    \"\"\"JavaScript execution ran out of memory.\"\"\"\nclass JSTimeoutException(JSEvalException):\n    \"\"\"JavaScript execution timed out.\"\"\"\nclass JSConversionException(MiniRacerBaseException):\n    \"\"\"JavaScript type could not be converted.\"\"\"\nclass WrongReturnTypeException(MiniRacerBaseException):\n    \"\"\"Invalid type returned by the JavaScript runtime.\"\"\"\nclass JSObject(object):\n    \"\"\"JavaScript object.\"\"\"",
        "detail": "custard.mock.mini_racer",
        "documentation": {}
    },
    {
        "label": "JSTimeoutException",
        "kind": 6,
        "importPath": "custard.mock.mini_racer",
        "description": "custard.mock.mini_racer",
        "peekOfCode": "class JSTimeoutException(JSEvalException):\n    \"\"\"JavaScript execution timed out.\"\"\"\nclass JSConversionException(MiniRacerBaseException):\n    \"\"\"JavaScript type could not be converted.\"\"\"\nclass WrongReturnTypeException(MiniRacerBaseException):\n    \"\"\"Invalid type returned by the JavaScript runtime.\"\"\"\nclass JSObject(object):\n    \"\"\"JavaScript object.\"\"\"\n    def __init__(self, id):\n        self.id = id",
        "detail": "custard.mock.mini_racer",
        "documentation": {}
    },
    {
        "label": "JSConversionException",
        "kind": 6,
        "importPath": "custard.mock.mini_racer",
        "description": "custard.mock.mini_racer",
        "peekOfCode": "class JSConversionException(MiniRacerBaseException):\n    \"\"\"JavaScript type could not be converted.\"\"\"\nclass WrongReturnTypeException(MiniRacerBaseException):\n    \"\"\"Invalid type returned by the JavaScript runtime.\"\"\"\nclass JSObject(object):\n    \"\"\"JavaScript object.\"\"\"\n    def __init__(self, id):\n        self.id = id\n    def __hash__(self):\n        return self.id",
        "detail": "custard.mock.mini_racer",
        "documentation": {}
    },
    {
        "label": "WrongReturnTypeException",
        "kind": 6,
        "importPath": "custard.mock.mini_racer",
        "description": "custard.mock.mini_racer",
        "peekOfCode": "class WrongReturnTypeException(MiniRacerBaseException):\n    \"\"\"Invalid type returned by the JavaScript runtime.\"\"\"\nclass JSObject(object):\n    \"\"\"JavaScript object.\"\"\"\n    def __init__(self, id):\n        self.id = id\n    def __hash__(self):\n        return self.id\nclass JSFunction(object):\n    \"\"\"JavaScript function.\"\"\"",
        "detail": "custard.mock.mini_racer",
        "documentation": {}
    },
    {
        "label": "JSObject",
        "kind": 6,
        "importPath": "custard.mock.mini_racer",
        "description": "custard.mock.mini_racer",
        "peekOfCode": "class JSObject(object):\n    \"\"\"JavaScript object.\"\"\"\n    def __init__(self, id):\n        self.id = id\n    def __hash__(self):\n        return self.id\nclass JSFunction(object):\n    \"\"\"JavaScript function.\"\"\"\nclass JSSymbol(object):\n    \"\"\"JavaScript symbol.\"\"\"",
        "detail": "custard.mock.mini_racer",
        "documentation": {}
    },
    {
        "label": "JSFunction",
        "kind": 6,
        "importPath": "custard.mock.mini_racer",
        "description": "custard.mock.mini_racer",
        "peekOfCode": "class JSFunction(object):\n    \"\"\"JavaScript function.\"\"\"\nclass JSSymbol(object):\n    \"\"\"JavaScript symbol.\"\"\"\ndef is_unicode(value):\n    \"\"\"Check if a value is a valid unicode string.\n    >>> is_unicode(u'foo')\n    True\n    >>> is_unicode(u'')\n    True",
        "detail": "custard.mock.mini_racer",
        "documentation": {}
    },
    {
        "label": "JSSymbol",
        "kind": 6,
        "importPath": "custard.mock.mini_racer",
        "description": "custard.mock.mini_racer",
        "peekOfCode": "class JSSymbol(object):\n    \"\"\"JavaScript symbol.\"\"\"\ndef is_unicode(value):\n    \"\"\"Check if a value is a valid unicode string.\n    >>> is_unicode(u'foo')\n    True\n    >>> is_unicode(u'')\n    True\n    >>> is_unicode(b'foo')\n    False",
        "detail": "custard.mock.mini_racer",
        "documentation": {}
    },
    {
        "label": "MiniRacer",
        "kind": 6,
        "importPath": "custard.mock.mini_racer",
        "description": "custard.mock.mini_racer",
        "peekOfCode": "class MiniRacer(object):\n    \"\"\"\n    MiniRacer evaluates JavaScript code using a V8 isolate.\n    :cvar json_impl: JSON module used by helper methods default is :py:mod:`json`\n    :cvar v8_flags: Flags used for V8 initialization\n    :vartype v8_flags: class attribute list of str\n    \"\"\"\n    json_impl = json\n    v8_flags = [\"--single-threaded\"]\n    ext = None",
        "detail": "custard.mock.mini_racer",
        "documentation": {}
    },
    {
        "label": "MiniRacerTypes",
        "kind": 6,
        "importPath": "custard.mock.mini_racer",
        "description": "custard.mock.mini_racer",
        "peekOfCode": "class MiniRacerTypes(object):\n    \"\"\"MiniRacer types identifier\n    Note: it needs to be coherent with mini_racer_extension.cc.\n    \"\"\"\n    invalid = 0\n    null = 1\n    bool = 2\n    integer = 3\n    double = 4\n    str_utf8 = 5",
        "detail": "custard.mock.mini_racer",
        "documentation": {}
    },
    {
        "label": "MiniRacerValueStruct",
        "kind": 6,
        "importPath": "custard.mock.mini_racer",
        "description": "custard.mock.mini_racer",
        "peekOfCode": "class MiniRacerValueStruct(ctypes.Structure):\n    _fields_ = [(\"value\", ctypes.c_void_p),  # value is 8 bytes, works only for 64bit systems\n                (\"type\", ctypes.c_int),\n                (\"len\", ctypes.c_size_t)]\nclass ArrayBufferByte(ctypes.Structure):\n    # Cannot use c_ubyte directly because it uses <B\n    # as an internal type but we need B for memoryview.\n    _fields_ = [(\"b\", ctypes.c_ubyte)]\n    _pack_ = 1\nclass MiniRacerValue(object):",
        "detail": "custard.mock.mini_racer",
        "documentation": {}
    },
    {
        "label": "ArrayBufferByte",
        "kind": 6,
        "importPath": "custard.mock.mini_racer",
        "description": "custard.mock.mini_racer",
        "peekOfCode": "class ArrayBufferByte(ctypes.Structure):\n    # Cannot use c_ubyte directly because it uses <B\n    # as an internal type but we need B for memoryview.\n    _fields_ = [(\"b\", ctypes.c_ubyte)]\n    _pack_ = 1\nclass MiniRacerValue(object):\n    def __init__(self, ctx, ptr):\n        self.ctx = ctx\n        self.ptr = ptr\n    def __str__(self):",
        "detail": "custard.mock.mini_racer",
        "documentation": {}
    },
    {
        "label": "MiniRacerValue",
        "kind": 6,
        "importPath": "custard.mock.mini_racer",
        "description": "custard.mock.mini_racer",
        "peekOfCode": "class MiniRacerValue(object):\n    def __init__(self, ctx, ptr):\n        self.ctx = ctx\n        self.ptr = ptr\n    def __str__(self):\n        return str(self.to_python())\n    @property\n    def type(self):\n        return self.ptr.contents.type\n    @property",
        "detail": "custard.mock.mini_racer",
        "documentation": {}
    },
    {
        "label": "is_unicode",
        "kind": 2,
        "importPath": "custard.mock.mini_racer",
        "description": "custard.mock.mini_racer",
        "peekOfCode": "def is_unicode(value):\n    \"\"\"Check if a value is a valid unicode string.\n    >>> is_unicode(u'foo')\n    True\n    >>> is_unicode(u'')\n    True\n    >>> is_unicode(b'foo')\n    False\n    >>> is_unicode(42)\n    False",
        "detail": "custard.mock.mini_racer",
        "documentation": {}
    },
    {
        "label": "EXTENSION_PATH",
        "kind": 5,
        "importPath": "custard.mock.mini_racer",
        "description": "custard.mock.mini_racer",
        "peekOfCode": "EXTENSION_PATH = _get_lib_path(\"mini_racer\")\nEXTENSION_NAME = os.path.basename(EXTENSION_PATH) if EXTENSION_PATH is not None else None\nif sys.version_info[0] < 3:\n    UNICODE_TYPE = unicode  # noqa: F821\nelse:\n    from typing import Any, Optional\n    UNICODE_TYPE = str\nclass MiniRacerBaseException(Exception):\n    \"\"\"Base MiniRacer exception.\"\"\"\nclass JSParseException(MiniRacerBaseException):",
        "detail": "custard.mock.mini_racer",
        "documentation": {}
    },
    {
        "label": "EXTENSION_NAME",
        "kind": 5,
        "importPath": "custard.mock.mini_racer",
        "description": "custard.mock.mini_racer",
        "peekOfCode": "EXTENSION_NAME = os.path.basename(EXTENSION_PATH) if EXTENSION_PATH is not None else None\nif sys.version_info[0] < 3:\n    UNICODE_TYPE = unicode  # noqa: F821\nelse:\n    from typing import Any, Optional\n    UNICODE_TYPE = str\nclass MiniRacerBaseException(Exception):\n    \"\"\"Base MiniRacer exception.\"\"\"\nclass JSParseException(MiniRacerBaseException):\n    \"\"\"JavaScript could not be parsed.\"\"\"",
        "detail": "custard.mock.mini_racer",
        "documentation": {}
    },
    {
        "label": "StrictMiniRacer",
        "kind": 5,
        "importPath": "custard.mock.mini_racer",
        "description": "custard.mock.mini_racer",
        "peekOfCode": "StrictMiniRacer = MiniRacer\nclass MiniRacerTypes(object):\n    \"\"\"MiniRacer types identifier\n    Note: it needs to be coherent with mini_racer_extension.cc.\n    \"\"\"\n    invalid = 0\n    null = 1\n    bool = 2\n    integer = 3\n    double = 4",
        "detail": "custard.mock.mini_racer",
        "documentation": {}
    },
    {
        "label": "ReqBodyTypeEnum",
        "kind": 6,
        "importPath": "custard.network.enums",
        "description": "custard.network.enums",
        "peekOfCode": "class ReqBodyTypeEnum(IntEnum):\n    none = 0\n    json = 1\n    form = 2\n    x_form = 3\n    binary = 4\n    graphQL = 5",
        "detail": "custard.network.enums",
        "documentation": {}
    },
    {
        "label": "Request",
        "kind": 6,
        "importPath": "custard.network.httpclient",
        "description": "custard.network.httpclient",
        "peekOfCode": "class Request(object):\n    def __init__(self, url, session=False, **kwargs):\n        self.url = url\n        self.session = session\n        self.kwargs = kwargs\n        if self.session:\n            self.client = requests.session()\n            return\n        self.client = requests\n    def get(self):",
        "detail": "custard.network.httpclient",
        "documentation": {}
    },
    {
        "label": "resolve_params",
        "kind": 2,
        "importPath": "custard.pagination.api",
        "description": "custard.pagination.api",
        "peekOfCode": "def resolve_params(params: Optional[AbstractParams] = None) -> AbstractParams:\n    if params is None:\n        try:\n            return params_value.get()\n        except LookupError:\n            raise RuntimeError(\"Use params or add_pagination\")\n    return params\ndef create_page(items: Sequence[T], total: int, params: AbstractParams) -> AbstractPage[T]:\n    return page_type.get().create(items, total, params)\ndef response() -> Response:",
        "detail": "custard.pagination.api",
        "documentation": {}
    },
    {
        "label": "create_page",
        "kind": 2,
        "importPath": "custard.pagination.api",
        "description": "custard.pagination.api",
        "peekOfCode": "def create_page(items: Sequence[T], total: int, params: AbstractParams) -> AbstractPage[T]:\n    return page_type.get().create(items, total, params)\ndef response() -> Response:\n    try:\n        return response_value.get()\n    except LookupError:\n        raise RuntimeError(\"response context var must be set\")\ndef request() -> Request:\n    try:\n        return request_value.get()",
        "detail": "custard.pagination.api",
        "documentation": {}
    },
    {
        "label": "response",
        "kind": 2,
        "importPath": "custard.pagination.api",
        "description": "custard.pagination.api",
        "peekOfCode": "def response() -> Response:\n    try:\n        return response_value.get()\n    except LookupError:\n        raise RuntimeError(\"response context var must be set\")\ndef request() -> Request:\n    try:\n        return request_value.get()\n    except LookupError:\n        raise RuntimeError(\"request context var must be set\")",
        "detail": "custard.pagination.api",
        "documentation": {}
    },
    {
        "label": "request",
        "kind": 2,
        "importPath": "custard.pagination.api",
        "description": "custard.pagination.api",
        "peekOfCode": "def request() -> Request:\n    try:\n        return request_value.get()\n    except LookupError:\n        raise RuntimeError(\"request context var must be set\")\ndef _ctx_var_with_reset(var: ContextVar, value: Any) -> ContextManager[None]:\n    token = var.set(value)\n    @contextmanager\n    def _reset_ctx() -> Iterator[None]:\n        yield",
        "detail": "custard.pagination.api",
        "documentation": {}
    },
    {
        "label": "set_page",
        "kind": 2,
        "importPath": "custard.pagination.api",
        "description": "custard.pagination.api",
        "peekOfCode": "def set_page(page: Type[AbstractPage]) -> ContextManager[None]:\n    return _ctx_var_with_reset(page_type, page)\ndef _create_page_dependency(page: Type[AbstractPage]) -> Callable[[], AsyncIterator[None]]:\n    async def _set_page_type() -> AsyncIterator[None]:\n        with set_page(page):\n            yield\n    return _set_page_type\ndef _create_params_dependency(\n        params: Type[TAbstractParams],\n) -> Callable[[TAbstractParams], AsyncIterator[TAbstractParams]]:",
        "detail": "custard.pagination.api",
        "documentation": {}
    },
    {
        "label": "add_pagination",
        "kind": 2,
        "importPath": "custard.pagination.api",
        "description": "custard.pagination.api",
        "peekOfCode": "def add_pagination(parent: ParentT) -> ParentT:\n    for route in parent.routes:\n        if isinstance(route, APIRoute):\n            _update_route(route)\n    return parent\n__all__ = [\n    \"add_pagination\",\n    \"create_page\",\n    \"resolve_params\",\n    \"response\",",
        "detail": "custard.pagination.api",
        "documentation": {}
    },
    {
        "label": "T",
        "kind": 5,
        "importPath": "custard.pagination.api",
        "description": "custard.pagination.api",
        "peekOfCode": "T = TypeVar(\"T\")\nTAbstractParams = TypeVar(\"TAbstractParams\", covariant=True, bound=AbstractParams)\nparams_value: ContextVar[AbstractParams] = ContextVar(\"params_value\")\npage_type: ContextVar[Type[AbstractPage]] = ContextVar(\"page_type\", default=Page)\nresponse_value: ContextVar[Response] = ContextVar(\"response_value\")\nrequest_value: ContextVar[Request] = ContextVar(\"request_value\")\ndef resolve_params(params: Optional[AbstractParams] = None) -> AbstractParams:\n    if params is None:\n        try:\n            return params_value.get()",
        "detail": "custard.pagination.api",
        "documentation": {}
    },
    {
        "label": "TAbstractParams",
        "kind": 5,
        "importPath": "custard.pagination.api",
        "description": "custard.pagination.api",
        "peekOfCode": "TAbstractParams = TypeVar(\"TAbstractParams\", covariant=True, bound=AbstractParams)\nparams_value: ContextVar[AbstractParams] = ContextVar(\"params_value\")\npage_type: ContextVar[Type[AbstractPage]] = ContextVar(\"page_type\", default=Page)\nresponse_value: ContextVar[Response] = ContextVar(\"response_value\")\nrequest_value: ContextVar[Request] = ContextVar(\"request_value\")\ndef resolve_params(params: Optional[AbstractParams] = None) -> AbstractParams:\n    if params is None:\n        try:\n            return params_value.get()\n        except LookupError:",
        "detail": "custard.pagination.api",
        "documentation": {}
    },
    {
        "label": "ParentT",
        "kind": 5,
        "importPath": "custard.pagination.api",
        "description": "custard.pagination.api",
        "peekOfCode": "ParentT = TypeVar(\"ParentT\", APIRouter, FastAPI)\ndef _update_route(route: APIRoute) -> None:\n    if any(d.call is _marker for d in route.dependant.dependencies):\n        return\n    if not lenient_issubclass(route.response_model, AbstractPage):\n        return\n    cls = cast(Type[AbstractPage], route.response_model)\n    dependencies = [\n        Depends(_marker),\n        Depends(_set_request_response),",
        "detail": "custard.pagination.api",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "custard.pagination.api",
        "description": "custard.pagination.api",
        "peekOfCode": "__all__ = [\n    \"add_pagination\",\n    \"create_page\",\n    \"resolve_params\",\n    \"response\",\n    \"request\",\n    \"set_page\",\n]",
        "detail": "custard.pagination.api",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "custard.pagination.async_sqlalchemy",
        "description": "custard.pagination.async_sqlalchemy",
        "peekOfCode": "__all__ = [\"paginate\"]",
        "detail": "custard.pagination.async_sqlalchemy",
        "documentation": {}
    },
    {
        "label": "RawParams",
        "kind": 6,
        "importPath": "custard.pagination.bases",
        "description": "custard.pagination.bases",
        "peekOfCode": "class RawParams:\n    limit: int\n    offset: int\nclass AbstractParams(ABC):\n    @abstractmethod\n    def to_raw_params(self) -> RawParams:\n        pass\ndef _create_params(cls: Type[AbstractParams], fields: Dict[str, Any]) -> Mapping[str, Any]:\n    if not issubclass(cls, BaseModel):\n        raise ValueError(f\"{cls.__name__} must be subclass of BaseModel\")",
        "detail": "custard.pagination.bases",
        "documentation": {}
    },
    {
        "label": "AbstractParams",
        "kind": 6,
        "importPath": "custard.pagination.bases",
        "description": "custard.pagination.bases",
        "peekOfCode": "class AbstractParams(ABC):\n    @abstractmethod\n    def to_raw_params(self) -> RawParams:\n        pass\ndef _create_params(cls: Type[AbstractParams], fields: Dict[str, Any]) -> Mapping[str, Any]:\n    if not issubclass(cls, BaseModel):\n        raise ValueError(f\"{cls.__name__} must be subclass of BaseModel\")\n    incorrect = sorted(fields.keys() - cls.__fields__.keys())\n    if incorrect:\n        ending = \"s\" if len(incorrect) > 1 else \"\"",
        "detail": "custard.pagination.bases",
        "documentation": {}
    },
    {
        "label": "AbstractPage",
        "kind": 6,
        "importPath": "custard.pagination.bases",
        "description": "custard.pagination.bases",
        "peekOfCode": "class AbstractPage(GenericModel, Generic[T], ABC):\n    __params_type__: ClassVar[Type[AbstractParams]]\n    @classmethod\n    @abstractmethod\n    def create(cls: Type[C], items: Sequence[T], total: int, params: AbstractParams) -> C:\n        pass\n    @classmethod\n    def with_custom_options(cls: Type[TAbstractPage], **kwargs: Any) -> Type[TAbstractPage]:\n        params_cls = cast(Type[AbstractPage], cls).__params_type__\n        custom_params: Any = create_model(",
        "detail": "custard.pagination.bases",
        "documentation": {}
    },
    {
        "label": "BasePage",
        "kind": 6,
        "importPath": "custard.pagination.bases",
        "description": "custard.pagination.bases",
        "peekOfCode": "class BasePage(AbstractPage[T], Generic[T], ABC):\n    items: Sequence[T]\n    total: conint(ge=0)  # type: ignore\n__all__ = [\n    \"AbstractPage\",\n    \"AbstractParams\",\n    \"BasePage\",\n    \"RawParams\",\n]",
        "detail": "custard.pagination.bases",
        "documentation": {}
    },
    {
        "label": "T",
        "kind": 5,
        "importPath": "custard.pagination.bases",
        "description": "custard.pagination.bases",
        "peekOfCode": "T = TypeVar(\"T\")\nC = TypeVar(\"C\")\nTAbstractPage = TypeVar(\"TAbstractPage\", bound=\"AbstractPage\")\n@dataclass\nclass RawParams:\n    limit: int\n    offset: int\nclass AbstractParams(ABC):\n    @abstractmethod\n    def to_raw_params(self) -> RawParams:",
        "detail": "custard.pagination.bases",
        "documentation": {}
    },
    {
        "label": "C",
        "kind": 5,
        "importPath": "custard.pagination.bases",
        "description": "custard.pagination.bases",
        "peekOfCode": "C = TypeVar(\"C\")\nTAbstractPage = TypeVar(\"TAbstractPage\", bound=\"AbstractPage\")\n@dataclass\nclass RawParams:\n    limit: int\n    offset: int\nclass AbstractParams(ABC):\n    @abstractmethod\n    def to_raw_params(self) -> RawParams:\n        pass",
        "detail": "custard.pagination.bases",
        "documentation": {}
    },
    {
        "label": "TAbstractPage",
        "kind": 5,
        "importPath": "custard.pagination.bases",
        "description": "custard.pagination.bases",
        "peekOfCode": "TAbstractPage = TypeVar(\"TAbstractPage\", bound=\"AbstractPage\")\n@dataclass\nclass RawParams:\n    limit: int\n    offset: int\nclass AbstractParams(ABC):\n    @abstractmethod\n    def to_raw_params(self) -> RawParams:\n        pass\ndef _create_params(cls: Type[AbstractParams], fields: Dict[str, Any]) -> Mapping[str, Any]:",
        "detail": "custard.pagination.bases",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "custard.pagination.bases",
        "description": "custard.pagination.bases",
        "peekOfCode": "__all__ = [\n    \"AbstractPage\",\n    \"AbstractParams\",\n    \"BasePage\",\n    \"RawParams\",\n]",
        "detail": "custard.pagination.bases",
        "documentation": {}
    },
    {
        "label": "Params",
        "kind": 6,
        "importPath": "custard.pagination.default",
        "description": "custard.pagination.default",
        "peekOfCode": "class Params(BaseModel, AbstractParams):\n    page: int = Query(1, ge=1, description=\"Page number\")\n    size: int = Query(50, ge=1, le=100, description=\"Page size\")\n    def to_raw_params(self) -> RawParams:\n        return RawParams(\n            limit=self.size,\n            offset=self.size * (self.page - 1),\n        )\nclass Page(BasePage[T], Generic[T]):\n    page: conint(ge=1)  # type: ignore",
        "detail": "custard.pagination.default",
        "documentation": {}
    },
    {
        "label": "Page",
        "kind": 6,
        "importPath": "custard.pagination.default",
        "description": "custard.pagination.default",
        "peekOfCode": "class Page(BasePage[T], Generic[T]):\n    page: conint(ge=1)  # type: ignore\n    size: conint(ge=1)  # type: ignore\n    __params_type__ = Params\n    @classmethod\n    def create(\n            cls,\n            items: Sequence[T],\n            total: int,\n            params: AbstractParams,",
        "detail": "custard.pagination.default",
        "documentation": {}
    },
    {
        "label": "T",
        "kind": 5,
        "importPath": "custard.pagination.default",
        "description": "custard.pagination.default",
        "peekOfCode": "T = TypeVar(\"T\")\nclass Params(BaseModel, AbstractParams):\n    page: int = Query(1, ge=1, description=\"Page number\")\n    size: int = Query(50, ge=1, le=100, description=\"Page size\")\n    def to_raw_params(self) -> RawParams:\n        return RawParams(\n            limit=self.size,\n            offset=self.size * (self.page - 1),\n        )\nclass Page(BasePage[T], Generic[T]):",
        "detail": "custard.pagination.default",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "custard.pagination.default",
        "description": "custard.pagination.default",
        "peekOfCode": "__all__ = [\n    \"Params\",\n    \"Page\",\n]",
        "detail": "custard.pagination.default",
        "documentation": {}
    },
    {
        "label": "Page",
        "kind": 6,
        "importPath": "custard.pagination.iterables",
        "description": "custard.pagination.iterables",
        "peekOfCode": "class Page(DefaultPage, Generic[T]):\n    total: Optional[conint(ge=0)]  # type: ignore\nclass LimitOffsetPage(DefaultLimitOffsetPage, Generic[T]):\n    total: Optional[conint(ge=0)]  # type: ignore\ndef paginate(\n        iterable: Iterable[T],\n        params: Optional[AbstractParams] = None,\n        total: Optional[int] = None,\n) -> AbstractPage[T]:\n    params = resolve_params(params)",
        "detail": "custard.pagination.iterables",
        "documentation": {}
    },
    {
        "label": "LimitOffsetPage",
        "kind": 6,
        "importPath": "custard.pagination.iterables",
        "description": "custard.pagination.iterables",
        "peekOfCode": "class LimitOffsetPage(DefaultLimitOffsetPage, Generic[T]):\n    total: Optional[conint(ge=0)]  # type: ignore\ndef paginate(\n        iterable: Iterable[T],\n        params: Optional[AbstractParams] = None,\n        total: Optional[int] = None,\n) -> AbstractPage[T]:\n    params = resolve_params(params)\n    raw_params = params.to_raw_params()\n    items = [*islice(iterable, raw_params.offset, raw_params.offset + raw_params.limit)]",
        "detail": "custard.pagination.iterables",
        "documentation": {}
    },
    {
        "label": "paginate",
        "kind": 2,
        "importPath": "custard.pagination.iterables",
        "description": "custard.pagination.iterables",
        "peekOfCode": "def paginate(\n        iterable: Iterable[T],\n        params: Optional[AbstractParams] = None,\n        total: Optional[int] = None,\n) -> AbstractPage[T]:\n    params = resolve_params(params)\n    raw_params = params.to_raw_params()\n    items = [*islice(iterable, raw_params.offset, raw_params.offset + raw_params.limit)]\n    return create_page(items, total, params)  # type: ignore\n__all__ = [",
        "detail": "custard.pagination.iterables",
        "documentation": {}
    },
    {
        "label": "T",
        "kind": 5,
        "importPath": "custard.pagination.iterables",
        "description": "custard.pagination.iterables",
        "peekOfCode": "T = TypeVar(\"T\")\nclass Page(DefaultPage, Generic[T]):\n    total: Optional[conint(ge=0)]  # type: ignore\nclass LimitOffsetPage(DefaultLimitOffsetPage, Generic[T]):\n    total: Optional[conint(ge=0)]  # type: ignore\ndef paginate(\n        iterable: Iterable[T],\n        params: Optional[AbstractParams] = None,\n        total: Optional[int] = None,\n) -> AbstractPage[T]:",
        "detail": "custard.pagination.iterables",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "custard.pagination.iterables",
        "description": "custard.pagination.iterables",
        "peekOfCode": "__all__ = [\n    \"Page\",\n    \"Params\",\n    \"LimitOffsetPage\",\n    \"LimitOffsetParams\",\n    \"paginate\",\n]",
        "detail": "custard.pagination.iterables",
        "documentation": {}
    },
    {
        "label": "LimitOffsetParams",
        "kind": 6,
        "importPath": "custard.pagination.limit_offset",
        "description": "custard.pagination.limit_offset",
        "peekOfCode": "class LimitOffsetParams(BaseModel, AbstractParams):\n    limit: int = Query(50, ge=1, le=100, description=\"Page size limit\")\n    offset: int = Query(0, ge=0, description=\"Page offset\")\n    def to_raw_params(self) -> RawParams:\n        return RawParams(\n            limit=self.limit,\n            offset=self.offset,\n        )\nclass LimitOffsetPage(BasePage[T], Generic[T]):\n    limit: conint(ge=1)  # type: ignore",
        "detail": "custard.pagination.limit_offset",
        "documentation": {}
    },
    {
        "label": "LimitOffsetPage",
        "kind": 6,
        "importPath": "custard.pagination.limit_offset",
        "description": "custard.pagination.limit_offset",
        "peekOfCode": "class LimitOffsetPage(BasePage[T], Generic[T]):\n    limit: conint(ge=1)  # type: ignore\n    offset: conint(ge=0)  # type: ignore\n    __params_type__ = LimitOffsetParams\n    @classmethod\n    def create(\n            cls,\n            items: Sequence[T],\n            total: int,\n            params: AbstractParams,",
        "detail": "custard.pagination.limit_offset",
        "documentation": {}
    },
    {
        "label": "T",
        "kind": 5,
        "importPath": "custard.pagination.limit_offset",
        "description": "custard.pagination.limit_offset",
        "peekOfCode": "T = TypeVar(\"T\")\nclass LimitOffsetParams(BaseModel, AbstractParams):\n    limit: int = Query(50, ge=1, le=100, description=\"Page size limit\")\n    offset: int = Query(0, ge=0, description=\"Page offset\")\n    def to_raw_params(self) -> RawParams:\n        return RawParams(\n            limit=self.limit,\n            offset=self.offset,\n        )\nclass LimitOffsetPage(BasePage[T], Generic[T]):",
        "detail": "custard.pagination.limit_offset",
        "documentation": {}
    },
    {
        "label": "Page",
        "kind": 5,
        "importPath": "custard.pagination.limit_offset",
        "description": "custard.pagination.limit_offset",
        "peekOfCode": "Page = LimitOffsetPage\nParams = LimitOffsetParams\n__all__ = [\n    \"Page\",\n    \"Params\",\n    \"LimitOffsetPage\",\n    \"LimitOffsetParams\",\n]",
        "detail": "custard.pagination.limit_offset",
        "documentation": {}
    },
    {
        "label": "Params",
        "kind": 5,
        "importPath": "custard.pagination.limit_offset",
        "description": "custard.pagination.limit_offset",
        "peekOfCode": "Params = LimitOffsetParams\n__all__ = [\n    \"Page\",\n    \"Params\",\n    \"LimitOffsetPage\",\n    \"LimitOffsetParams\",\n]",
        "detail": "custard.pagination.limit_offset",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "custard.pagination.limit_offset",
        "description": "custard.pagination.limit_offset",
        "peekOfCode": "__all__ = [\n    \"Page\",\n    \"Params\",\n    \"LimitOffsetPage\",\n    \"LimitOffsetParams\",\n]",
        "detail": "custard.pagination.limit_offset",
        "documentation": {}
    },
    {
        "label": "Params",
        "kind": 6,
        "importPath": "custard.pagination.pagination",
        "description": "custard.pagination.pagination",
        "peekOfCode": "class Params(BaseModel, AbstractParams):\n    page: int = Query(1, ge=1, description=\"Page number\")\n    size: int = Query(20, gt=0, le=100, description=\"Page size\")\n    def to_raw_params(self) -> RawParams:\n        return RawParams(\n            limit=self.size,\n            offset=self.size * (self.page - 1),\n        )\nclass Page(AbstractPage[T], Generic[T]):\n    results: Sequence[T]",
        "detail": "custard.pagination.pagination",
        "documentation": {}
    },
    {
        "label": "Page",
        "kind": 6,
        "importPath": "custard.pagination.pagination",
        "description": "custard.pagination.pagination",
        "peekOfCode": "class Page(AbstractPage[T], Generic[T]):\n    results: Sequence[T]\n    total: int\n    page: int\n    size: int\n    next: str\n    previous: str\n    total_pages: int\n    __params_type__ = Params  # Set params related to Page\n    @classmethod",
        "detail": "custard.pagination.pagination",
        "documentation": {}
    },
    {
        "label": "T",
        "kind": 5,
        "importPath": "custard.pagination.pagination",
        "description": "custard.pagination.pagination",
        "peekOfCode": "T = TypeVar(\"T\")\nclass Params(BaseModel, AbstractParams):\n    page: int = Query(1, ge=1, description=\"Page number\")\n    size: int = Query(20, gt=0, le=100, description=\"Page size\")\n    def to_raw_params(self) -> RawParams:\n        return RawParams(\n            limit=self.size,\n            offset=self.size * (self.page - 1),\n        )\nclass Page(AbstractPage[T], Generic[T]):",
        "detail": "custard.pagination.pagination",
        "documentation": {}
    },
    {
        "label": "paginate",
        "kind": 2,
        "importPath": "custard.pagination.paginator",
        "description": "custard.pagination.paginator",
        "peekOfCode": "def paginate(\n        sequence: Sequence[T],\n        params: Optional[AbstractParams] = None,\n        length_function: Callable[[Sequence[T]], int] = len,\n) -> AbstractPage[T]:\n    params = resolve_params(params)\n    raw_params = params.to_raw_params()\n    return create_page(\n        items=sequence[raw_params.offset: raw_params.offset + raw_params.limit],\n        total=length_function(sequence),",
        "detail": "custard.pagination.paginator",
        "documentation": {}
    },
    {
        "label": "T",
        "kind": 5,
        "importPath": "custard.pagination.paginator",
        "description": "custard.pagination.paginator",
        "peekOfCode": "T = TypeVar(\"T\")\ndef paginate(\n        sequence: Sequence[T],\n        params: Optional[AbstractParams] = None,\n        length_function: Callable[[Sequence[T]], int] = len,\n) -> AbstractPage[T]:\n    params = resolve_params(params)\n    raw_params = params.to_raw_params()\n    return create_page(\n        items=sequence[raw_params.offset: raw_params.offset + raw_params.limit],",
        "detail": "custard.pagination.paginator",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "custard.pagination.paginator",
        "description": "custard.pagination.paginator",
        "peekOfCode": "__all__ = [\"paginate\"]",
        "detail": "custard.pagination.paginator",
        "documentation": {}
    },
    {
        "label": "paginate_query",
        "kind": 2,
        "importPath": "custard.pagination.sync_sqlalchemy",
        "description": "custard.pagination.sync_sqlalchemy",
        "peekOfCode": "def paginate_query(query: T, params: AbstractParams) -> T:\n    raw_params = params.to_raw_params()\n    return query.limit(raw_params.limit).offset(raw_params.offset)\ndef _to_dict(obj: Any) -> Any:\n    try:\n        return obj._asdict()\n    except AttributeError:\n        return obj\ndef paginate(query: Query, params: Optional[AbstractParams] = None) -> AbstractPage:\n    params = resolve_params(params)",
        "detail": "custard.pagination.sync_sqlalchemy",
        "documentation": {}
    },
    {
        "label": "paginate",
        "kind": 2,
        "importPath": "custard.pagination.sync_sqlalchemy",
        "description": "custard.pagination.sync_sqlalchemy",
        "peekOfCode": "def paginate(query: Query, params: Optional[AbstractParams] = None) -> AbstractPage:\n    params = resolve_params(params)\n    total = query.count()\n    items = [_to_dict(item) for item in paginate_query(query, params)]\n    return create_page(items, total, params)\n__all__ = [\"paginate_query\", \"paginate\"]",
        "detail": "custard.pagination.sync_sqlalchemy",
        "documentation": {}
    },
    {
        "label": "T",
        "kind": 5,
        "importPath": "custard.pagination.sync_sqlalchemy",
        "description": "custard.pagination.sync_sqlalchemy",
        "peekOfCode": "T = TypeVar(\"T\", Select, Query)\ndef paginate_query(query: T, params: AbstractParams) -> T:\n    raw_params = params.to_raw_params()\n    return query.limit(raw_params.limit).offset(raw_params.offset)\ndef _to_dict(obj: Any) -> Any:\n    try:\n        return obj._asdict()\n    except AttributeError:\n        return obj\ndef paginate(query: Query, params: Optional[AbstractParams] = None) -> AbstractPage:",
        "detail": "custard.pagination.sync_sqlalchemy",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "custard.pagination.sync_sqlalchemy",
        "description": "custard.pagination.sync_sqlalchemy",
        "peekOfCode": "__all__ = [\"paginate_query\", \"paginate\"]",
        "detail": "custard.pagination.sync_sqlalchemy",
        "documentation": {}
    },
    {
        "label": "_ver",
        "kind": 5,
        "importPath": "custard.script.compat",
        "description": "custard.script.compat",
        "peekOfCode": "_ver = sys.version_info\n#: Python 2.x?\nis_py2 = (_ver[0] == 2)\n#: Python 3.x?\nis_py3 = (_ver[0] == 3)\n# ---------\n# Specifics\n# ---------\ntry:\n    JSONDecodeError = json.JSONDecodeError",
        "detail": "custard.script.compat",
        "documentation": {}
    },
    {
        "label": "is_py2",
        "kind": 5,
        "importPath": "custard.script.compat",
        "description": "custard.script.compat",
        "peekOfCode": "is_py2 = (_ver[0] == 2)\n#: Python 3.x?\nis_py3 = (_ver[0] == 3)\n# ---------\n# Specifics\n# ---------\ntry:\n    JSONDecodeError = json.JSONDecodeError\nexcept AttributeError:\n    JSONDecodeError = ValueError",
        "detail": "custard.script.compat",
        "documentation": {}
    },
    {
        "label": "is_py3",
        "kind": 5,
        "importPath": "custard.script.compat",
        "description": "custard.script.compat",
        "peekOfCode": "is_py3 = (_ver[0] == 3)\n# ---------\n# Specifics\n# ---------\ntry:\n    JSONDecodeError = json.JSONDecodeError\nexcept AttributeError:\n    JSONDecodeError = ValueError\nif is_py2:\n    builtin_str = str",
        "detail": "custard.script.compat",
        "documentation": {}
    },
    {
        "label": "parse_string_value",
        "kind": 2,
        "importPath": "custard.script.parser",
        "description": "custard.script.parser",
        "peekOfCode": "def parse_string_value(str_value):\n    \"\"\" parse string to number if possible\n    e.g. \"123\" => 123\n         \"12.2\" => 12.3\n         \"abc\" => \"abc\"\n         \"$var\" => \"$var\"\n    \"\"\"\n    try:\n        return ast.literal_eval(str_value)\n    except ValueError:",
        "detail": "custard.script.parser",
        "documentation": {}
    },
    {
        "label": "extract_variables",
        "kind": 2,
        "importPath": "custard.script.parser",
        "description": "custard.script.parser",
        "peekOfCode": "def extract_variables(content):\n    \"\"\" extract all variable names from content, which is in format $variable\n    Args:\n        content (str): string content\n    Returns:\n        list: variables list extracted from string content\n    Examples:\n        >>> extract_variables(\"$variable\")\n        >>> extract_variables(\"/blog/$postid\")\n        >>> extract_variables(\"/$var1/$var2\")",
        "detail": "custard.script.parser",
        "documentation": {}
    },
    {
        "label": "extract_functions",
        "kind": 2,
        "importPath": "custard.script.parser",
        "description": "custard.script.parser",
        "peekOfCode": "def extract_functions(content):\n    \"\"\" extract all functions from string content, which are in format ${fun()}\n    Args:\n        content (str): string content\n    Returns:\n        list: functions list extracted from string content\n    Examples:\n        >>> extract_functions(\"${func(5)}\")\n        >>> extract_functions(\"${func(a=1, b=2)}\")\n        >>> extract_functions(\"/api/1000?_t=${get_timestamp()}\")",
        "detail": "custard.script.parser",
        "documentation": {}
    },
    {
        "label": "parse_function",
        "kind": 2,
        "importPath": "custard.script.parser",
        "description": "custard.script.parser",
        "peekOfCode": "def parse_function(content):\n    \"\"\" parse function name and args from string content.\n    Args:\n        content (str): string content\n    Returns:\n        dict: function meta dict\n            {\n                \"func_name\": \"xxx\",\n                \"args\": [],\n                \"kwargs\": {}",
        "detail": "custard.script.parser",
        "documentation": {}
    },
    {
        "label": "parse_validator",
        "kind": 2,
        "importPath": "custard.script.parser",
        "description": "custard.script.parser",
        "peekOfCode": "def parse_validator(validator):\n    \"\"\"\n    Args:\n        validator:\n            format1: this is kept for compatiblity with the previous versions.\n                {\"check\": \"status_code\", \"comparator\": \"eq\", \"expect\": 201}\n                {\"check\": \"$resp_body_success\", \"comparator\": \"eq\", \"expect\": True}\n            format2: recommended new version\n                {'eq': ['status_code', 201]}\n                {'eq': ['$resp_body_success', True]}",
        "detail": "custard.script.parser",
        "documentation": {}
    },
    {
        "label": "substitute_variables",
        "kind": 2,
        "importPath": "custard.script.parser",
        "description": "custard.script.parser",
        "peekOfCode": "def substitute_variables(content, variables_mapping):\n    \"\"\" substitute variables in content with variables_mapping\n    Args:\n        content (str/dict/list/numeric/bool/type): content to be substituted.\n        variables_mapping (dict): variables mapping.\n    Returns:\n        substituted content.\n    Examples:\n        >>> content = { 'request': { 'url': '/api/users/$uid', 'headers': {'token': '$token'} } }\n        >>> variables_mapping = {\"$uid\": 1000}",
        "detail": "custard.script.parser",
        "documentation": {}
    },
    {
        "label": "get_builtin_item",
        "kind": 2,
        "importPath": "custard.script.parser",
        "description": "custard.script.parser",
        "peekOfCode": "def get_builtin_item(item_type, item_name):\n    \"\"\"\n    Args:\n        item_type (enum): \"variables\" or \"functions\"\n        item_name (str): variable name or function name\n    Returns:\n        variable or function with the name of item_name\n    \"\"\"\n    # override built_in module with debugtalk.py module\n    from httprunner import loader",
        "detail": "custard.script.parser",
        "documentation": {}
    },
    {
        "label": "get_mapping_variable",
        "kind": 2,
        "importPath": "custard.script.parser",
        "description": "custard.script.parser",
        "peekOfCode": "def get_mapping_variable(variable_name, variables_mapping):\n    \"\"\" get variable from variables_mapping.\n    Args:\n        variable_name (str): variable name\n        variables_mapping (dict): variables mapping\n    Returns:\n        mapping variable value.\n    Raises:\n        exceptions.VariableNotFound: variable is not found.\n    \"\"\"",
        "detail": "custard.script.parser",
        "documentation": {}
    },
    {
        "label": "get_mapping_function",
        "kind": 2,
        "importPath": "custard.script.parser",
        "description": "custard.script.parser",
        "peekOfCode": "def get_mapping_function(function_name, functions_mapping):\n    \"\"\" get function from functions_mapping,\n        if not found, then try to check if builtin function.\n    Args:\n        function_name (str):\n        functions_mapping (dict):\n    Returns:\n        mapping function object.\n    Raises:\n        exceptions.FunctionNotFound: function is neither defined in debugtalk.py nor builtin.",
        "detail": "custard.script.parser",
        "documentation": {}
    },
    {
        "label": "parse_function_params",
        "kind": 2,
        "importPath": "custard.script.parser",
        "description": "custard.script.parser",
        "peekOfCode": "def parse_function_params(params) -> dict:\n    \"\"\" parse function params to args and kwargs.\n    Args:\n        params (str): function param in string\n    Returns:\n        dict: function meta dict\n            {\n                \"args\": [],\n                \"kwargs\": {}\n            }",
        "detail": "custard.script.parser",
        "documentation": {}
    },
    {
        "label": "parse_string",
        "kind": 2,
        "importPath": "custard.script.parser",
        "description": "custard.script.parser",
        "peekOfCode": "def parse_string(\n        raw_string,\n        variables_mapping,\n        functions_mapping,\n):\n    \"\"\" parse string content with variables and functions mapping.\n    Args:\n        raw_string: raw string content to be parsed.\n        variables_mapping: variables mapping.\n        functions_mapping: functions mapping.",
        "detail": "custard.script.parser",
        "documentation": {}
    },
    {
        "label": "parse_data",
        "kind": 2,
        "importPath": "custard.script.parser",
        "description": "custard.script.parser",
        "peekOfCode": "def parse_data(content, variables_mapping=None, functions_mapping=None):\n    \"\"\" parse content with variables mapping\n    Args:\n        content (str/dict/list/numeric/bool/type): content to be parsed\n        variables_mapping (dict): variables mapping.\n        functions_mapping (dict): functions mapping.\n    Returns:\n        parsed content.\n    Examples:\n        >>> content = {'request': { 'url': '/api/users/$uid', 'headers': {'token': '$token'}  } }",
        "detail": "custard.script.parser",
        "documentation": {}
    },
    {
        "label": "variable_regexp",
        "kind": 5,
        "importPath": "custard.script.parser",
        "description": "custard.script.parser",
        "peekOfCode": "variable_regexp = r\"\\$([\\w_]+)\"\nfunction_regexp = r\"\\$\\{([\\w_]+\\([\\$\\w\\.\\-/_ =,]*\\))\\}\"\nfunction_regexp_compile = re.compile(r\"^([\\w_]+)\\(([\\$\\w\\.\\-/_ =,]*)\\)$\")\n# use $$ to escape $ notation\ndolloar_regex_compile = re.compile(r\"\\$\\$\")\n# variable notation, e.g. ${var} or $var\nvariable_regex_compile = re.compile(r\"\\$\\{(\\w+)\\}|\\$(\\w+)\")\n# function notation, e.g. ${func1($var_1, $var_3)}\nfunction_regex_compile = re.compile(r\"\\$\\{(\\w+)\\(([\\$\\w\\.\\-/\\s=,]*)\\)\\}\")\ndef parse_string_value(str_value):",
        "detail": "custard.script.parser",
        "documentation": {}
    },
    {
        "label": "function_regexp",
        "kind": 5,
        "importPath": "custard.script.parser",
        "description": "custard.script.parser",
        "peekOfCode": "function_regexp = r\"\\$\\{([\\w_]+\\([\\$\\w\\.\\-/_ =,]*\\))\\}\"\nfunction_regexp_compile = re.compile(r\"^([\\w_]+)\\(([\\$\\w\\.\\-/_ =,]*)\\)$\")\n# use $$ to escape $ notation\ndolloar_regex_compile = re.compile(r\"\\$\\$\")\n# variable notation, e.g. ${var} or $var\nvariable_regex_compile = re.compile(r\"\\$\\{(\\w+)\\}|\\$(\\w+)\")\n# function notation, e.g. ${func1($var_1, $var_3)}\nfunction_regex_compile = re.compile(r\"\\$\\{(\\w+)\\(([\\$\\w\\.\\-/\\s=,]*)\\)\\}\")\ndef parse_string_value(str_value):\n    \"\"\" parse string to number if possible",
        "detail": "custard.script.parser",
        "documentation": {}
    },
    {
        "label": "function_regexp_compile",
        "kind": 5,
        "importPath": "custard.script.parser",
        "description": "custard.script.parser",
        "peekOfCode": "function_regexp_compile = re.compile(r\"^([\\w_]+)\\(([\\$\\w\\.\\-/_ =,]*)\\)$\")\n# use $$ to escape $ notation\ndolloar_regex_compile = re.compile(r\"\\$\\$\")\n# variable notation, e.g. ${var} or $var\nvariable_regex_compile = re.compile(r\"\\$\\{(\\w+)\\}|\\$(\\w+)\")\n# function notation, e.g. ${func1($var_1, $var_3)}\nfunction_regex_compile = re.compile(r\"\\$\\{(\\w+)\\(([\\$\\w\\.\\-/\\s=,]*)\\)\\}\")\ndef parse_string_value(str_value):\n    \"\"\" parse string to number if possible\n    e.g. \"123\" => 123",
        "detail": "custard.script.parser",
        "documentation": {}
    },
    {
        "label": "dolloar_regex_compile",
        "kind": 5,
        "importPath": "custard.script.parser",
        "description": "custard.script.parser",
        "peekOfCode": "dolloar_regex_compile = re.compile(r\"\\$\\$\")\n# variable notation, e.g. ${var} or $var\nvariable_regex_compile = re.compile(r\"\\$\\{(\\w+)\\}|\\$(\\w+)\")\n# function notation, e.g. ${func1($var_1, $var_3)}\nfunction_regex_compile = re.compile(r\"\\$\\{(\\w+)\\(([\\$\\w\\.\\-/\\s=,]*)\\)\\}\")\ndef parse_string_value(str_value):\n    \"\"\" parse string to number if possible\n    e.g. \"123\" => 123\n         \"12.2\" => 12.3\n         \"abc\" => \"abc\"",
        "detail": "custard.script.parser",
        "documentation": {}
    },
    {
        "label": "variable_regex_compile",
        "kind": 5,
        "importPath": "custard.script.parser",
        "description": "custard.script.parser",
        "peekOfCode": "variable_regex_compile = re.compile(r\"\\$\\{(\\w+)\\}|\\$(\\w+)\")\n# function notation, e.g. ${func1($var_1, $var_3)}\nfunction_regex_compile = re.compile(r\"\\$\\{(\\w+)\\(([\\$\\w\\.\\-/\\s=,]*)\\)\\}\")\ndef parse_string_value(str_value):\n    \"\"\" parse string to number if possible\n    e.g. \"123\" => 123\n         \"12.2\" => 12.3\n         \"abc\" => \"abc\"\n         \"$var\" => \"$var\"\n    \"\"\"",
        "detail": "custard.script.parser",
        "documentation": {}
    },
    {
        "label": "function_regex_compile",
        "kind": 5,
        "importPath": "custard.script.parser",
        "description": "custard.script.parser",
        "peekOfCode": "function_regex_compile = re.compile(r\"\\$\\{(\\w+)\\(([\\$\\w\\.\\-/\\s=,]*)\\)\\}\")\ndef parse_string_value(str_value):\n    \"\"\" parse string to number if possible\n    e.g. \"123\" => 123\n         \"12.2\" => 12.3\n         \"abc\" => \"abc\"\n         \"$var\" => \"$var\"\n    \"\"\"\n    try:\n        return ast.literal_eval(str_value)",
        "detail": "custard.script.parser",
        "documentation": {}
    },
    {
        "label": "JsonToSchema",
        "kind": 6,
        "importPath": "custard.script.schema",
        "description": "custard.script.schema",
        "peekOfCode": "class JsonToSchema:\n    # \n    @classmethod\n    def get_object_data(cls, dict_data):\n        # dict\n        schema_data = {}\n        # key\n        for dict_data_k in dict_data.keys():\n            # value////None,schema_data\n            if type(dict_data[dict_data_k]) in (str, int, bool, float, list):",
        "detail": "custard.script.schema",
        "documentation": {}
    },
    {
        "label": "IncompleteModelError",
        "kind": 6,
        "importPath": "custard.swagger.exception",
        "description": "custard.swagger.exception",
        "peekOfCode": "class IncompleteModelError(BaseException):\n    pass\nclass ParseMethodError(Exception):\n    pass",
        "detail": "custard.swagger.exception",
        "documentation": {}
    },
    {
        "label": "ParseMethodError",
        "kind": 6,
        "importPath": "custard.swagger.exception",
        "description": "custard.swagger.exception",
        "peekOfCode": "class ParseMethodError(Exception):\n    pass",
        "detail": "custard.swagger.exception",
        "documentation": {}
    },
    {
        "label": "load_json",
        "kind": 2,
        "importPath": "custard.swagger.loader",
        "description": "custard.swagger.loader",
        "peekOfCode": "def load_json(json_str):\n    \"\"\"\n    json\n    Args:\n        json_str:\n    Returns:\n    \"\"\"\n    return json.loads(json_str)\ndef load_file(path):\n    \"\"\"",
        "detail": "custard.swagger.loader",
        "documentation": {}
    },
    {
        "label": "load_file",
        "kind": 2,
        "importPath": "custard.swagger.loader",
        "description": "custard.swagger.loader",
        "peekOfCode": "def load_file(path):\n    \"\"\"\n    json\n    Args:\n        path:\n    Returns:\n    \"\"\"\n    with open(path, encoding='utf8') as f:\n        return load_json(f.read())\ndef load_url(url, method='get', **kwargs):",
        "detail": "custard.swagger.loader",
        "documentation": {}
    },
    {
        "label": "load_url",
        "kind": 2,
        "importPath": "custard.swagger.loader",
        "description": "custard.swagger.loader",
        "peekOfCode": "def load_url(url, method='get', **kwargs):\n    \"\"\"\n    urljson\n    Args:\n        url:\n        method:\n        **kwargs:\n    Returns:\n    \"\"\"\n    return requests.request(url=url, method=method, **kwargs).json()",
        "detail": "custard.swagger.loader",
        "documentation": {}
    },
    {
        "label": "Swagger2",
        "kind": 6,
        "importPath": "custard.swagger.swagger",
        "description": "custard.swagger.swagger",
        "peekOfCode": "class Swagger2:\n    def __init__(self, source, deep=5):\n        self.source = source\n        self.deep = deep\n        self.__scheme = self.schemes[0]\n        self.__host = self.source.get('host') or 'localhost'\n    def __property__(self, prop):\n        if isinstance(prop, dict):\n            _type = prop.get('type')\n            _format = prop.get('format')",
        "detail": "custard.swagger.swagger",
        "documentation": {}
    },
    {
        "label": "path_format",
        "kind": 2,
        "importPath": "custard.swagger.utils",
        "description": "custard.swagger.utils",
        "peekOfCode": "def path_format(url, params):\n    t = string.Template(re.subn(r'{(\\w+)}', r'${\\1}', url)[0])\n    return t.safe_substitute(params)\ndef form_format(data: dict, file:str):\n    _data = dict()\n    for k, v in data.items():\n        if v == file:\n            v = (k, open(file, mode='rb'))\n        else:\n            v = (None, v)",
        "detail": "custard.swagger.utils",
        "documentation": {}
    },
    {
        "label": "form_format",
        "kind": 2,
        "importPath": "custard.swagger.utils",
        "description": "custard.swagger.utils",
        "peekOfCode": "def form_format(data: dict, file:str):\n    _data = dict()\n    for k, v in data.items():\n        if v == file:\n            v = (k, open(file, mode='rb'))\n        else:\n            v = (None, v)\n        _data.update({k: v})\n    return _data",
        "detail": "custard.swagger.utils",
        "documentation": {}
    },
    {
        "label": "TimerContextManager",
        "kind": 6,
        "importPath": "custard.time.dafunc",
        "description": "custard.time.dafunc",
        "peekOfCode": "class TimerContextManager(object):\n    \"\"\"\n    \n    \"\"\"\n    def __init__(self, is_print_log=True, logger=None):\n        self._is_print_log = is_print_log\n        self.logger = logger\n        self.t_spend = None\n        self._line = None\n        self._file_name = None",
        "detail": "custard.time.dafunc",
        "documentation": {}
    },
    {
        "label": "func_timeout",
        "kind": 2,
        "importPath": "custard.time.dafunc",
        "description": "custard.time.dafunc",
        "peekOfCode": "def func_timeout(timeout, func, args=(), kwargs=None):\n    \"\"\"\n    Args:\n        timeout:\n        func:\n        args:\n        kwargs:\n    Returns:\n    \"\"\"\n    if not kwargs:",
        "detail": "custard.time.dafunc",
        "documentation": {}
    },
    {
        "label": "bind_timeout",
        "kind": 2,
        "importPath": "custard.time.dafunc",
        "description": "custard.time.dafunc",
        "peekOfCode": "def bind_timeout(timeout, allow_override=False):\n    \"\"\"\n    Args:\n        timeout:\n        allow_override:\n    Returns:\n    \"\"\"\n    default_timeout = copy.copy(timeout)\n    is_timeout_function = bool(issubclass(timeout.__class__, (\n        types.FunctionType, types.MethodType, types.LambdaType, types.BuiltinFunctionType, types.BuiltinMethodType)))",
        "detail": "custard.time.dafunc",
        "documentation": {}
    },
    {
        "label": "calc_time",
        "kind": 2,
        "importPath": "custard.time.dafunc",
        "description": "custard.time.dafunc",
        "peekOfCode": "def calc_time(logger: Any = None):\n    \"\"\"\n    \n    Args:\n        logger:\n    Returns:\n    Examples:\n        >>> @calc_time(\"\")\n        ... def test_calc_time(num=100):\n        ...     return sum([x for x in range(num + 1)])",
        "detail": "custard.time.dafunc",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "custard.time.dafunc",
        "description": "custard.time.dafunc",
        "peekOfCode": "__all__ = ('func_timeout', 'bind_timeout', 'calc_time', 'FunctionTimedOut', 'TimerContextManager', 'StoppableThread')\ndef func_timeout(timeout, func, args=(), kwargs=None):\n    \"\"\"\n    Args:\n        timeout:\n        func:\n        args:\n        kwargs:\n    Returns:\n    \"\"\"",
        "detail": "custard.time.dafunc",
        "documentation": {}
    },
    {
        "label": "TimeOutError",
        "kind": 6,
        "importPath": "custard.time.exceptions",
        "description": "custard.time.exceptions",
        "peekOfCode": "class TimeOutError(Exception):\n    \"\"\"\n    An operation timed out\n    \"\"\"\n    pass\nclass FunctionTimedOut(BaseException):\n    def __init__(self, msg='', timed_out_after=None, timed_out_function=None,\n                 timed_out_args=None, timed_out_kwargs=None):\n        \"\"\"\n        Args:",
        "detail": "custard.time.exceptions",
        "documentation": {}
    },
    {
        "label": "FunctionTimedOut",
        "kind": 6,
        "importPath": "custard.time.exceptions",
        "description": "custard.time.exceptions",
        "peekOfCode": "class FunctionTimedOut(BaseException):\n    def __init__(self, msg='', timed_out_after=None, timed_out_function=None,\n                 timed_out_args=None, timed_out_kwargs=None):\n        \"\"\"\n        Args:\n            msg:\n            timed_out_after:\n            timed_out_function:\n            timed_out_args:\n            timed_out_kwargs:",
        "detail": "custard.time.exceptions",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "custard.time.exceptions",
        "description": "custard.time.exceptions",
        "peekOfCode": "__all__ = ('FunctionTimedOut', 'RETRY_SAME_TIMEOUT')\nRETRY_SAME_TIMEOUT = 'RETRY_SAME_TIMEOUT'\nclass TimeOutError(Exception):\n    \"\"\"\n    An operation timed out\n    \"\"\"\n    pass\nclass FunctionTimedOut(BaseException):\n    def __init__(self, msg='', timed_out_after=None, timed_out_function=None,\n                 timed_out_args=None, timed_out_kwargs=None):",
        "detail": "custard.time.exceptions",
        "documentation": {}
    },
    {
        "label": "RETRY_SAME_TIMEOUT",
        "kind": 5,
        "importPath": "custard.time.exceptions",
        "description": "custard.time.exceptions",
        "peekOfCode": "RETRY_SAME_TIMEOUT = 'RETRY_SAME_TIMEOUT'\nclass TimeOutError(Exception):\n    \"\"\"\n    An operation timed out\n    \"\"\"\n    pass\nclass FunctionTimedOut(BaseException):\n    def __init__(self, msg='', timed_out_after=None, timed_out_function=None,\n                 timed_out_args=None, timed_out_kwargs=None):\n        \"\"\"",
        "detail": "custard.time.exceptions",
        "documentation": {}
    },
    {
        "label": "Moment",
        "kind": 6,
        "importPath": "custard.time.moment",
        "description": "custard.time.moment",
        "peekOfCode": "class Moment:\n    @staticmethod\n    def get_now_time(layout=\"%Y-%m-%d %H:%M:%S\") -> str:\n        \"\"\"\n        \n        Args:\n            layout: 10timestamp 13timestamp,  else  \n        Returns:\n        Examples:\n            >>> print(Moment.get_now_time(\"%Y-%m-%d %H:%M:%S\"))",
        "detail": "custard.time.moment",
        "documentation": {}
    },
    {
        "label": "StoppableThread",
        "kind": 6,
        "importPath": "custard.time.stoppable_thread",
        "description": "custard.time.stoppable_thread",
        "peekOfCode": "class StoppableThread(threading.Thread):\n    def stop_thread(self, exception, repeat_every=2.0):\n        if self.is_alive() is False:\n            return True\n        self._stderr = open(os.devnull, 'w')\n        join_thread = JoinThread(self, exception, repeat_every=repeat_every)\n        join_thread._stderr = self._stderr\n        join_thread.start()\n        join_thread._stderr = self._stderr\n    def stop(self, exception, repeat_every=2.0):",
        "detail": "custard.time.stoppable_thread",
        "documentation": {}
    },
    {
        "label": "JoinThread",
        "kind": 6,
        "importPath": "custard.time.stoppable_thread",
        "description": "custard.time.stoppable_thread",
        "peekOfCode": "class JoinThread(threading.Thread):\n    def __init__(self, other_thread, exception, repeat_every=2.0):\n        threading.Thread.__init__(self)\n        self.other_thread = other_thread\n        self.exception = exception\n        self.repeat_every = repeat_every\n        self.daemon = True\n    def run(self):\n        self.other_thread._Thread__stderr = self._stderr\n        if hasattr(self.other_thread, '_thread__stop'):",
        "detail": "custard.time.stoppable_thread",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "custard.time.stoppable_thread",
        "description": "custard.time.stoppable_thread",
        "peekOfCode": "__all__ = ('StoppableThread', 'JoinThread')\nclass StoppableThread(threading.Thread):\n    def stop_thread(self, exception, repeat_every=2.0):\n        if self.is_alive() is False:\n            return True\n        self._stderr = open(os.devnull, 'w')\n        join_thread = JoinThread(self, exception, repeat_every=repeat_every)\n        join_thread._stderr = self._stderr\n        join_thread.start()\n        join_thread._stderr = self._stderr",
        "detail": "custard.time.stoppable_thread",
        "documentation": {}
    },
    {
        "label": "add_dicts",
        "kind": 2,
        "importPath": "custard.utils.datasets",
        "description": "custard.utils.datasets",
        "peekOfCode": "def add_dicts(*args: Tuple[Dict, ...]) -> Dict:\n    \"\"\"\n    Adds two or more dicts together. Common keys will have their values added.\n    Returns:\n    Example:\n        >>> t1 = {'a':1, 'b':2}\n        >>> t2 = {'b':1, 'c':3}\n        >>> t3 = {'d':5}\n        >>> add_dicts(t1, t2, t3)\n        {'a': 1, 'c': 3, 'b': 3, 'd': 5}",
        "detail": "custard.utils.datasets",
        "documentation": {}
    },
    {
        "label": "slugify",
        "kind": 2,
        "importPath": "custard.utils.decorators",
        "description": "custard.utils.decorators",
        "peekOfCode": "def slugify(fn: Callable) -> Callable:\n    @wraps(fn)\n    def wrapper(*args: Tuple[T, ...], **kwargs: Dict[str, T]) -> str:\n        return text.slugify(fn(*args, **kwargs))\n    return wrapper\ndef slugify_domain(fn: Callable) -> Callable:\n    @wraps(fn)\n    def wrapper(*args: Tuple[T, ...], **kwargs: Dict[str, T]) -> str:\n        return text.slugify(fn(*args, **kwargs), allow_dots=True)\n    return wrapper",
        "detail": "custard.utils.decorators",
        "documentation": {}
    },
    {
        "label": "slugify_domain",
        "kind": 2,
        "importPath": "custard.utils.decorators",
        "description": "custard.utils.decorators",
        "peekOfCode": "def slugify_domain(fn: Callable) -> Callable:\n    @wraps(fn)\n    def wrapper(*args: Tuple[T, ...], **kwargs: Dict[str, T]) -> str:\n        return text.slugify(fn(*args, **kwargs), allow_dots=True)\n    return wrapper\ndef slugify_unicode(fn: Callable) -> Callable:\n    @wraps(fn)\n    def wrapper(*args: Tuple[T, ...], **kwargs: Dict[str, T]) -> str:\n        return text.slugify(fn(*args, **kwargs), allow_unicode=True)\n    return wrapper",
        "detail": "custard.utils.decorators",
        "documentation": {}
    },
    {
        "label": "slugify_unicode",
        "kind": 2,
        "importPath": "custard.utils.decorators",
        "description": "custard.utils.decorators",
        "peekOfCode": "def slugify_unicode(fn: Callable) -> Callable:\n    @wraps(fn)\n    def wrapper(*args: Tuple[T, ...], **kwargs: Dict[str, T]) -> str:\n        return text.slugify(fn(*args, **kwargs), allow_unicode=True)\n    return wrapper\ndef lowercase(fn: Callable) -> Callable:\n    @wraps(fn)\n    def wrapper(*args: Tuple[T, ...], **kwargs: Dict[str, T]) -> str:\n        return fn(*args, **kwargs).lower()\n    return wrapper",
        "detail": "custard.utils.decorators",
        "documentation": {}
    },
    {
        "label": "lowercase",
        "kind": 2,
        "importPath": "custard.utils.decorators",
        "description": "custard.utils.decorators",
        "peekOfCode": "def lowercase(fn: Callable) -> Callable:\n    @wraps(fn)\n    def wrapper(*args: Tuple[T, ...], **kwargs: Dict[str, T]) -> str:\n        return fn(*args, **kwargs).lower()\n    return wrapper",
        "detail": "custard.utils.decorators",
        "documentation": {}
    },
    {
        "label": "T",
        "kind": 5,
        "importPath": "custard.utils.decorators",
        "description": "custard.utils.decorators",
        "peekOfCode": "T = TypeVar(\"T\")\ndef slugify(fn: Callable) -> Callable:\n    @wraps(fn)\n    def wrapper(*args: Tuple[T, ...], **kwargs: Dict[str, T]) -> str:\n        return text.slugify(fn(*args, **kwargs))\n    return wrapper\ndef slugify_domain(fn: Callable) -> Callable:\n    @wraps(fn)\n    def wrapper(*args: Tuple[T, ...], **kwargs: Dict[str, T]) -> str:\n        return text.slugify(fn(*args, **kwargs), allow_dots=True)",
        "detail": "custard.utils.decorators",
        "documentation": {}
    },
    {
        "label": "slugify",
        "kind": 2,
        "importPath": "custard.utils.text",
        "description": "custard.utils.text",
        "peekOfCode": "def slugify(value: str, allow_dots: bool = False, allow_unicode: bool = False) -> str:\n    \"\"\"\n    Converts to lowercase, removes non-word characters (alphanumerics and\n    underscores) and converts spaces to hyphens. Also strips leading and\n    trailing whitespace. Modified to optionally allow dots.\n    Adapted from Django 1.9\n    \"\"\"\n    pattern: Pattern = _re_pattern_allow_dots if allow_dots else _re_pattern\n    value = str(value)\n    if allow_unicode:",
        "detail": "custard.utils.text",
        "documentation": {}
    },
    {
        "label": "loop",
        "kind": 5,
        "importPath": "examples.async_lur",
        "description": "examples.async_lur",
        "peekOfCode": "loop = asyncio.get_event_loop()\nloop.run_until_complete(main())\nloop.close()",
        "detail": "examples.async_lur",
        "documentation": {}
    },
    {
        "label": "_Test",
        "kind": 6,
        "importPath": "examples.decorator",
        "description": "examples.decorator",
        "peekOfCode": "class _Test(unittest.TestCase):\n    @unittest.skip\n    @bind_timeout(timeout=0.5)\n    def test_not_time_out(self):\n        print(\"\")\n        time.sleep(0.2)\n    @unittest.skip\n    @bind_timeout(timeout=0.5)\n    def test_time_out(self):\n        print(\"\")",
        "detail": "examples.decorator",
        "documentation": {}
    },
    {
        "label": "is_execute",
        "kind": 5,
        "importPath": "examples.dts",
        "description": "examples.dts",
        "peekOfCode": "is_execute = True\nsource_schema = \"dts\"\nsource_url = \"localhost\"\nsource_user = \"root\"\nsource_password = \"PassWord@Mysql123\"\nsource_port = 3306\ntarget_schema = \"dts_bak\"\ntarget_url = \"localhost\"\ntarget_user = \"root\"\ntarget_password = \"PassWord@Redis123\"",
        "detail": "examples.dts",
        "documentation": {}
    },
    {
        "label": "source_schema",
        "kind": 5,
        "importPath": "examples.dts",
        "description": "examples.dts",
        "peekOfCode": "source_schema = \"dts\"\nsource_url = \"localhost\"\nsource_user = \"root\"\nsource_password = \"PassWord@Mysql123\"\nsource_port = 3306\ntarget_schema = \"dts_bak\"\ntarget_url = \"localhost\"\ntarget_user = \"root\"\ntarget_password = \"PassWord@Redis123\"\ntarget_port = 3306",
        "detail": "examples.dts",
        "documentation": {}
    },
    {
        "label": "source_url",
        "kind": 5,
        "importPath": "examples.dts",
        "description": "examples.dts",
        "peekOfCode": "source_url = \"localhost\"\nsource_user = \"root\"\nsource_password = \"PassWord@Mysql123\"\nsource_port = 3306\ntarget_schema = \"dts_bak\"\ntarget_url = \"localhost\"\ntarget_user = \"root\"\ntarget_password = \"PassWord@Redis123\"\ntarget_port = 3306\nsql_inspect = MySqlInspect(source_schema, source_url, source_user, source_password, source_port,",
        "detail": "examples.dts",
        "documentation": {}
    },
    {
        "label": "source_user",
        "kind": 5,
        "importPath": "examples.dts",
        "description": "examples.dts",
        "peekOfCode": "source_user = \"root\"\nsource_password = \"PassWord@Mysql123\"\nsource_port = 3306\ntarget_schema = \"dts_bak\"\ntarget_url = \"localhost\"\ntarget_user = \"root\"\ntarget_password = \"PassWord@Redis123\"\ntarget_port = 3306\nsql_inspect = MySqlInspect(source_schema, source_url, source_user, source_password, source_port,\n                           target_schema, target_url, target_user, target_password, target_port)",
        "detail": "examples.dts",
        "documentation": {}
    },
    {
        "label": "source_password",
        "kind": 5,
        "importPath": "examples.dts",
        "description": "examples.dts",
        "peekOfCode": "source_password = \"PassWord@Mysql123\"\nsource_port = 3306\ntarget_schema = \"dts_bak\"\ntarget_url = \"localhost\"\ntarget_user = \"root\"\ntarget_password = \"PassWord@Redis123\"\ntarget_port = 3306\nsql_inspect = MySqlInspect(source_schema, source_url, source_user, source_password, source_port,\n                           target_schema, target_url, target_user, target_password, target_port)\nsql_util = MysqlUtil(source_schema, source_url, source_user, source_password, source_port)",
        "detail": "examples.dts",
        "documentation": {}
    },
    {
        "label": "source_port",
        "kind": 5,
        "importPath": "examples.dts",
        "description": "examples.dts",
        "peekOfCode": "source_port = 3306\ntarget_schema = \"dts_bak\"\ntarget_url = \"localhost\"\ntarget_user = \"root\"\ntarget_password = \"PassWord@Redis123\"\ntarget_port = 3306\nsql_inspect = MySqlInspect(source_schema, source_url, source_user, source_password, source_port,\n                           target_schema, target_url, target_user, target_password, target_port)\nsql_util = MysqlUtil(source_schema, source_url, source_user, source_password, source_port)\nsql_util.get_columns(\"pika_sensitive_word\")",
        "detail": "examples.dts",
        "documentation": {}
    },
    {
        "label": "target_schema",
        "kind": 5,
        "importPath": "examples.dts",
        "description": "examples.dts",
        "peekOfCode": "target_schema = \"dts_bak\"\ntarget_url = \"localhost\"\ntarget_user = \"root\"\ntarget_password = \"PassWord@Redis123\"\ntarget_port = 3306\nsql_inspect = MySqlInspect(source_schema, source_url, source_user, source_password, source_port,\n                           target_schema, target_url, target_user, target_password, target_port)\nsql_util = MysqlUtil(source_schema, source_url, source_user, source_password, source_port)\nsql_util.get_columns(\"pika_sensitive_word\")\nsql_inspect.inspect_table(is_execute)",
        "detail": "examples.dts",
        "documentation": {}
    },
    {
        "label": "target_url",
        "kind": 5,
        "importPath": "examples.dts",
        "description": "examples.dts",
        "peekOfCode": "target_url = \"localhost\"\ntarget_user = \"root\"\ntarget_password = \"PassWord@Redis123\"\ntarget_port = 3306\nsql_inspect = MySqlInspect(source_schema, source_url, source_user, source_password, source_port,\n                           target_schema, target_url, target_user, target_password, target_port)\nsql_util = MysqlUtil(source_schema, source_url, source_user, source_password, source_port)\nsql_util.get_columns(\"pika_sensitive_word\")\nsql_inspect.inspect_table(is_execute)",
        "detail": "examples.dts",
        "documentation": {}
    },
    {
        "label": "target_user",
        "kind": 5,
        "importPath": "examples.dts",
        "description": "examples.dts",
        "peekOfCode": "target_user = \"root\"\ntarget_password = \"PassWord@Redis123\"\ntarget_port = 3306\nsql_inspect = MySqlInspect(source_schema, source_url, source_user, source_password, source_port,\n                           target_schema, target_url, target_user, target_password, target_port)\nsql_util = MysqlUtil(source_schema, source_url, source_user, source_password, source_port)\nsql_util.get_columns(\"pika_sensitive_word\")\nsql_inspect.inspect_table(is_execute)",
        "detail": "examples.dts",
        "documentation": {}
    },
    {
        "label": "target_password",
        "kind": 5,
        "importPath": "examples.dts",
        "description": "examples.dts",
        "peekOfCode": "target_password = \"PassWord@Redis123\"\ntarget_port = 3306\nsql_inspect = MySqlInspect(source_schema, source_url, source_user, source_password, source_port,\n                           target_schema, target_url, target_user, target_password, target_port)\nsql_util = MysqlUtil(source_schema, source_url, source_user, source_password, source_port)\nsql_util.get_columns(\"pika_sensitive_word\")\nsql_inspect.inspect_table(is_execute)",
        "detail": "examples.dts",
        "documentation": {}
    },
    {
        "label": "target_port",
        "kind": 5,
        "importPath": "examples.dts",
        "description": "examples.dts",
        "peekOfCode": "target_port = 3306\nsql_inspect = MySqlInspect(source_schema, source_url, source_user, source_password, source_port,\n                           target_schema, target_url, target_user, target_password, target_port)\nsql_util = MysqlUtil(source_schema, source_url, source_user, source_password, source_port)\nsql_util.get_columns(\"pika_sensitive_word\")\nsql_inspect.inspect_table(is_execute)",
        "detail": "examples.dts",
        "documentation": {}
    },
    {
        "label": "sql_inspect",
        "kind": 5,
        "importPath": "examples.dts",
        "description": "examples.dts",
        "peekOfCode": "sql_inspect = MySqlInspect(source_schema, source_url, source_user, source_password, source_port,\n                           target_schema, target_url, target_user, target_password, target_port)\nsql_util = MysqlUtil(source_schema, source_url, source_user, source_password, source_port)\nsql_util.get_columns(\"pika_sensitive_word\")\nsql_inspect.inspect_table(is_execute)",
        "detail": "examples.dts",
        "documentation": {}
    },
    {
        "label": "sql_util",
        "kind": 5,
        "importPath": "examples.dts",
        "description": "examples.dts",
        "peekOfCode": "sql_util = MysqlUtil(source_schema, source_url, source_user, source_password, source_port)\nsql_util.get_columns(\"pika_sensitive_word\")\nsql_inspect.inspect_table(is_execute)",
        "detail": "examples.dts",
        "documentation": {}
    },
    {
        "label": "TestJsonLogger",
        "kind": 6,
        "importPath": "examples.json_logger",
        "description": "examples.json_logger",
        "peekOfCode": "class TestJsonLogger(unittest.TestCase):\n    def setUp(self):\n        self.logger = logging.getLogger(\"logging-test-{}\".format(random.randint(1, 101)))\n        self.logger.setLevel(logging.DEBUG)\n        self.buffer = StringIO()\n        self.logHandler = logging.StreamHandler(self.buffer)\n        self.logger.addHandler(self.logHandler)\n    def testDefaultFormat(self):\n        fr = jsonlogger.JsonFormatter()\n        self.logHandler.setFormatter(fr)",
        "detail": "examples.json_logger",
        "documentation": {}
    },
    {
        "label": "test4",
        "kind": 2,
        "importPath": "examples.kaptcha_execution_time",
        "description": "examples.kaptcha_execution_time",
        "peekOfCode": "def test4():\n    start = time.time()\n    obj = kaptcha.Captcha(gif=True)\n    for _ in range(1000):\n        obj.letter_digit()\n    print(f\"<gif>1000: {(time.time() - start) / 1000:.5f}\")\ndef test3():\n    start = time.time()\n    obj = kaptcha.Captcha(imageObj=True)\n    for _ in range(1000):",
        "detail": "examples.kaptcha_execution_time",
        "documentation": {}
    },
    {
        "label": "test3",
        "kind": 2,
        "importPath": "examples.kaptcha_execution_time",
        "description": "examples.kaptcha_execution_time",
        "peekOfCode": "def test3():\n    start = time.time()\n    obj = kaptcha.Captcha(imageObj=True)\n    for _ in range(1000):\n        obj.letter_digit()\n    print(f\"<Image>1000: {(time.time() - start) / 1000:.5f}\")\ndef test2():\n    start = time.time()\n    obj = kaptcha.Captcha(enhance=True, chips=15)\n    for _ in range(1000):",
        "detail": "examples.kaptcha_execution_time",
        "documentation": {}
    },
    {
        "label": "test2",
        "kind": 2,
        "importPath": "examples.kaptcha_execution_time",
        "description": "examples.kaptcha_execution_time",
        "peekOfCode": "def test2():\n    start = time.time()\n    obj = kaptcha.Captcha(enhance=True, chips=15)\n    for _ in range(1000):\n        obj.letter_digit()\n    print(f\"<>1000: {(time.time() - start) / 1000:.5f}\")\ndef test1():\n    start = time.time()\n    for _ in range(1000):\n        kaptcha.Captcha().letter_digit()",
        "detail": "examples.kaptcha_execution_time",
        "documentation": {}
    },
    {
        "label": "test1",
        "kind": 2,
        "importPath": "examples.kaptcha_execution_time",
        "description": "examples.kaptcha_execution_time",
        "peekOfCode": "def test1():\n    start = time.time()\n    for _ in range(1000):\n        kaptcha.Captcha().letter_digit()\n    print(f\"1000: {(time.time() - start) / 1000:.5f}\")\ntest1()\ntest2()\ntest3()\ntest4()",
        "detail": "examples.kaptcha_execution_time",
        "documentation": {}
    },
    {
        "label": "app",
        "kind": 5,
        "importPath": "examples.limiter",
        "description": "examples.limiter",
        "peekOfCode": "app = FastAPI()\n@app.on_event(\"startup\")\nasync def startup():\n    \"\"\"https://aioredis.readthedocs.io/en/latest/getting-started/\"\"\"\n    redis = await aioredis.from_url(\"redis://localhost:6379\", password=\"PassWord@Redis123\", encoding=\"utf8\")\n    await Limiter.init(redis)\n@app.on_event(\"shutdown\")\nasync def shutdown():\n    await Limiter.close()\n@app.get(\"/\", dependencies=[Depends(RateLimiter(counts=2, seconds=5))])",
        "detail": "examples.limiter",
        "documentation": {}
    },
    {
        "label": "Mock",
        "kind": 5,
        "importPath": "examples.mock",
        "description": "examples.mock",
        "peekOfCode": "Mock = Mock()\npprint(Mock.mock('@csentence '))\npprint(Mock.mock('@paragraph '))\npprint(Mock.mock('@cparagraph '))\npprint(Mock.mock('@sentence '))\npprint(Mock.mock('@csentence '))\npprint(Mock.mock('@word '))\npprint(Mock.mock('@cword '))\npprint(Mock.mock('@emoji '))\npprint(Mock.mock('@title '))",
        "detail": "examples.mock",
        "documentation": {}
    },
    {
        "label": "User",
        "kind": 6,
        "importPath": "examples.pagination_async_sqlalchemy",
        "description": "examples.pagination_async_sqlalchemy",
        "peekOfCode": "class User(Base):\n    __tablename__ = \"users\"\n    id = Column(Integer, primary_key=True, autoincrement=True)\n    name = Column(String, nullable=False)\n    email = Column(String, nullable=False)\nclass UserIn(BaseModel):\n    name: str\n    email: str\nclass UserOut(UserIn):\n    id: int",
        "detail": "examples.pagination_async_sqlalchemy",
        "documentation": {}
    },
    {
        "label": "UserIn",
        "kind": 6,
        "importPath": "examples.pagination_async_sqlalchemy",
        "description": "examples.pagination_async_sqlalchemy",
        "peekOfCode": "class UserIn(BaseModel):\n    name: str\n    email: str\nclass UserOut(UserIn):\n    id: int\n    class Config:\n        orm_mode = True\napp = FastAPI()\n@app.on_event(\"startup\")\nasync def on_startup() -> None:",
        "detail": "examples.pagination_async_sqlalchemy",
        "documentation": {}
    },
    {
        "label": "UserOut",
        "kind": 6,
        "importPath": "examples.pagination_async_sqlalchemy",
        "description": "examples.pagination_async_sqlalchemy",
        "peekOfCode": "class UserOut(UserIn):\n    id: int\n    class Config:\n        orm_mode = True\napp = FastAPI()\n@app.on_event(\"startup\")\nasync def on_startup() -> None:\n    async with engine.begin() as conn:\n        await conn.run_sync(Base.metadata.drop_all)\n        await conn.run_sync(Base.metadata.create_all)",
        "detail": "examples.pagination_async_sqlalchemy",
        "documentation": {}
    },
    {
        "label": "faker",
        "kind": 5,
        "importPath": "examples.pagination_async_sqlalchemy",
        "description": "examples.pagination_async_sqlalchemy",
        "peekOfCode": "faker = Faker()\nengine = create_async_engine(\"sqlite+aiosqlite:///.db\")\nasync_session = sessionmaker(engine, class_=AsyncSession)\nBase = declarative_base()\nclass User(Base):\n    __tablename__ = \"users\"\n    id = Column(Integer, primary_key=True, autoincrement=True)\n    name = Column(String, nullable=False)\n    email = Column(String, nullable=False)\nclass UserIn(BaseModel):",
        "detail": "examples.pagination_async_sqlalchemy",
        "documentation": {}
    },
    {
        "label": "engine",
        "kind": 5,
        "importPath": "examples.pagination_async_sqlalchemy",
        "description": "examples.pagination_async_sqlalchemy",
        "peekOfCode": "engine = create_async_engine(\"sqlite+aiosqlite:///.db\")\nasync_session = sessionmaker(engine, class_=AsyncSession)\nBase = declarative_base()\nclass User(Base):\n    __tablename__ = \"users\"\n    id = Column(Integer, primary_key=True, autoincrement=True)\n    name = Column(String, nullable=False)\n    email = Column(String, nullable=False)\nclass UserIn(BaseModel):\n    name: str",
        "detail": "examples.pagination_async_sqlalchemy",
        "documentation": {}
    },
    {
        "label": "async_session",
        "kind": 5,
        "importPath": "examples.pagination_async_sqlalchemy",
        "description": "examples.pagination_async_sqlalchemy",
        "peekOfCode": "async_session = sessionmaker(engine, class_=AsyncSession)\nBase = declarative_base()\nclass User(Base):\n    __tablename__ = \"users\"\n    id = Column(Integer, primary_key=True, autoincrement=True)\n    name = Column(String, nullable=False)\n    email = Column(String, nullable=False)\nclass UserIn(BaseModel):\n    name: str\n    email: str",
        "detail": "examples.pagination_async_sqlalchemy",
        "documentation": {}
    },
    {
        "label": "Base",
        "kind": 5,
        "importPath": "examples.pagination_async_sqlalchemy",
        "description": "examples.pagination_async_sqlalchemy",
        "peekOfCode": "Base = declarative_base()\nclass User(Base):\n    __tablename__ = \"users\"\n    id = Column(Integer, primary_key=True, autoincrement=True)\n    name = Column(String, nullable=False)\n    email = Column(String, nullable=False)\nclass UserIn(BaseModel):\n    name: str\n    email: str\nclass UserOut(UserIn):",
        "detail": "examples.pagination_async_sqlalchemy",
        "documentation": {}
    },
    {
        "label": "app",
        "kind": 5,
        "importPath": "examples.pagination_async_sqlalchemy",
        "description": "examples.pagination_async_sqlalchemy",
        "peekOfCode": "app = FastAPI()\n@app.on_event(\"startup\")\nasync def on_startup() -> None:\n    async with engine.begin() as conn:\n        await conn.run_sync(Base.metadata.drop_all)\n        await conn.run_sync(Base.metadata.create_all)\n    async with async_session() as session:\n        session.add_all([User(name=faker.name(), email=faker.email()) for _ in range(10)])\n        await session.commit()\nasync def get_db() -> AsyncIterator[AsyncSession]:",
        "detail": "examples.pagination_async_sqlalchemy",
        "documentation": {}
    },
    {
        "label": "User",
        "kind": 6,
        "importPath": "examples.pagination_sqlalchemy",
        "description": "examples.pagination_sqlalchemy",
        "peekOfCode": "class User(Base):\n    __tablename__ = \"users\"\n    id = Column(Integer, primary_key=True, autoincrement=True)\n    name = Column(String, nullable=False)\n    email = Column(String, nullable=False)\nBase.metadata.drop_all()\nBase.metadata.create_all()\nclass UserIn(BaseModel):\n    name: str\n    email: str",
        "detail": "examples.pagination_sqlalchemy",
        "documentation": {}
    },
    {
        "label": "UserIn",
        "kind": 6,
        "importPath": "examples.pagination_sqlalchemy",
        "description": "examples.pagination_sqlalchemy",
        "peekOfCode": "class UserIn(BaseModel):\n    name: str\n    email: str\nclass UserOut(UserIn):\n    id: int\n    class Config:\n        orm_mode = True\napp = FastAPI()\n@app.on_event(\"startup\")\ndef on_startup() -> None:",
        "detail": "examples.pagination_sqlalchemy",
        "documentation": {}
    },
    {
        "label": "UserOut",
        "kind": 6,
        "importPath": "examples.pagination_sqlalchemy",
        "description": "examples.pagination_sqlalchemy",
        "peekOfCode": "class UserOut(UserIn):\n    id: int\n    class Config:\n        orm_mode = True\napp = FastAPI()\n@app.on_event(\"startup\")\ndef on_startup() -> None:\n    session = SessionLocal()\n    session.add_all([User(name=faker.name(), email=faker.email()) for _ in range(100)])\n    session.flush()",
        "detail": "examples.pagination_sqlalchemy",
        "documentation": {}
    },
    {
        "label": "on_startup",
        "kind": 2,
        "importPath": "examples.pagination_sqlalchemy",
        "description": "examples.pagination_sqlalchemy",
        "peekOfCode": "def on_startup() -> None:\n    session = SessionLocal()\n    session.add_all([User(name=faker.name(), email=faker.email()) for _ in range(100)])\n    session.flush()\n    session.close()\ndef get_db() -> Iterator[Session]:\n    db = SessionLocal()\n    try:\n        yield db\n    finally:",
        "detail": "examples.pagination_sqlalchemy",
        "documentation": {}
    },
    {
        "label": "get_db",
        "kind": 2,
        "importPath": "examples.pagination_sqlalchemy",
        "description": "examples.pagination_sqlalchemy",
        "peekOfCode": "def get_db() -> Iterator[Session]:\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n@app.post(\"/users\", response_model=UserOut)\ndef create_user(user_in: UserIn, db: Session = Depends(get_db)) -> User:\n    user = User(name=user_in.name, email=user_in.email)\n    db.add(user)",
        "detail": "examples.pagination_sqlalchemy",
        "documentation": {}
    },
    {
        "label": "create_user",
        "kind": 2,
        "importPath": "examples.pagination_sqlalchemy",
        "description": "examples.pagination_sqlalchemy",
        "peekOfCode": "def create_user(user_in: UserIn, db: Session = Depends(get_db)) -> User:\n    user = User(name=user_in.name, email=user_in.email)\n    db.add(user)\n    db.flush()\n    return user\n@app.get(\"/users/default\", response_model=Page[UserOut])\n@app.get(\"/users/limit-offset\", response_model=LimitOffsetPage[UserOut])\ndef get_users(db: Session = Depends(get_db)) -> Any:\n    return paginate(db.query(User))\nadd_pagination(app)",
        "detail": "examples.pagination_sqlalchemy",
        "documentation": {}
    },
    {
        "label": "get_users",
        "kind": 2,
        "importPath": "examples.pagination_sqlalchemy",
        "description": "examples.pagination_sqlalchemy",
        "peekOfCode": "def get_users(db: Session = Depends(get_db)) -> Any:\n    return paginate(db.query(User))\nadd_pagination(app)\nif __name__ == \"__main__\":\n    uvicorn.run(\"pagination_sqlalchemy:app\")",
        "detail": "examples.pagination_sqlalchemy",
        "documentation": {}
    },
    {
        "label": "faker",
        "kind": 5,
        "importPath": "examples.pagination_sqlalchemy",
        "description": "examples.pagination_sqlalchemy",
        "peekOfCode": "faker = Faker()\nengine = create_engine(\"sqlite:///.db\", connect_args={\"check_same_thread\": False})\nSessionLocal = sessionmaker(autocommit=True, autoflush=True, bind=engine)\nBase = declarative_base(bind=engine)\nclass User(Base):\n    __tablename__ = \"users\"\n    id = Column(Integer, primary_key=True, autoincrement=True)\n    name = Column(String, nullable=False)\n    email = Column(String, nullable=False)\nBase.metadata.drop_all()",
        "detail": "examples.pagination_sqlalchemy",
        "documentation": {}
    },
    {
        "label": "engine",
        "kind": 5,
        "importPath": "examples.pagination_sqlalchemy",
        "description": "examples.pagination_sqlalchemy",
        "peekOfCode": "engine = create_engine(\"sqlite:///.db\", connect_args={\"check_same_thread\": False})\nSessionLocal = sessionmaker(autocommit=True, autoflush=True, bind=engine)\nBase = declarative_base(bind=engine)\nclass User(Base):\n    __tablename__ = \"users\"\n    id = Column(Integer, primary_key=True, autoincrement=True)\n    name = Column(String, nullable=False)\n    email = Column(String, nullable=False)\nBase.metadata.drop_all()\nBase.metadata.create_all()",
        "detail": "examples.pagination_sqlalchemy",
        "documentation": {}
    },
    {
        "label": "SessionLocal",
        "kind": 5,
        "importPath": "examples.pagination_sqlalchemy",
        "description": "examples.pagination_sqlalchemy",
        "peekOfCode": "SessionLocal = sessionmaker(autocommit=True, autoflush=True, bind=engine)\nBase = declarative_base(bind=engine)\nclass User(Base):\n    __tablename__ = \"users\"\n    id = Column(Integer, primary_key=True, autoincrement=True)\n    name = Column(String, nullable=False)\n    email = Column(String, nullable=False)\nBase.metadata.drop_all()\nBase.metadata.create_all()\nclass UserIn(BaseModel):",
        "detail": "examples.pagination_sqlalchemy",
        "documentation": {}
    },
    {
        "label": "Base",
        "kind": 5,
        "importPath": "examples.pagination_sqlalchemy",
        "description": "examples.pagination_sqlalchemy",
        "peekOfCode": "Base = declarative_base(bind=engine)\nclass User(Base):\n    __tablename__ = \"users\"\n    id = Column(Integer, primary_key=True, autoincrement=True)\n    name = Column(String, nullable=False)\n    email = Column(String, nullable=False)\nBase.metadata.drop_all()\nBase.metadata.create_all()\nclass UserIn(BaseModel):\n    name: str",
        "detail": "examples.pagination_sqlalchemy",
        "documentation": {}
    },
    {
        "label": "app",
        "kind": 5,
        "importPath": "examples.pagination_sqlalchemy",
        "description": "examples.pagination_sqlalchemy",
        "peekOfCode": "app = FastAPI()\n@app.on_event(\"startup\")\ndef on_startup() -> None:\n    session = SessionLocal()\n    session.add_all([User(name=faker.name(), email=faker.email()) for _ in range(100)])\n    session.flush()\n    session.close()\ndef get_db() -> Iterator[Session]:\n    db = SessionLocal()\n    try:",
        "detail": "examples.pagination_sqlalchemy",
        "documentation": {}
    },
    {
        "label": "url",
        "kind": 5,
        "importPath": "examples.swagger_online_change",
        "description": "examples.swagger_online_change",
        "peekOfCode": "url = 'http://xxxx/doctor-api/swagger/doc.json'\nswagger = custard.swagger_parse(url)\nprint('{}'.format(len(swagger.apis)))\napi_path = 'doctor-api.json'\nwith open(api_path, mode='w', encoding='utf8') as f:\n    f.write(json.dumps(swagger.apis, indent=4, ensure_ascii=False))",
        "detail": "examples.swagger_online_change",
        "documentation": {}
    },
    {
        "label": "swagger",
        "kind": 5,
        "importPath": "examples.swagger_online_change",
        "description": "examples.swagger_online_change",
        "peekOfCode": "swagger = custard.swagger_parse(url)\nprint('{}'.format(len(swagger.apis)))\napi_path = 'doctor-api.json'\nwith open(api_path, mode='w', encoding='utf8') as f:\n    f.write(json.dumps(swagger.apis, indent=4, ensure_ascii=False))",
        "detail": "examples.swagger_online_change",
        "documentation": {}
    },
    {
        "label": "api_path",
        "kind": 5,
        "importPath": "examples.swagger_online_change",
        "description": "examples.swagger_online_change",
        "peekOfCode": "api_path = 'doctor-api.json'\nwith open(api_path, mode='w', encoding='utf8') as f:\n    f.write(json.dumps(swagger.apis, indent=4, ensure_ascii=False))",
        "detail": "examples.swagger_online_change",
        "documentation": {}
    },
    {
        "label": "APITestCase",
        "kind": 6,
        "importPath": "examples.swagger_usabletest",
        "description": "examples.swagger_usabletest",
        "peekOfCode": "class APITestCase(unittest.TestCase):\n    default_file = './file.txt'\n    result_path = 'result/'\n    @classmethod\n    def setUpClass(cls, run_host=None):\n        warnings.simplefilter('ignore', ResourceWarning)\n        # \n        if not os.path.exists(cls.default_file):\n            with open(cls.default_file, mode='w') as f:\n                f.write('Hello world!')",
        "detail": "examples.swagger_usabletest",
        "documentation": {}
    }
]